{
 "Description": "(DEV-SO0111R) AWS Security Hub Automated Response & Remediation Remediation Runbooks, v1.5.1",
 "AWSTemplateFormatVersion": "2010-09-09",
 "Parameters": {
  "WaitProviderServiceToken": {
   "Type": "String"
  }
 },
 "Resources": {
  "ASRCreateCloudTrailMultiRegionTrail": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-CreateCloudTrailMultiRegionTrail\n## What does this document do?\nCreates a multi-region trail with KMS encryption and enables CloudTrail\nNote: this remediation will create a NEW trail.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* KMSKeyArn (from SSM): Arn of the KMS key to be used to encrypt data\n\n## Security Standards / Controls\n* AFSBP v1.0.0:   CloudTrail.1\n* CIS v1.2.0:     2.1\n* PCI:            CloudTrail.2\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "KMSKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for this remediation",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      },
      "AWSPartition": {
       "type": "String",
       "default": "aws",
       "description": "Partition for creation of ARNs.",
       "allowedValues": [
        "aws",
        "aws-cn",
        "aws-us-gov"
       ]
      }
     },
     "outputs": [
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "CreateLoggingBucket",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "LoggingBucketName",
         "Selector": "$.Payload.logging_bucket",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "account": "{{global:ACCOUNT_ID}}",
         "region": "{{global:REGION}}",
         "kms_key_arn": "{{KMSKeyArn}}"
        },
        "Runtime": "python3.8",
        "Handler": "create_logging_bucket",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nERROR_CREATING_BUCKET = \"Error creating bucket \"\n\n\ndef connect_to_s3(boto_config):\n    return boto3.client(\"s3\", config=boto_config)\n\n\ndef create_logging_bucket(event, _):\n    boto_config = Config(retries={\"mode\": \"standard\"})\n    s3 = connect_to_s3(boto_config)\n\n    kms_key_arn = event[\"kms_key_arn\"]\n    aws_account = event[\"account\"]\n    aws_region = event[\"region\"]\n    bucket_name = \"so0111-access-logs-\" + aws_region + \"-\" + aws_account\n\n    if create_bucket(s3, bucket_name, aws_region) == \"bucket_exists\":\n        return {\"logging_bucket\": bucket_name}\n    encrypt_bucket(s3, bucket_name, kms_key_arn)\n    put_access_block(s3, bucket_name)\n    put_bucket_acl(s3, bucket_name)\n\n    return {\"logging_bucket\": bucket_name}\n\n\ndef create_bucket(s3, bucket_name, aws_region):\n    try:\n        kwargs = {\"Bucket\": bucket_name, \"ACL\": \"private\"}\n        if aws_region != \"us-east-1\":\n            kwargs[\"CreateBucketConfiguration\"] = {\"LocationConstraint\": aws_region}\n\n        s3.create_bucket(**kwargs)\n\n    except ClientError as ex:\n        exception_type = ex.response[\"Error\"][\"Code\"]\n        # bucket already exists - return\n        if exception_type == \"BucketAlreadyOwnedByYou\":\n            print(\"Bucket \" + bucket_name + \" already exists and is owned by you\")\n            return \"bucket_exists\"\n        else:\n            print(ex)\n            exit(ERROR_CREATING_BUCKET + bucket_name)\n    except Exception as e:\n        print(e)\n        exit(ERROR_CREATING_BUCKET + bucket_name)\n\n\ndef encrypt_bucket(s3, bucket_name, kms_key_arn):\n    try:\n        s3.put_bucket_encryption(\n            Bucket=bucket_name,\n            ServerSideEncryptionConfiguration={\n                \"Rules\": [\n                    {\n                        \"ApplyServerSideEncryptionByDefault\": {\n                            \"SSEAlgorithm\": \"aws:kms\",\n                            \"KMSMasterKeyID\": kms_key_arn.split(\"key/\")[1],\n                        }\n                    }\n                ]\n            },\n        )\n    except Exception as e:\n        exit(\"Error encrypting bucket \" + bucket_name + \": \" + str(e))\n\n\ndef put_access_block(s3, bucket_name):\n    try:\n        s3.put_public_access_block(\n            Bucket=bucket_name,\n            PublicAccessBlockConfiguration={\n                \"BlockPublicAcls\": True,\n                \"IgnorePublicAcls\": True,\n                \"BlockPublicPolicy\": True,\n                \"RestrictPublicBuckets\": True,\n            },\n        )\n    except Exception as e:\n        exit(\n            \"Error setting public access block for bucket \"\n            + bucket_name\n            + \": \"\n            + str(e)\n        )\n\n\ndef put_bucket_acl(s3, bucket_name):\n    try:\n        s3.put_bucket_acl(\n            Bucket=bucket_name,\n            GrantReadACP=\"uri=http://acs.amazonaws.com/groups/s3/LogDelivery\",\n            GrantWrite=\"uri=http://acs.amazonaws.com/groups/s3/LogDelivery\",\n        )\n    except Exception as e:\n        exit(\"Error setting ACL for bucket \" + bucket_name + \": \" + str(e))"
       },
       "isEnd": false
      },
      {
       "name": "CreateCloudTrailBucket",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "CloudTrailBucketName",
         "Selector": "$.Payload.cloudtrail_bucket",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "account": "{{global:ACCOUNT_ID}}",
         "region": "{{global:REGION}}",
         "kms_key_arn": "{{KMSKeyArn}}",
         "logging_bucket": "{{CreateLoggingBucket.LoggingBucketName}}"
        },
        "Runtime": "python3.8",
        "Handler": "create_encrypted_bucket",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\n\ndef connect_to_s3(boto_config):\n    return boto3.client(\"s3\", config=boto_config)\n\n\ndef create_encrypted_bucket(event, _):\n    boto_config = Config(retries={\"mode\": \"standard\"})\n    s3 = connect_to_s3(boto_config)\n\n    kms_key_arn = event[\"kms_key_arn\"]\n    aws_account = event[\"account\"]\n    aws_region = event[\"region\"]\n    logging_bucket = event[\"logging_bucket\"]\n    bucket_name = \"so0111-aws-cloudtrail-\" + aws_account\n\n    if create_s3_bucket(s3, bucket_name, aws_region) == \"bucket_exists\":\n        return {\"cloudtrail_bucket\": bucket_name}\n    put_bucket_encryption(s3, bucket_name, kms_key_arn)\n    put_public_access_block(s3, bucket_name)\n    put_bucket_logging(s3, bucket_name, logging_bucket)\n\n    return {\"cloudtrail_bucket\": bucket_name}\n\n\ndef create_s3_bucket(s3, bucket_name, aws_region):\n    try:\n        kwargs = {\"Bucket\": bucket_name, \"ACL\": \"private\"}\n        if aws_region != \"us-east-1\":\n            kwargs[\"CreateBucketConfiguration\"] = {\"LocationConstraint\": aws_region}\n\n        s3.create_bucket(**kwargs)\n\n    except ClientError as client_ex:\n        exception_type = client_ex.response[\"Error\"][\"Code\"]\n        if exception_type == \"BucketAlreadyOwnedByYou\":\n            print(\"Bucket \" + bucket_name + \" already exists and is owned by you\")\n            return \"bucket_exists\"\n        else:\n            exit(\"Error creating bucket \" + bucket_name + \" \" + str(client_ex))\n    except Exception as e:\n        exit(\"Error creating bucket \" + bucket_name + \" \" + str(e))\n\n\ndef put_bucket_encryption(s3, bucket_name, kms_key_arn):\n    try:\n        s3.put_bucket_encryption(\n            Bucket=bucket_name,\n            ServerSideEncryptionConfiguration={\n                \"Rules\": [\n                    {\n                        \"ApplyServerSideEncryptionByDefault\": {\n                            \"SSEAlgorithm\": \"aws:kms\",\n                            \"KMSMasterKeyID\": kms_key_arn.split(\"key/\")[1],\n                        }\n                    }\n                ]\n            },\n        )\n    except Exception as e:\n        print(e)\n        exit(\n            \"Error applying encryption to bucket \"\n            + bucket_name\n            + \" with key \"\n            + kms_key_arn\n        )\n\n\ndef put_public_access_block(s3, bucket_name):\n    try:\n        s3.put_public_access_block(\n            Bucket=bucket_name,\n            PublicAccessBlockConfiguration={\n                \"BlockPublicAcls\": True,\n                \"IgnorePublicAcls\": True,\n                \"BlockPublicPolicy\": True,\n                \"RestrictPublicBuckets\": True,\n            },\n        )\n    except Exception as e:\n        exit(f\"Error setting public access block for bucket {bucket_name}: {str(e)}\")\n\n\ndef put_bucket_logging(s3, bucket_name, logging_bucket):\n    try:\n        s3.put_bucket_logging(\n            Bucket=bucket_name,\n            BucketLoggingStatus={\n                \"LoggingEnabled\": {\n                    \"TargetBucket\": logging_bucket,\n                    \"TargetPrefix\": \"cloudtrail-access-logs\",\n                }\n            },\n        )\n    except Exception as e:\n        print(e)\n        exit(\"Error setting public access block for bucket \" + bucket_name)"
       },
       "isEnd": false
      },
      {
       "name": "CreateCloudTrailBucketPolicy",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "cloudtrail_bucket": "{{CreateCloudTrailBucket.CloudTrailBucketName}}",
         "partition": "{{AWSPartition}}",
         "account": "{{global:ACCOUNT_ID}}"
        },
        "Runtime": "python3.8",
        "Handler": "create_bucket_policy",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\ndef connect_to_s3(boto_config):\n    return boto3.client('s3', config=boto_config)\n\ndef create_bucket_policy(event, _):\n\n    boto_config = Config(\n        retries ={\n          'mode': 'standard'\n        }\n    )\n    s3 = connect_to_s3(boto_config)\n\n    cloudtrail_bucket = event['cloudtrail_bucket']\n    aws_partition = event['partition']\n    aws_account = event['account']\n    try:\n        bucket_policy = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Sid\": \"AWSCloudTrailAclCheck20150319\",\n                    \"Effect\": \"Allow\",\n                    \"Principal\": {\n                        \"Service\": [\n                            \"cloudtrail.amazonaws.com\"\n                        ]\n                    },\n                    \"Action\": \"s3:GetBucketAcl\",\n                    \"Resource\": \"arn:\" + aws_partition + \":s3:::\" + cloudtrail_bucket\n                },\n                {\n                    \"Sid\": \"AWSCloudTrailWrite20150319\",\n                    \"Effect\": \"Allow\",\n                    \"Principal\": {\n                        \"Service\": [\n                            \"cloudtrail.amazonaws.com\"\n                        ]\n                    },\n                    \"Action\": \"s3:PutObject\",\n                    \"Resource\": \"arn:\" + aws_partition + \":s3:::\" + cloudtrail_bucket + \"/AWSLogs/\" + aws_account + \"/*\",\n                    \"Condition\": {\n                        \"StringEquals\": {\n                            \"s3:x-amz-acl\": \"bucket-owner-full-control\"\n                        },\n                    }\n                },\n                {\n                    \"Sid\": \"AllowSSLRequestsOnly\",\n                    \"Effect\": \"Deny\",\n                    \"Principal\": \"*\",\n                    \"Action\": \"s3:*\",\n                    \"Resource\": [\"arn:\" + aws_partition + \":s3:::\" + cloudtrail_bucket ,\"arn:\" + aws_partition + \":s3:::\" + cloudtrail_bucket + \"/*\"],\n                    \"Condition\": {\n                        \"Bool\": {\n                            \"aws:SecureTransport\": \"false\"\n                        }\n                    }\n                }\n            ]\n        }\n        s3.put_bucket_policy(\n            Bucket=cloudtrail_bucket,\n            Policy=json.dumps(bucket_policy)\n        )\n        return {\n            \"output\": {\n                \"Message\": f'Set bucket policy for bucket {cloudtrail_bucket}'\n            }\n        }\n    except Exception as e:\n        print(e)\n        exit('PutBucketPolicy failed: ' + str(e))"
       },
       "isEnd": false
      },
      {
       "name": "EnableCloudTrail",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "CloudTrailBucketName",
         "Selector": "$.Payload.cloudtrail_bucket",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "cloudtrail_bucket": "{{CreateCloudTrailBucket.CloudTrailBucketName}}",
         "kms_key_arn": "{{KMSKeyArn}}"
        },
        "Runtime": "python3.8",
        "Handler": "enable_cloudtrail",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\ndef connect_to_cloudtrail(boto_config):\n    return boto3.client('cloudtrail', config=boto_config)\n\ndef enable_cloudtrail(event, _):\n\n    boto_config = Config(\n        retries ={\n          'mode': 'standard'\n        }\n    )\n    ct = connect_to_cloudtrail(boto_config)\n\n    try:\n        ct.create_trail(\n            Name='multi-region-cloud-trail',\n            S3BucketName=event['cloudtrail_bucket'],\n            IncludeGlobalServiceEvents=True,\n            EnableLogFileValidation=True,\n            IsMultiRegionTrail=True,\n            KmsKeyId=event['kms_key_arn']\n        )\n        ct.start_logging(\n            Name='multi-region-cloud-trail'\n        )\n        return {\n            \"output\": {\n                \"Message\": f'CloudTrail Trail multi-region-cloud-trail created'\n            }\n        }\n    except Exception as e:\n        exit('Error enabling AWS Config: ' + str(e))"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "cloudtrail_bucket": "{{CreateCloudTrailBucket.CloudTrailBucketName}}",
         "logging_bucket": "{{CreateLoggingBucket.LoggingBucketName}}"
        },
        "Runtime": "python3.8",
        "Handler": "process_results",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\ndef process_results(event, _):\n  print(f'Created encrypted CloudTrail bucket {event[\"cloudtrail_bucket\"]}')\n  print(f'Created access logging for CloudTrail bucket in bucket {event[\"logging_bucket\"]}')\n  print('Enabled multi-region AWS CloudTrail')\n  return {\n    \"response\": {\n      \"message\": \"AWS CloudTrail successfully enabled\",\n      \"status\": \"Success\"\n    }\n  }"
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-CreateCloudTrailMultiRegionTrail",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR CreateCloudTrailMultiRegionTrail"
   }
  },
  "ASRCreateLogMetricFilterAndAlarm": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-CreateLogMetricFilterAndAlarm\n## What does this document do?\nCreates a metric filter for a given log group and also creates and alarm for the metric.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* CloudWatch Log Group Name: Name of the CloudWatch log group to use to create metric filter\n* Alarm Value: Threshhold value for the creating an alarm for the CloudWatch Alarm\n\n## Security Standards / Controls\n* CIS v1.2.0:     3.1-3.14\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "LogGroupName": {
       "type": "String",
       "description": "Name of the log group to be used to create metric filter",
       "allowedPattern": ".*"
      },
      "FilterName": {
       "type": "String",
       "description": "Name for the metric filter",
       "allowedPattern": ".*"
      },
      "FilterPattern": {
       "type": "String",
       "description": "Filter pattern to create metric filter",
       "allowedPattern": ".*"
      },
      "MetricName": {
       "type": "String",
       "description": "Name of the metric for metric filter",
       "allowedPattern": ".*"
      },
      "MetricValue": {
       "type": "Integer",
       "description": "Value of the metric for metric filter"
      },
      "MetricNamespace": {
       "type": "String",
       "description": "Namespace where the metrics will be sent",
       "allowedPattern": ".*"
      },
      "AlarmName": {
       "type": "String",
       "description": "Name of the Alarm to be created for the metric filter",
       "allowedPattern": ".*"
      },
      "AlarmDesc": {
       "type": "String",
       "description": "Description of the Alarm to be created for the metric filter",
       "allowedPattern": ".*"
      },
      "AlarmThreshold": {
       "type": "Integer",
       "description": "Threshold value for the alarm"
      },
      "KMSKeyArn": {
       "type": "String",
       "description": "The ARN of a KMS key to use for encryption of the SNS Topic and Config bucket",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      },
      "SNSTopicName": {
       "type": "String",
       "allowedPattern": "^[a-zA-Z0-9][a-zA-Z0-9-_]{0,255}$"
      }
     },
     "mainSteps": [
      {
       "name": "CreateTopic",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "TopicArn",
         "Selector": "$.Payload.topic_arn",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "kms_key_arn": "{{KMSKeyArn}}",
         "topic_name": "{{SNSTopicName}}"
        },
        "Runtime": "python3.8",
        "Handler": "create_encrypted_topic",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nboto_config = Config(\n    retries ={\n        'mode': 'standard'\n    }\n)\n\ndef connect_to_sns():\n    return boto3.client('sns', config=boto_config)\n\ndef connect_to_ssm():\n    return boto3.client('ssm', config=boto_config)\n\ndef create_encrypted_topic(event, _):\n\n    kms_key_arn = event['kms_key_arn']\n    new_topic = False\n    topic_arn = ''\n    topic_name = event['topic_name']\n\n    try:\n        sns = connect_to_sns()\n        topic_arn = sns.create_topic(\n            Name=topic_name,\n            Attributes={\n                'KmsMasterKeyId': kms_key_arn.split('key/')[1]\n            }\n        )['TopicArn']\n        new_topic = True\n\n    except ClientError as client_exception:\n        exception_type = client_exception.response['Error']['Code']\n        if exception_type == 'InvalidParameter':\n            print(f'Topic {topic_name} already exists. This remediation may have been run before.')\n            print('Ignoring exception - remediation continues.')\n            topic_arn = sns.create_topic(\n                Name=topic_name\n            )['TopicArn']\n        else:\n            exit(f'ERROR: Unhandled client exception: {client_exception}')\n\n    except Exception as e:\n        exit(f'ERROR: could not create SNS Topic {topic_name}: {str(e)}')\n\n    if new_topic:\n        try:\n            ssm = connect_to_ssm()\n            ssm.put_parameter(\n                Name='/Solutions/SO0111/SNS_Topic_CIS3.x',\n                Description='SNS Topic for AWS Config updates',\n                Type='String',\n                Overwrite=True,\n                Value=topic_arn\n            )\n        except Exception as e:\n            exit(f'ERROR: could not create SNS Topic {topic_name}: {str(e)}')\n\n    create_topic_policy(topic_arn)\n\n    return {\"topic_arn\": topic_arn}\n\ndef create_topic_policy(topic_arn):\n    sns = connect_to_sns()\n    try:\n        topic_policy = {\n            \"Id\": \"Policy_ID\",\n            \"Statement\": [\n            {\n                \"Sid\": \"AWSConfigSNSPolicy\",\n                \"Effect\": \"Allow\",\n                \"Principal\": {\n                \"Service\": \"cloudwatch.amazonaws.com\"\n                },\n                \"Action\": \"SNS:Publish\",\n                \"Resource\": topic_arn,\n            }]\n        }\n\n        sns.set_topic_attributes(\n            TopicArn=topic_arn,\n            AttributeName='Policy',\n            AttributeValue=json.dumps(topic_policy)\n        )\n    except Exception as e:\n        exit(f'ERROR: Failed to SetTopicAttributes for {topic_arn}: {str(e)}')"
       }
      },
      {
       "name": "CreateMetricFilerAndAlarm",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "LogGroupName": "{{LogGroupName}}",
         "FilterName": "{{FilterName}}",
         "FilterPattern": "{{FilterPattern}}",
         "MetricName": "{{MetricName}}",
         "MetricNamespace": "{{MetricNamespace}}",
         "MetricValue": "{{MetricValue}}",
         "AlarmName": "{{AlarmName}}",
         "AlarmDesc": "{{AlarmDesc}}",
         "AlarmThreshold": "{{AlarmThreshold}}",
         "TopicArn": "{{CreateTopic.TopicArn}}"
        },
        "Runtime": "python3.8",
        "Handler": "verify",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nimport logging\nimport os\nfrom botocore.config import Config\n\nboto_config = Config(\n    retries={\n        'max_attempts': 10,\n        'mode': 'standard'\n    }\n)\n\nlog = logging.getLogger()\nLOG_LEVEL = str(os.getenv('LogLevel', 'INFO'))\nlog.setLevel(LOG_LEVEL)\n\n\ndef get_service_client(service_name):\n    \"\"\"\n    Returns the service client for given the service name\n    :param service_name: name of the service\n    :return: service client\n    \"\"\"\n    log.debug(\"Getting the service client for service: {}\".format(service_name))\n    return boto3.client(service_name, config=boto_config)\n\n\ndef put_metric_filter(cw_log_group, filter_name, filter_pattern, metric_name, metric_namespace, metric_value):\n    \"\"\"\n    Puts the metric filter on the CloudWatch log group with provided values\n    :param cw_log_group: Name of the CloudWatch log group\n    :param filter_name: Name of the filter\n    :param filter_pattern: Pattern for the filter\n    :param metric_name: Name of the metric\n    :param metric_namespace: Namespace where metric is logged\n    :param metric_value: Value to be logged for the metric\n    \"\"\"\n    logs_client = get_service_client('logs')\n    log.debug(\"Putting the metric filter with values: {}\".format([\n        cw_log_group, filter_name, filter_pattern, metric_name, metric_namespace, metric_value]))\n    try:\n        logs_client.put_metric_filter(\n            logGroupName=cw_log_group,\n            filterName=filter_name,\n            filterPattern=filter_pattern,\n            metricTransformations=[\n                {\n                    'metricName': metric_name,\n                    'metricNamespace': metric_namespace,\n                    'metricValue': str(metric_value),\n                    'unit': 'Count'\n                }\n            ]\n        )\n    except Exception as e:\n        exit(\"Exception occurred while putting metric filter: \" + str(e))\n    log.debug(\"Successfully added the metric filter.\")\n\n\ndef put_metric_alarm(alarm_name, alarm_desc, alarm_threshold, metric_name, metric_namespace, topic_arn):\n    \"\"\"\n    Puts the metric alarm for the metric name with provided values\n    :param alarm_name: Name for the alarm\n    :param alarm_desc: Description for the alarm\n    :param alarm_threshold: Threshold value for the alarm\n    :param metric_name: Name of the metric\n    :param metric_namespace: Namespace where metric is logged\n    \"\"\"\n    cw_client = get_service_client('cloudwatch')\n    log.debug(\"Putting the metric alarm with values {}\".format(\n        [alarm_name, alarm_desc, alarm_threshold, metric_name, metric_namespace]))\n    try:\n        cw_client.put_metric_alarm(\n            AlarmName=alarm_name,\n            AlarmDescription=alarm_desc,\n            ActionsEnabled=True,\n            OKActions=[\n                topic_arn\n            ],\n            AlarmActions=[\n                topic_arn\n            ],\n            MetricName=metric_name,\n            Namespace=metric_namespace,\n            Statistic='Sum',\n            Period=300,\n            Unit='Count',\n            EvaluationPeriods=12,\n            DatapointsToAlarm=1,\n            Threshold=alarm_threshold,\n            ComparisonOperator='GreaterThanOrEqualToThreshold',\n            TreatMissingData='notBreaching'\n        )\n    except Exception as e:\n        exit(\"Exception occurred while putting metric alarm: \" + str(e))\n    log.debug(\"Successfully added metric alarm.\")\n\n\ndef verify(event, _):\n    log.info(\"Begin handler\")\n    log.debug(\"====Print Event====\")\n    log.debug(event)\n\n    filter_name = event['FilterName']\n    filter_pattern = event['FilterPattern']\n    metric_name = event['MetricName']\n    metric_namespace = event['MetricNamespace']\n    metric_value = event['MetricValue']\n    alarm_name = event['AlarmName']\n    alarm_desc = event['AlarmDesc']\n    alarm_threshold = event['AlarmThreshold']\n    cw_log_group = event['LogGroupName']\n    topic_arn = event['TopicArn']\n\n    put_metric_filter(cw_log_group, filter_name, filter_pattern, metric_name, metric_namespace, metric_value)\n    put_metric_alarm(alarm_name, alarm_desc, alarm_threshold, metric_name, metric_namespace, topic_arn)\n    return {\n        \"response\": {\n            \"message\": f'Created filter {event[\"FilterName\"]} for metric {event[\"MetricName\"]}, and alarm {event[\"AlarmName\"]}',\n            \"status\": \"Success\"\n        }\n    }"
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-CreateLogMetricFilterAndAlarm",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR CreateLogMetricFilterAndAlarm"
   }
  },
  "ASREnableAutoScalingGroupELBHealthCheck": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-EnableAutoScalingGroupELBHealthCheck\n\n## What does this document do?\nThis runbook enables health checks for the Amazon EC2 Auto Scaling (Auto Scaling) group you specify using the [UpdateAutoScalingGroup](https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_UpdateAutoScalingGroup.html) API.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n* AutoScalingGroupARN: (Required) The Amazon Resource Name (ARN) of the auto scaling group that you want to enable health checks on.\n* HealthCheckGracePeriod: (Optional) The amount of time, in seconds, that Auto Scaling waits before checking the health status of an Amazon Elastic Compute Cloud (Amazon EC2) instance that has come into service.\n\n## Output Parameters\n\n* Remediation.Output - stdout messages from the remediation\n\n## Security Standards / Controls\n* AFSBP v1.0.0: Autoscaling.1\n* CIS v1.2.0:   2.1\n* PCI:          Autoscaling.1\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "AutoScalingGroupName": {
       "type": "String",
       "description": "(Required) The Amazon Resource Name (ARN) of the auto scaling group that you want to enable health checks on.",
       "allowedPattern": "^.{1,255}$"
      },
      "HealthCheckGracePeriod": {
       "type": "Integer",
       "description": "(Optional) The amount of time, in seconds, that Auto Scaling waits before checking the health status of an Amazon Elastic Compute Cloud (Amazon EC2) instance that has come into service.",
       "allowedPattern": "^[0-9]\\d*$",
       "default": 300
      }
     },
     "outputs": [
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "EnableELBHealthCheck",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "autoscaling",
        "Api": "UpdateAutoScalingGroup",
        "AutoScalingGroupName": "{{AutoScalingGroupName}}",
        "HealthCheckType": "ELB",
        "HealthCheckGracePeriod": "{{HealthCheckGracePeriod}}"
       },
       "description": "Enable ELB health check type on ASG",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "AsgName": "{{AutoScalingGroupName}}"
        },
        "Runtime": "python3.8",
        "Handler": "verify",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\ndef connect_to_autoscaling(boto_config):\n    return boto3.client('autoscaling', config=boto_config)\n\ndef verify(event, _):\n\n    boto_config = Config(\n        retries ={\n          'mode': 'standard'\n        }\n    )\n    asg_client = connect_to_autoscaling(boto_config)\n    asg_name = event['AsgName']\n    try:\n        desc_asg = asg_client.describe_auto_scaling_groups(\n            AutoScalingGroupNames=[asg_name]\n        )\n        if len(desc_asg['AutoScalingGroups']) < 1:\n            exit(f'No AutoScaling Group found matching {asg_name}')\n\n        health_check = desc_asg['AutoScalingGroups'][0]['HealthCheckType']\n        print(json.dumps(desc_asg['AutoScalingGroups'][0], default=str))\n        if (health_check == 'ELB'):\n            return {\n                \"response\": {\n                    \"message\": \"Autoscaling Group health check type updated to ELB\",\n                    \"status\": \"Success\"\n                }\n            }\n        else:\n            return {\n                \"response\": {\n                    \"message\": \"Autoscaling Group health check type is not ELB\",\n                    \"status\": \"Failed\"\n                }\n            }\n    except Exception as e:\n        exit(\"Exception while executing remediation: \" + str(e))"
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableAutoScalingGroupELBHealthCheck",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableAutoScalingGroupELBHealthCheck"
   }
  },
  "ASREnableAWSConfig": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-EnableAWSConfig\n\n## What does this document do?\nEnables AWS Config:\n* Turns on recording for all resources.\n* Creates an encrypted bucket for Config logging.\n* Creates a logging bucket for access logs for the config bucket\n* Creates an SNS topic for Config notifications\n* Creates a service-linked role\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n* KMSKeyArn: KMS Customer-managed key to use for encryption of Config log data and SNS Topic\n* AWSServiceRoleForConfig: (Optional) The name of the exiting IAM role to use for the Config service. Default: aws-service-role/config.amazonaws.com/AWSServiceRoleForConfig\n* SNSTopicName: (Required) Name of the SNS Topic to use to post AWS Config messages.\n\n## Output Parameters\n* Remediation.Output: STDOUT and messages from the remediation steps.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "KMSKeyArn": {
       "type": "String",
       "description": "The ARN of a KMS key to use for encryption of the SNS Topic and Config bucket",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      },
      "AWSServiceRoleForConfig": {
       "type": "String",
       "default": "aws-service-role/config.amazonaws.com/AWSServiceRoleForConfig",
       "allowedPattern": "^(:?[\\w+=,.@-]+/)+[\\w+=,.@-]+$"
      },
      "SNSTopicName": {
       "type": "String",
       "allowedPattern": "^[a-zA-Z0-9][a-zA-Z0-9-_]{0,255}$"
      }
     },
     "outputs": [
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "CreateTopic",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "TopicArn",
         "Selector": "$.Payload.topic_arn",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "kms_key_arn": "{{KMSKeyArn}}",
         "topic_name": "{{SNSTopicName}}"
        },
        "Runtime": "python3.8",
        "Handler": "create_encrypted_topic",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nboto_config = Config(\n    retries ={\n        'mode': 'standard'\n    }\n)\n\ndef connect_to_sns():\n    return boto3.client('sns', config=boto_config)\n\ndef connect_to_ssm():\n    return boto3.client('ssm', config=boto_config)\n\ndef create_encrypted_topic(event, _):\n\n    kms_key_arn = event['kms_key_arn']\n    new_topic = False\n    topic_arn = ''\n    topic_name = event['topic_name']\n\n    try:\n        sns = connect_to_sns()\n        topic_arn = sns.create_topic(\n            Name=topic_name,\n            Attributes={\n                'KmsMasterKeyId': kms_key_arn.split('key/')[1]\n            }\n        )['TopicArn']\n        new_topic = True\n\n    except ClientError as client_exception:\n        exception_type = client_exception.response['Error']['Code']\n        if exception_type == 'InvalidParameter':\n            print(f'Topic {topic_name} already exists. This remediation may have been run before.')\n            print('Ignoring exception - remediation continues.')\n            topic_arn = sns.create_topic(\n                Name=topic_name\n            )['TopicArn']\n        else:\n            exit(f'ERROR: Unhandled client exception: {client_exception}')\n\n    except Exception as e:\n        exit(f'ERROR: could not create SNS Topic {topic_name}: {str(e)}')\n\n    if new_topic:\n        try:\n            ssm = connect_to_ssm()\n            ssm.put_parameter(\n                Name='/Solutions/SO0111/SNS_Topic_Config.1',\n                Description='SNS Topic for AWS Config updates',\n                Type='String',\n                Overwrite=True,\n                Value=topic_arn\n            )\n        except Exception as e:\n            exit(f'ERROR: could not create SNS Topic {topic_name}: {str(e)}')\n\n    create_topic_policy(topic_arn)\n\n    return {\"topic_arn\": topic_arn}\n\ndef create_topic_policy(topic_arn):\n    sns = connect_to_sns()\n    try:\n        topic_policy = {\n            \"Id\": \"Policy_ID\",\n            \"Statement\": [\n            {\n                \"Sid\": \"AWSConfigSNSPolicy\",\n                \"Effect\": \"Allow\",\n                \"Principal\": {\n                \"Service\": \"config.amazonaws.com\"\n                },\n                \"Action\": \"SNS:Publish\",\n                \"Resource\": topic_arn,\n            }]\n        }\n\n        sns.set_topic_attributes(\n            TopicArn=topic_arn,\n            AttributeName='Policy',\n            AttributeValue=json.dumps(topic_policy)\n        )\n    except Exception as e:\n        exit(f'ERROR: Failed to SetTopicAttributes for {topic_arn}: {str(e)}')"
       },
       "isEnd": false
      },
      {
       "name": "CreateAccessLoggingBucket",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-CreateAccessLoggingBucket",
        "RuntimeParameters": {
         "BucketName": "so0111-accesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateAccessLoggingBucket"
        }
       }
      },
      {
       "name": "CreateConfigBucket",
       "action": "aws:executeScript",
       "isEnd": false,
       "outputs": [
        {
         "Name": "ConfigBucketName",
         "Selector": "$.Payload.config_bucket",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "logging_bucket": "so0111-accesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}",
         "account": "{{global:ACCOUNT_ID}}",
         "region": "{{global:REGION}}",
         "partition": "{{global:AWS_PARTITION}}",
         "kms_key_arn": "{{KMSKeyArn}}"
        },
        "Runtime": "python3.8",
        "Handler": "create_encrypted_bucket",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\nfrom botocore.retries import bucket\n\nboto_config = Config(\n    retries ={\n        'mode': 'standard'\n    }\n)\n\ndef connect_to_s3(boto_config):\n    return boto3.client('s3', config=boto_config)\n\ndef create_bucket(bucket_name, aws_region):\n    s3 = connect_to_s3(boto_config)\n    try:\n        if aws_region == 'us-east-1':\n            s3.create_bucket(\n                ACL='private',\n                Bucket=bucket_name\n            )\n        else:\n            s3.create_bucket(\n                ACL='private',\n                Bucket=bucket_name,\n                CreateBucketConfiguration={\n                    'LocationConstraint': aws_region\n                }\n            )\n        return \"created\"\n\n    except ClientError as ex:\n        exception_type = ex.response['Error']['Code']\n        # bucket already exists - return\n        if exception_type in [\"BucketAlreadyExists\", \"BucketAlreadyOwnedByYou\"]:\n            print('Bucket ' + bucket_name + ' already exists')\n            return \"already exists\"\n        else:\n            exit(f'ERROR creating bucket {bucket_name}: {str(ex)}')\n    except Exception as e:\n        exit(f'ERROR creating bucket {bucket_name}: {str(e)}')\n\ndef encrypt_bucket(bucket_name, kms_key):\n    s3 = connect_to_s3(boto_config)\n    try:\n        s3.put_bucket_encryption(\n        Bucket=bucket_name,\n        ServerSideEncryptionConfiguration={\n        'Rules': [\n            {\n            'ApplyServerSideEncryptionByDefault': {\n                'SSEAlgorithm': 'aws:kms',\n                'KMSMasterKeyID': kms_key\n            }\n            }\n        ]\n        }\n    )\n    except Exception as e:\n        exit(f'ERROR putting bucket encryption for {bucket_name}: {str(e)}')\n\ndef block_public_access(bucket_name):\n    s3 = connect_to_s3(boto_config)\n    try:\n        s3.put_public_access_block(\n            Bucket=bucket_name,\n            PublicAccessBlockConfiguration={\n                'BlockPublicAcls': True,\n                'IgnorePublicAcls': True,\n                'BlockPublicPolicy': True,\n                'RestrictPublicBuckets': True\n            }\n        )\n    except Exception as e:\n        exit(f'ERROR setting public access block for bucket {bucket_name}: {str(e)}')\n\ndef enable_access_logging(bucket_name, logging_bucket):\n    s3 = connect_to_s3(boto_config)\n    try:\n        s3.put_bucket_logging(\n            Bucket=bucket_name,\n            BucketLoggingStatus={\n            'LoggingEnabled': {\n                'TargetBucket': logging_bucket,\n                'TargetPrefix': f'access-logs/{bucket_name}'\n            }\n            }\n        )\n    except Exception as e:\n        exit(f'Error setting access logging for bucket {bucket_name}: {str(e)}')\n\ndef create_bucket_policy(config_bucket, aws_partition):\n    s3 = connect_to_s3(boto_config)\n    try:\n        bucket_policy = {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n            {\n                \"Sid\": \"AWSConfigBucketPermissionsCheck\",\n                \"Effect\": \"Allow\",\n                \"Principal\": {\n                    \"Service\": [\n                        \"config.amazonaws.com\"\n                    ]\n                },\n                \"Action\": \"s3:GetBucketAcl\",\n                \"Resource\": \"arn:\" + aws_partition + \":s3:::\" + config_bucket\n            },\n            {\n                \"Sid\": \"AWSConfigBucketExistenceCheck\",\n                \"Effect\": \"Allow\",\n                \"Principal\": {\n                    \"Service\": [\n                        \"config.amazonaws.com\"\n                    ]\n                },\n                \"Action\": \"s3:ListBucket\",\n                \"Resource\": \"arn:\" + aws_partition + \":s3:::\" + config_bucket\n            },\n            {\n                \"Sid\": \"AWSConfigBucketDelivery\",\n                \"Effect\": \"Allow\",\n                \"Principal\": {\n                    \"Service\": [\n                        \"config.amazonaws.com\"\n                    ]\n                },\n                \"Action\": \"s3:PutObject\",\n                \"Resource\": \"arn:\" + aws_partition + \":s3:::\" + config_bucket + \"/*\",\n                \"Condition\": {\n                    \"StringEquals\": {\n                        \"s3:x-amz-acl\": \"bucket-owner-full-control\"\n                    }\n                }\n            }\n            ]\n        }\n        s3.put_bucket_policy(\n            Bucket=config_bucket,\n            Policy=json.dumps(bucket_policy)\n        )\n    except Exception as e:\n        exit(f'ERROR: PutBucketPolicy failed for {config_bucket}: {str(e)}')\n\ndef create_encrypted_bucket(event, _):\n\n    kms_key_arn = event['kms_key_arn']\n    aws_partition = event['partition']\n    aws_account = event['account']\n    aws_region = event['region']\n    logging_bucket = event['logging_bucket']\n    bucket_name = 'so0111-aws-config-' + aws_region + '-' + aws_account\n\n    if create_bucket(bucket_name, aws_region) == 'already exists':\n        return {\"config_bucket\": bucket_name}\n\n    encrypt_bucket(bucket_name, kms_key_arn.split('key/')[1])\n    block_public_access(bucket_name)\n    enable_access_logging(bucket_name, logging_bucket)\n    create_bucket_policy(bucket_name, aws_partition)\n\n    return {\"config_bucket\": bucket_name}"
       }
      },
      {
       "name": "EnableConfig",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "ConfigBucketName",
         "Selector": "$.Payload.config_bucket",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "partition": "{{global:AWS_PARTITION}}",
         "account": "{{global:ACCOUNT_ID}}",
         "region": "{{global:REGION}}",
         "config_bucket": "{{CreateConfigBucket.ConfigBucketName}}",
         "aws_service_role": "{{AWSServiceRoleForConfig}}",
         "topic_arn": "{{CreateTopic.TopicArn}}"
        },
        "Runtime": "python3.8",
        "Handler": "enable_config",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nboto_config = Config(\n    retries ={\n        'mode': 'standard'\n    }\n)\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef create_config_recorder(aws_partition, aws_account, aws_service_role):\n    cfgsvc = connect_to_config(boto_config)\n    try:\n        config_service_role_arn = 'arn:' + aws_partition + ':iam::' + aws_account + ':role/' + aws_service_role\n        cfgsvc.put_configuration_recorder(\n            ConfigurationRecorder={\n                'name': 'default',\n                'roleARN': config_service_role_arn,\n                'recordingGroup': {\n                    'allSupported': True,\n                    'includeGlobalResourceTypes': True\n                }\n            }\n        )\n    except ClientError as ex:\n        exception_type = ex.response['Error']['Code']\n        # recorder already exists - continue\n        if exception_type in [\"MaxNumberOfConfigurationRecordersExceededException\"]:\n            print('Config Recorder already exists. Continuing.')\n        else:\n            exit(f'ERROR: Boto3 ClientError enabling Config: {exception_type} - {str(ex)}')\n    except Exception as e:\n        exit(f'ERROR enabling AWS Config - create_config_recorder: {str(e)}')\n\ndef create_delivery_channel(config_bucket, aws_account, topic_arn):\n    cfgsvc = connect_to_config(boto_config)\n    try:\n        cfgsvc.put_delivery_channel(\n            DeliveryChannel={\n                'name': 'default',\n                's3BucketName': config_bucket,\n                's3KeyPrefix': aws_account,\n                'snsTopicARN': topic_arn,\n                'configSnapshotDeliveryProperties': {\n                    'deliveryFrequency': 'Twelve_Hours'\n                }\n            }\n        )\n    except ClientError as ex:\n        exception_type = ex.response['Error']['Code']\n        # delivery channel already exists - return\n        if exception_type in [\"MaxNumberOfDeliveryChannelsExceededException\"]:\n            print('DeliveryChannel already exists')\n        else:\n            exit(f'ERROR: Boto3 ClientError enabling Config: {exception_type} - {str(ex)}')\n    except Exception as e:\n        exit(f'ERROR enabling AWS Config - create_delivery_channel: {str(e)}')\n\ndef start_recorder():\n    cfgsvc = connect_to_config(boto_config)\n    try:\n        cfgsvc.start_configuration_recorder(\n            ConfigurationRecorderName='default'\n        )\n    except Exception as e:\n        exit(f'ERROR enabling AWS Config: {str(e)}')\n\ndef enable_config(event, _):\n    aws_account = event['account']\n    aws_partition = event['partition']\n    aws_service_role = event['aws_service_role']\n    config_bucket = event['config_bucket']\n    topic_arn = event['topic_arn']\n\n    create_config_recorder(aws_partition, aws_account, aws_service_role)\n    create_delivery_channel(config_bucket, aws_account, topic_arn)\n    start_recorder()"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "config_bucket": "{{CreateConfigBucket.ConfigBucketName}}",
         "logging_bucket": "so0111-accesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}",
         "sns_topic_arn": "{{CreateTopic.TopicArn}}"
        },
        "Runtime": "python3.8",
        "Handler": "process_results",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\ndef process_results(event, _):\n    print(f'Created encrypted SNS topic {event[\"sns_topic_arn\"]}')\n    print(f'Created encrypted Config bucket {event[\"config_bucket\"]}')\n    print(f'Created access logging for Config bucket in bucket {event[\"logging_bucket\"]}')\n    print('Enabled AWS Config by creating a default recorder')\n    return {\n        \"response\": {\n            \"message\": \"AWS Config successfully enabled\",\n            \"status\": \"Success\"\n        }\n    }"
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableAWSConfig",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableAWSConfig"
   }
  },
  "ASREnableCloudTrailToCloudWatchLogging": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-EnableCloudTrailToCloudWatchLogging\n## What does this document do?\nCreates a CloudWatch logs group for CloudTrail data.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* KMSKeyArn (from SSM): Arn of the KMS key to be used to encrypt data\n\n## Security Standards / Controls\n* AFSBP v1.0.0:   N/A\n* CIS v1.2.0:     2.4\n* PCI:            CloudTrail.4\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "TrailName": {
       "type": "String",
       "description": "(Required) The name of the CloudTrail.",
       "allowedPattern": "^[A-Za-z0-9._-]{3,128}$"
      },
      "CloudWatchLogsRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows CloudTrail to log to CloudWatch.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "LogGroupName": {
       "type": "String",
       "description": "(Required) The name of the Log Group for CloudTrail logs.",
       "allowedPattern": "^[a-zA-Z0-9-_./]{1,512}$"
      }
     },
     "outputs": [
      "UpdateTrailToCWLogs.Output"
     ],
     "mainSteps": [
      {
       "name": "CreateLogGroup",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "logs",
        "Api": "CreateLogGroup",
        "logGroupName": "{{LogGroupName}}"
       },
       "description": "Create the log group",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "WaitForCreation",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "LogGroup": "{{LogGroupName}}"
        },
        "Runtime": "python3.8",
        "Handler": "wait_for_loggroup",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport time\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_logs(boto_config):\n    return boto3.client('logs', config=boto_config)\n\ndef sleep_between_attempts():\n    time.sleep(2)\n\ndef wait_for_loggroup(event, _):\n    boto_config = Config(\n        retries ={\n          'mode': 'standard'\n        }\n    )\n    cwl_client = connect_to_logs(boto_config)\n\n    max_retries = 3\n    attempts = 0\n    while attempts < max_retries:\n        try:\n            describe_group = cwl_client.describe_log_groups(logGroupNamePrefix=event['LogGroup'])\n            print(len(describe_group['logGroups']))\n            for group in describe_group['logGroups']:\n                if group['logGroupName'] == event['LogGroup']:\n                    return str(group['arn'])\n            # no match - wait and retry\n            sleep_between_attempts()\n            attempts += 1\n\n        except Exception as err:\n            exit(f'Failed to create Log Group {event[\"LogGroup\"]}: {str(err)}')\n\n    exit(f'Failed to create Log Group {event[\"LogGroup\"]}: Timed out')"
       },
       "outputs": [
        {
         "Name": "CloudWatchLogsGroupArn",
         "Selector": "$.Payload",
         "Type": "String"
        }
       ],
       "isEnd": false
      },
      {
       "name": "UpdateTrailToCWLogs",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "cloudtrail",
        "Api": "UpdateTrail",
        "Name": "{{TrailName}}",
        "CloudWatchLogsLogGroupArn": "{{WaitForCreation.CloudWatchLogsGroupArn}}",
        "CloudWatchLogsRoleArn": "{{CloudWatchLogsRole}}"
       },
       "description": "Enable logging to CloudWatch Logs",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableCloudTrailToCloudWatchLogging",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableCloudTrailToCloudWatchLogging"
   }
  },
  "ASREnableCloudTrailEncryption": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-EnableCloudTrailEncryption\n## What does this document do?\nEnables encryption on a CloudTrail using the provided KMS CMK\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* KMSKeyArn (from SSM): Arn of the KMS key to be used to encrypt data\n* TrailRegion: region of the CloudTrail to encrypt\n* TrailArn: ARN of the CloudTrail to encrypt\n\n## Security Standards / Controls\n* AFSBP v1.0.0:   CloudTrail.2\n* CIS v1.2.0:     2.7\n* PCI:            CloudTrail.1\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "KMSKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for this remediation",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      },
      "TrailRegion": {
       "type": "String",
       "description": "Region the CloudTrail is in",
       "allowedPattern": "^[a-z]{2}(?:-gov)?-[a-z]+-\\d$"
      },
      "TrailArn": {
       "type": "String",
       "description": "ARN of the CloudTrail",
       "allowedPattern": "^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail/[A-Za-z0-9._-]{3,128}$"
      }
     },
     "outputs": [
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "Remediation",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "exec_region": "{{global:REGION}}",
         "trail_region": "{{TrailRegion}}",
         "trail": "{{TrailArn}}",
         "region": "{{global:REGION}}",
         "kms_key_arn": "{{KMSKeyArn}}"
        },
        "Runtime": "python3.8",
        "Handler": "enable_trail_encryption",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\ndef connect_to_cloudtrail(region, boto_config):\n    return boto3.client('cloudtrail', region_name=region, config=boto_config)\n\ndef enable_trail_encryption(event, _):\n    \"\"\"\n    remediates CloudTrail.2 by enabling SSE-KMS\n    On success returns a string map\n    On failure returns NoneType\n    \"\"\"\n    boto_config = Config(\n        retries ={\n          'mode': 'standard'\n        }\n    )\n\n    if event['trail_region'] != event['exec_region']:\n        exit('ERROR: cross-region remediation is not yet supported')\n\n    ctrail_client = connect_to_cloudtrail(event['trail_region'], boto_config)\n    kms_key_arn = event['kms_key_arn']\n\n    try:\n        ctrail_client.update_trail(\n            Name=event['trail'],\n            KmsKeyId=kms_key_arn\n        )\n        return {\n            \"response\": {\n                \"message\": f'Enabled KMS CMK encryption on {event[\"trail\"]}',\n                \"status\": \"Success\"\n            }\n        }\n    except Exception as e:\n        exit(f'Error enabling SSE-KMS encryption: {str(e)}')"
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableCloudTrailEncryption",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableCloudTrailEncryption"
   }
  },
  "ASREnableDefaultEncryptionS3": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document name - ASR-EnableDefaultEncryptionS3\n\n## What does this document do?\nThis document configures default encryption for an Amazon S3 Bucket.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n* BucketName: (Required) Name of the bucket to modify.\n* AccountId: (Required) Account to which the bucket belongs\n\n## Output Parameters\n\n* Remediation.Output - stdout messages from the remediation\n\n## Security Standards / Controls\n* AFSBP v1.0.0: S3.4\n* CIS v1.2.0:   n/a\n* PCI:          S3.4\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AccountId": {
       "type": "String",
       "description": "Account ID of the account for the finding",
       "allowedPattern": "^[0-9]{12}$"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "BucketName": {
       "type": "String",
       "description": "Name of the bucket to have a policy added",
       "allowedPattern": "(?=^.{3,63}$)(?!^(\\d+\\.)+\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])$)"
      },
      "KmsKeyAlias": {
       "type": "String",
       "description": "(Required) KMS Customer-Managed Key (CMK) alias or the default value which is created in the SSM parameter at solution deployment (default-s3-encryption) is used to identify that the s3 bucket encryption value should be set to AES-256.",
       "default": "default-s3-encryption",
       "allowedPattern": "^$|^[a-zA-Z0-9/_-]{1,256}$"
      }
     },
     "mainSteps": [
      {
       "name": "ChooseEncryptionMethod",
       "action": "aws:branch",
       "inputs": {
        "Choices": [
         {
          "NextStep": "EncryptWithAES",
          "Variable": "{{KmsKeyAlias}}",
          "StringEquals": "default-s3-encryption"
         }
        ],
        "Default": "EncryptWithCMK"
       }
      },
      {
       "name": "EncryptWithAES",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "s3",
        "Api": "PutBucketEncryption",
        "Bucket": "{{BucketName}}",
        "ExpectedBucketOwner": "{{AccountId}}",
        "ServerSideEncryptionConfiguration": {
         "Rules": [
          {
           "ApplyServerSideEncryptionByDefault": {
            "SSEAlgorithm": "AES256"
           },
           "BucketKeyEnabled": true
          }
         ]
        }
       },
       "isEnd": true
      },
      {
       "name": "EncryptWithCMK",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "s3",
        "Api": "PutBucketEncryption",
        "Bucket": "{{BucketName}}",
        "ExpectedBucketOwner": "{{AccountId}}",
        "ServerSideEncryptionConfiguration": {
         "Rules": [
          {
           "ApplyServerSideEncryptionByDefault": {
            "SSEAlgorithm": "aws:kms",
            "KMSMasterKeyID": "{{KmsKeyAlias}}"
           },
           "BucketKeyEnabled": true
          }
         ]
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableDefaultEncryptionS3",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableDefaultEncryptionS3"
   }
  },
  "ASREnableVPCFlowLogs": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-EnableVPCFlowLogs\n## What does this document do?\nEnables VPC Flow Logs for a given VPC\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* VPC: VPC Id of the VPC for which logs are to be enabled\n* RemediationRole: role arn of the role to use for logging\n* KMSKeyArn: Amazon Resource Name (ARN) of the KMS Customer-Managed Key to use to encrypt the log group\n\n## Security Standards / Controls\n* AFSBP v1.0.0:   CloudTrail.2\n* CIS v1.2.0:     2.7\n* PCI:            CloudTrail.1\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "VPC": {
       "type": "String",
       "allowedPattern": "^vpc-[0-9a-f]{8,17}",
       "description": "The VPC ID of the VPC"
      },
      "RemediationRole": {
       "type": "String",
       "description": "The ARN of the role that will allow VPC Flow Logs to log to CloudWatch logs",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "KMSKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for remediations requiring encryption",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      }
     },
     "outputs": [
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "Remediation",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "vpc": "{{VPC}}",
         "remediation_role": "{{RemediationRole}}",
         "kms_key_arn": "{{KMSKeyArn}}"
        },
        "Runtime": "python3.8",
        "Handler": "enable_flow_logs",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nimport time\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\ndef connect_to_logs(boto_config):\n    return boto3.client('logs', config=boto_config)\n\ndef connect_to_ec2(boto_config):\n    return boto3.client('ec2', config=boto_config)\n\ndef log_group_exists(client, group):\n    try:\n        log_group_verification = client.describe_log_groups(\n            logGroupNamePrefix=group\n        )['logGroups']\n        if len(log_group_verification) >= 1:\n            for existing_loggroup in log_group_verification:\n                if existing_loggroup['logGroupName'] == group:\n                    return 1\n        return 0\n\n    except Exception as e:\n        exit(f'EnableVPCFlowLogs failed - unhandled exception {str(e)}')\n\ndef wait_for_seconds(wait_interval):\n    time.sleep(wait_interval)\n\ndef wait_for_loggroup(client, wait_interval, max_retries, loggroup):\n    attempts = 1\n    while not log_group_exists(client, loggroup):\n        wait_for_seconds(wait_interval)\n        attempts += 1\n        if attempts > max_retries:\n            exit(f'Timeout waiting for log group {loggroup} to become active')\n\ndef flowlogs_active(client, loggroup):\n    # searches for flow log status, filtered on unique CW Log Group created earlier\n    try:\n        flow_status = client.describe_flow_logs(\n            DryRun=False,\n            Filters=[\n                {\n                    'Name': 'log-group-name',\n                    'Values': [loggroup]\n                },\n            ]\n        )['FlowLogs']\n        if len(flow_status) == 1 and flow_status[0]['FlowLogStatus'] == 'ACTIVE':\n            return 1\n        else:\n            return 0\n\n    except Exception as e:\n        exit(f'EnableVPCFlowLogs failed - unhandled exception {str(e)}')\n\ndef wait_for_flowlogs(client, wait_interval, max_retries, loggroup):\n    attempts = 1\n    while not flowlogs_active(client, loggroup):\n        wait_for_seconds(wait_interval)\n        attempts += 1\n        if attempts > max_retries:\n            exit(f'Timeout waiting for flowlogs to log group {loggroup} to become active')\n\ndef enable_flow_logs(event, _):\n    \"\"\"\n    remediates CloudTrail.2 by enabling SSE-KMS\n    On success returns a string map\n    On failure returns NoneType\n    \"\"\"\n    max_retries = event.get('retries', 12) # max number of waits for actions to complete.\n    wait_interval = event.get('wait', 5) # how many seconds between attempts\n\n    boto_config_args = {\n        'retries': {\n            'mode': 'standard'\n        }\n    }\n\n    boto_config = Config(**boto_config_args)\n\n    if 'vpc' not in event or 'remediation_role' not in event or 'kms_key_arn' not in event:\n        exit('Error: missing vpc from input')\n\n    logs_client = connect_to_logs(boto_config)\n    ec2_client = connect_to_ec2(boto_config)\n\n    kms_key_arn = event['kms_key_arn'] # for logs encryption at rest\n\n    # set dynamic variable for CW Log Group for VPC Flow Logs\n    vpc_flow_loggroup = \"VPCFlowLogs/\" + event['vpc']\n    # create cloudwatch log group\n    try:\n        logs_client.create_log_group(\n            logGroupName=vpc_flow_loggroup,\n            kmsKeyId=kms_key_arn\n        )\n    except ClientError as client_error:\n        exception_type = client_error.response['Error']['Code']\n\n        if exception_type in [\"ResourceAlreadyExistsException\"]:\n            print(f'CloudWatch Logs group {vpc_flow_loggroup} already exists')\n        else:\n            exit(f'ERROR CREATING LOGGROUP {vpc_flow_loggroup}: {str(exception_type)}')\n\n    except Exception as e:\n        exit(f'ERROR CREATING LOGGROUP {vpc_flow_loggroup}: {str(e)}')\n\n    # wait for CWL creation to propagate\n    wait_for_loggroup(logs_client, wait_interval, max_retries, vpc_flow_loggroup)\n\n    # create VPC Flow Logging\n    try:\n        ec2_client.create_flow_logs(\n            DryRun=False,\n            DeliverLogsPermissionArn=event['remediation_role'],\n            LogGroupName=vpc_flow_loggroup,\n            ResourceIds=[event['vpc']],\n            ResourceType='VPC',\n            TrafficType='REJECT',\n            LogDestinationType='cloud-watch-logs'\n        )\n    except ClientError as client_error:\n        exception_type = client_error.response['Error']['Code']\n\n        if exception_type in [\"FlowLogAlreadyExists\"]:\n            return {\n                \"response\": {\n                    \"message\": f'VPC Flow Logs for {event[\"vpc\"]} already enabled',\n                    \"status\": \"Success\"\n                }\n            }\n        else:\n            exit(f'ERROR CREATING LOGGROUP {vpc_flow_loggroup}: {str(exception_type)}')\n    except Exception as e:\n        exit(f'create_flow_logs failed {str(e)}')\n\n    # wait for Flow Log creation to propagate. Exits on timeout (no need to check results)\n    wait_for_flowlogs(ec2_client, wait_interval, max_retries, vpc_flow_loggroup)\n\n    # wait_for_flowlogs will exit if unsuccessful after max_retries * wait_interval (60 seconds by default)\n    return {\n        \"response\": {\n            \"message\": f'VPC Flow Logs enabled for {event[\"vpc\"]} to {vpc_flow_loggroup}',\n            \"status\": \"Success\"\n        }\n    }"
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableVPCFlowLogs",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableVPCFlowLogs"
   }
  },
  "ASRCreateAccessLoggingBucket": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-CreateAccessLoggingBucket\n\n## What does this document do?\nCreates an S3 bucket for access logging.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* BucketName: (Required) Name of the bucket to create\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "BucketName": {
       "type": "String",
       "description": "(Required) The bucket name (not the ARN).",
       "allowedPattern": "(?=^.{3,63}$)(?!^(\\d+\\.)+\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])$)"
      }
     },
     "outputs": [
      "CreateAccessLoggingBucket.Output"
     ],
     "mainSteps": [
      {
       "name": "CreateAccessLoggingBucket",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "BucketName": "{{BucketName}}",
         "AWS_REGION": "{{global:REGION}}"
        },
        "Runtime": "python3.8",
        "Handler": "create_logging_bucket",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.exceptions import ClientError\nfrom botocore.config import Config\n\n\ndef connect_to_s3(boto_config):\n    return boto3.client(\"s3\", config=boto_config)\n\n\ndef create_logging_bucket(event, _):\n    boto_config = Config(retries={\"mode\": \"standard\"})\n    s3 = connect_to_s3(boto_config)\n\n    try:\n        kwargs = {\n            \"Bucket\": event[\"BucketName\"],\n            \"GrantWrite\": \"uri=http://acs.amazonaws.com/groups/s3/LogDelivery\",\n            \"GrantReadACP\": \"uri=http://acs.amazonaws.com/groups/s3/LogDelivery\",\n        }\n        if event[\"AWS_REGION\"] != \"us-east-1\":\n            kwargs[\"CreateBucketConfiguration\"] = {\n                \"LocationConstraint\": event[\"AWS_REGION\"]\n            }\n\n        s3.create_bucket(**kwargs)\n\n        s3.put_bucket_encryption(\n            Bucket=event[\"BucketName\"],\n            ServerSideEncryptionConfiguration={\n                \"Rules\": [\n                    {\"ApplyServerSideEncryptionByDefault\": {\"SSEAlgorithm\": \"AES256\"}}\n                ]\n            },\n        )\n        return {\"output\": {\"Message\": f'Bucket {event[\"BucketName\"]} created'}}\n    except ClientError as error:\n        if error.response[\"Error\"][\"Code\"] != \"BucketAlreadyOwnedByYou\":\n            exit(str(error))\n        else:\n            return {\n                \"output\": {\n                    \"Message\": f'Bucket {event[\"BucketName\"]} already exists and is owned by you'\n                }\n            }\n    except Exception as e:\n        print(e)\n        exit(str(e))"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "StringMap"
        }
       ],
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-CreateAccessLoggingBucket",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR CreateAccessLoggingBucket"
   }
  },
  "ASRMakeEBSSnapshotsPrivate": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-MakeEBSSnapshotPrivate\n\n## What does this document do?\nThis runbook works an the account level to remove public share on all EBS snapshots\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n\n## Output Parameters\n\n* Remediation.Output - stdout messages from the remediation\n\n## Security Standards / Controls\n* AFSBP v1.0.0: EC2.1\n* CIS v1.2.0:   n/a\n* PCI:          EC2.1\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AccountId": {
       "type": "String",
       "description": "Account ID of the account for which snapshots are to be checked.",
       "allowedPattern": "^[0-9]{12}$"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "TestMode": {
       "type": "Boolean",
       "description": "Enables test mode, which generates a list of fake volume Ids",
       "default": false
      }
     },
     "outputs": [
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "GetPublicSnapshotIds",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Snapshots",
         "Selector": "$.Payload",
         "Type": "StringList"
        }
       ],
       "inputs": {
        "InputPayload": {
         "region": "{{global:REGION}}",
         "account_id": "{{AccountId}}",
         "testmode": "{{TestMode}}"
        },
        "Runtime": "python3.8",
        "Handler": "get_public_snapshots",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nboto_config = Config(\n    retries = {\n            'mode': 'standard',\n            'max_attempts': 10\n        }\n    )\n\ndef connect_to_ec2(boto_config):\n    return boto3.client('ec2', config=boto_config)\n\ndef get_public_snapshots(event, _):\n    account_id = event['account_id']\n\n    if 'testmode' in event and event['testmode']:\n        return [\n            \"snap-12341234123412345\",\n            \"snap-12341234123412345\",\n            \"snap-12341234123412345\",\n            \"snap-12341234123412345\",\n            \"snap-12341234123412345\"\n        ]\n\n    return list_public_snapshots(account_id)\n\ndef list_public_snapshots(account_id):\n    ec2 = connect_to_ec2(boto_config)\n    control_token = 'start'\n    try:\n\n        public_snapshot_ids = []\n\n        while control_token:\n\n            if control_token == 'start': # needed a value to start the loop. Now reset it\n                control_token = ''\n\n            kwargs = {\n                'MaxResults': 100,\n                'OwnerIds': [ account_id ],\n                'RestorableByUserIds': [ 'all' ]\n            }\n            if control_token:\n                kwargs['NextToken'] = control_token\n\n            response = ec2.describe_snapshots(\n                        **kwargs\n                )\n\n            for snapshot in response['Snapshots']:\n                public_snapshot_ids.append(snapshot['SnapshotId'])\n\n            if 'NextToken' in response:\n                control_token = response['NextToken']\n            else:\n                control_token = ''\n\n        return public_snapshot_ids\n\n    except Exception as e:\n        print(e)\n        exit('Failed to describe_snapshots')"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "region": "{{global:REGION}}",
         "snapshots": "{{GetPublicSnapshotIds.Snapshots}}"
        },
        "Runtime": "python3.8",
        "Handler": "make_snapshots_private",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\ndef connect_to_ec2(boto_config):\n    return boto3.client('ec2', config=boto_config)\n\ndef make_snapshots_private(event, _):\n    boto_config = Config(\n        retries = {\n                'mode': 'standard',\n                'max_attempts': 10\n            }\n        )\n    ec2 = connect_to_ec2(boto_config)\n\n    remediated = []\n    snapshots = event['snapshots']\n\n    success_count = 0\n\n    for snapshot_id in snapshots:\n        try:\n            ec2.modify_snapshot_attribute(\n                Attribute='CreateVolumePermission',\n                CreateVolumePermission={\n                    'Remove': [{'Group': 'all'}]\n                },\n                SnapshotId=snapshot_id\n            )\n            print(f'Snapshot {snapshot_id} permissions set to private')\n\n            remediated.append(snapshot_id)\n            success_count += 1\n        except Exception as e:\n            print(e)\n            print(f'FAILED to remediate Snapshot {snapshot_id}')\n\n    result=json.dumps(ec2.describe_snapshots(\n            SnapshotIds=remediated\n        ), indent=2, default=str)\n    print(result)\n\n    return {\n        \"response\": {\n            \"message\": f'{success_count} of {len(snapshots)} Snapshot permissions set to private',\n            \"status\": \"Success\"\n        }\n    }"
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-MakeEBSSnapshotsPrivate",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR MakeEBSSnapshotsPrivate"
   }
  },
  "ASRMakeRDSSnapshotPrivate": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-MakeRDSSnapshotPrivate\n\n## What does this document do?\nThis runbook removes public access to an RDS Snapshot\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n* DBSnapshotId: identifier of the public snapshot\n* DBSnapshotType: snapshot or cluster-snapshot\n\n## Output Parameters\n\n* Remediation.Output - stdout messages from the remediation\n\n## Security Standards / Controls\n* AFSBP v1.0.0: RDS.1\n* CIS v1.2.0:   n/a\n* PCI:          RDS.1\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "DBSnapshotId": {
       "type": "String",
       "allowedPattern": "^[a-zA-Z](?:[0-9a-zA-Z]+[-]{1})*[0-9a-zA-Z]{1,}$"
      },
      "DBSnapshotType": {
       "type": "String",
       "allowedValues": [
        "cluster-snapshot",
        "snapshot"
       ]
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "MakeRDSSnapshotPrivate.Output"
     ],
     "mainSteps": [
      {
       "name": "MakeRDSSnapshotPrivate",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "DBSnapshotType": "{{DBSnapshotType}}",
         "DBSnapshotId": "{{DBSnapshotId}}"
        },
        "Runtime": "python3.8",
        "Handler": "make_snapshot_private",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\ndef connect_to_rds():\n    boto_config = Config(\n        retries ={\n            'mode': 'standard'\n        }\n    )\n    return boto3.client('rds', config=boto_config)\n\ndef make_snapshot_private(event, _):\n\n    rds_client = connect_to_rds()\n    snapshot_id = event['DBSnapshotId']\n    snapshot_type = event['DBSnapshotType']\n    try:\n        if (snapshot_type == 'snapshot'):\n            rds_client.modify_db_snapshot_attribute(\n                DBSnapshotIdentifier=snapshot_id,\n                AttributeName='restore',\n                ValuesToRemove=['all']\n            )\n        elif (snapshot_type == 'cluster-snapshot'):\n            rds_client.modify_db_cluster_snapshot_attribute(\n                DBClusterSnapshotIdentifier=snapshot_id,\n                AttributeName='restore',\n                ValuesToRemove=['all']\n            )\n        else:\n            exit(f'Unrecognized snapshot_type {snapshot_type}')\n\n        print(f'Remediation completed: {snapshot_id} public access removed.')\n        return {\n            \"response\": {\n                \"message\": f'Snapshot {snapshot_id} permissions set to private',\n                \"status\": \"Success\"\n            }\n        }\n    except Exception as e:\n        exit(f'Remediation failed for {snapshot_id}: {str(e)}')"
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-MakeRDSSnapshotPrivate",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR MakeRDSSnapshotPrivate"
   }
  },
  "ASRRemoveLambdaPublicAccess": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-RemoveLambdaPublicAccess\n\n## What does this document do?\nThis document removes the public resource policy. A public resource policy\ncontains a principal \"*\" or AWS: \"*\", which allows public access to the\nfunction. The remediation is to remove the SID of the public policy.\n\n## Input Parameters\n* FunctionName: name of the AWS Lambda function that has open access policies\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n\n## Output Parameters\n\n* RemoveLambdaPublicAccess.Output - stdout messages from the remediation\n\n## Security Standards / Controls\n* AFSBP v1.0.0: Lambda.1\n* CIS v1.2.0:   n/a\n* PCI:          Lambda.1\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "FunctionName": {
       "type": "String",
       "allowedPattern": "^[a-zA-Z0-9\\-_]{1,64}$"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "RemoveLambdaPublicAccess.Output"
     ],
     "mainSteps": [
      {
       "name": "RemoveLambdaPublicAccess",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "FunctionName": "{{FunctionName}}"
        },
        "Runtime": "python3.8",
        "Handler": "remove_lambda_public_access",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nboto_config = Config(\n    retries = {\n        'mode': 'standard',\n        'max_attempts': 10\n    }\n)\n\ndef connect_to_lambda(boto_config):\n    return boto3.client('lambda', config=boto_config)\n\ndef print_policy_before(policy):\n    print('Resource Policy to be deleted:')\n    print(json.dumps(policy, indent=2, default=str))\n\ndef public_s3_statement_check(statement, principal):\n    \"\"\"\n    This function checks if the user has given access to an S3 bucket without providing an AWS account.\n    \"\"\"\n    try:\n        empty_source_account_check = False\n        if (\"StringEquals\" in statement[\"Condition\"]):\n            empty_source_account_check = (\"AWS:SourceAccount\" not in statement[\"Condition\"][\"StringEquals\"])\n        else:\n            empty_source_account_check = True\n        return principal.get(\"Service\", \"\") == \"s3.amazonaws.com\" and empty_source_account_check\n    except KeyError:\n        return principal.get(\"Service\", \"\") == \"s3.amazonaws.com\"\n\ndef remove_resource_policy(functionname, sid, client):\n    try:\n        client.remove_permission(\n            FunctionName=functionname,\n            StatementId=sid\n        )\n        print(f'SID {sid} removed from Lambda function {functionname}')\n    except Exception as e:\n        exit(f'FAILED: SID {sid} was NOT removed from Lambda function {functionname} - {str(e)}')\n\ndef remove_public_statement(client, functionname, statement, principal):\n    if principal == \"*\" or (isinstance(principal, dict) and (principal.get(\"AWS\",\"\") == \"*\" or public_s3_statement_check(statement, principal))):\n        print_policy_before(statement)\n        remove_resource_policy(functionname, statement['Sid'], client)\n\ndef remove_lambda_public_access(event, _):\n\n    client = connect_to_lambda(boto_config)\n\n    functionname = event['FunctionName']\n    try:\n        response = client.get_policy(FunctionName=functionname)\n        policy = response['Policy']\n        policy_json = json.loads(policy)\n        statements = policy_json['Statement']\n\n        print('Scanning for public resource policies in ' + functionname)\n\n        for statement in statements:\n            remove_public_statement(client, functionname, statement, statement['Principal'])\n\n        client.get_policy(FunctionName=functionname)\n\n        verify(functionname)\n    except ClientError as ex:\n        exception_type = ex.response['Error']['Code']\n        if exception_type in ['ResourceNotFoundException']:\n            print(\"Remediation completed. Resource policy is now empty.\")\n        else:\n            exit(f'ERROR: Remediation failed for RemoveLambdaPublicAccess: {str(ex)}')\n    except Exception as e:\n        exit(f'ERROR: Remediation failed for RemoveLambdaPublicAccess: {str(e)}')\n\ndef verify(function_name_to_check):\n\n    client = connect_to_lambda(boto_config)\n\n    try:\n        response = client.get_policy(FunctionName=function_name_to_check)\n\n        print(\"Remediation executed successfully. Policy after:\")\n        print(json.dumps(response, indent=2, default=str))\n\n    except ClientError as ex:\n        exception_type = ex.response['Error']['Code']\n        if exception_type in ['ResourceNotFoundException']:\n            print(\"Remediation completed. Resource policy is now empty.\")\n        else:\n            exit(f'ERROR: {exception_type} on get_policy')\n    except Exception as e:\n        exit(f'Exception while retrieving lambda function policy: {str(e)}')"
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-RemoveLambdaPublicAccess",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR RemoveLambdaPublicAccess"
   }
  },
  "ASRRevokeUnrotatedKeys": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-RevokeUnrotatedKeys\n\n## What does this document do?\nThis document disables active keys that have not been rotated for more than 90 days. Note that this remediation is **DISRUPTIVE**. It will disabled keys that have been used within the previous 90 days by have not been rotated by using the [UpdateAccessKey API](https://docs.aws.amazon.com/IAM/latest/APIReference/API_UpdateAccessKey.html). Please note, this automation document requires AWS Config to be enabled.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* MaxCredentialUsageAge: (Optional) Maximum number of days a key is allowed to be unrotated before revoking it. DEFAULT: 90\n\n## Output Parameters\n* RevokeUnrotatedKeys.Output\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "IAMResourceId": {
       "type": "String",
       "description": "(Required) IAM resource unique identifier.",
       "allowedPattern": "^[\\w+=,.@_-]{1,128}$"
      },
      "MaxCredentialUsageAge": {
       "type": "String",
       "description": "(Required) Maximum number of days within which a credential must be used. The default value is 90 days.",
       "allowedPattern": "^(?:[1-9]\\d{0,3}|10000)$",
       "default": "90"
      }
     },
     "outputs": [
      "RevokeUnrotatedKeys.Output"
     ],
     "mainSteps": [
      {
       "name": "RevokeUnrotatedKeys",
       "action": "aws:executeScript",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## RevokeUnrotatedKeys\n\nThis step deactivates IAM user access keys that have not been rotated in more than MaxCredentialUsageAge days\n## Outputs\n* Output: Success message or failure Exception.\n",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "unrotated_key_handler",
        "InputPayload": {
         "IAMResourceId": "{{ IAMResourceId }}",
         "MaxCredentialUsageAge": "{{ MaxCredentialUsageAge }}"
        },
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nfrom datetime import datetime, timezone, timedelta\nimport boto3\nfrom botocore.config import Config\n\nboto_config = Config(\n    retries ={\n        'mode': 'standard'\n    }\n)\n\nresponses = {}\nresponses[\"DeactivateUnusedKeysResponse\"] = []\n\ndef connect_to_iam(boto_config):\n    return boto3.client('iam', config=boto_config)\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef get_user_name(resource_id):\n    config_client = connect_to_config(boto_config)\n    list_discovered_resources_response = config_client.list_discovered_resources(\n        resourceType='AWS::IAM::User',\n        resourceIds=[resource_id]\n    )\n    resource_name = list_discovered_resources_response.get(\"resourceIdentifiers\")[0].get(\"resourceName\")\n    return resource_name\n\ndef list_access_keys(user_name, include_inactive=False):\n    iam_client = connect_to_iam(boto_config)\n    active_keys = []\n    keys = iam_client.list_access_keys(UserName=user_name).get(\"AccessKeyMetadata\", [])\n    for key in keys:\n        if include_inactive or key.get('Status') == 'Active':\n            active_keys.append(key)\n    return active_keys\n\ndef deactivate_unused_keys(access_keys, max_credential_usage_age, user_name):\n    iam_client = connect_to_iam(boto_config)\n    for key in access_keys:\n        print(key)\n        last_used = iam_client.get_access_key_last_used(AccessKeyId=key.get(\"AccessKeyId\")).get(\"AccessKeyLastUsed\")\n        deactivate = False\n\n        now = datetime.now(timezone.utc)\n        days_since_creation = (now - key.get(\"CreateDate\")).days\n        last_used_days = (now - last_used.get(\"LastUsedDate\", now)).days\n\n        print(f'Key {key.get(\"AccessKeyId\")} is {days_since_creation} days old and last used {last_used_days} days ago')\n\n        if days_since_creation > max_credential_usage_age:\n            deactivate = True\n\n        if last_used_days > max_credential_usage_age:\n            deactivate = True\n\n        if deactivate:\n            deactivate_key(user_name, key.get(\"AccessKeyId\"))\n\ndef deactivate_key(user_name, access_key):\n    iam_client = connect_to_iam(boto_config)\n    responses[\"DeactivateUnusedKeysResponse\"].append({\"AccessKeyId\": access_key, \"Response\": iam_client.update_access_key(UserName=user_name, AccessKeyId=access_key, Status=\"Inactive\")})\n\ndef verify_expired_credentials_revoked(responses, user_name):\n    if responses.get(\"DeactivateUnusedKeysResponse\"):\n        for key in responses.get(\"DeactivateUnusedKeysResponse\"):\n            key_data = next(filter(lambda x: x.get(\"AccessKeyId\") == key.get(\"AccessKeyId\"), list_access_keys(user_name, True)))\n            if key_data.get(\"Status\") != \"Inactive\":\n                error_message = \"VERIFICATION FAILED. ACCESS KEY {} NOT DEACTIVATED\".format(key_data.get(\"AccessKeyId\"))\n                raise RuntimeError(error_message)\n\n    return {\n        \"output\": \"Verification of unrotated access keys is successful.\",\n        \"http_responses\": responses\n    }\n\ndef unrotated_key_handler(event, _):\n    user_name = get_user_name(event.get(\"IAMResourceId\"))\n    max_credential_usage_age = int(event.get(\"MaxCredentialUsageAge\"))\n    access_keys = list_access_keys(user_name)\n    deactivate_unused_keys(access_keys, max_credential_usage_age, user_name)\n    return verify_expired_credentials_revoked(responses, user_name)"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-RevokeUnrotatedKeys",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR RevokeUnrotatedKeys"
   }
  },
  "ASRSetSSLBucketPolicy": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-SetSSLBucketPolicy\n\n## What does this document do?\nThis document adds a bucket policy to require transmission over HTTPS for the given S3 bucket by adding a policy statement to the bucket policy.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n* BucketName: (Required) Name of the bucket to modify.\n* AccountId: (Required) Account to which the bucket belongs\n\n## Output Parameters\n\n* Remediation.Output - stdout messages from the remediation\n\n## Security Standards / Controls\n* AFSBP v1.0.0: S3.5\n* CIS v1.2.0:   n/a\n* PCI:          S3.5\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AccountId": {
       "type": "String",
       "description": "Account ID of the account for the finding",
       "allowedPattern": "^[0-9]{12}$"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "BucketName": {
       "type": "String",
       "description": "Name of the bucket to have a policy added",
       "allowedPattern": "(?=^.{3,63}$)(?!^(\\d+\\.)+\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])$)"
      }
     },
     "outputs": [
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "Remediation",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "accountid": "{{AccountId}}",
         "bucket": "{{BucketName}}",
         "partition": "{{global:AWS_PARTITION}}"
        },
        "Runtime": "python3.8",
        "Handler": "add_ssl_bucket_policy",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nboto_config = Config(\n    retries = {\n            'mode': 'standard',\n            'max_attempts': 10\n        }\n    )\n\ndef connect_to_s3():\n    return boto3.client('s3', config=boto_config)\n\ndef policy_to_add(bucket, partition):\n    return {\n        \"Sid\": \"AllowSSLRequestsOnly\",\n        \"Action\": \"s3:*\",\n        \"Effect\": \"Deny\",\n        \"Resource\": [\n            f'arn:{partition}:s3:::{bucket}',\n            f'arn:{partition}:s3:::{bucket}/*'\n        ],\n        \"Condition\": {\n            \"Bool\": {\n                    \"aws:SecureTransport\": \"false\"\n            }\n        },\n        \"Principal\": \"*\"\n    }\ndef new_policy():\n    return {\n        \"Id\": \"BucketPolicy\",\n        \"Version\": \"2012-10-17\",\n        \"Statement\": []\n    }\n\ndef add_ssl_bucket_policy(event, _):\n    bucket_name = event['bucket']\n    account_id = event['accountid']\n    aws_partition = event['partition']\n    s3 = connect_to_s3()\n    bucket_policy = {}\n    try:\n        existing_policy = s3.get_bucket_policy(\n            Bucket=bucket_name,\n            ExpectedBucketOwner=account_id\n        )\n        bucket_policy = json.loads(existing_policy['Policy'])\n    except ClientError as ex:\n        exception_type = ex.response['Error']['Code']\n        # delivery channel already exists - return\n        if exception_type not in [\"NoSuchBucketPolicy\"]:\n            exit(f'ERROR: Boto3 s3 ClientError: {exception_type} - {str(ex)}')\n    except Exception as e:\n        exit(f'ERROR getting bucket policy for {bucket_name}: {str(e)}')\n\n    if not bucket_policy:\n        bucket_policy = new_policy()\n\n    print(f'Existing policy: {bucket_policy}')\n    bucket_policy['Statement'].append(policy_to_add(bucket_name, aws_partition))\n\n    try:\n        result = s3.put_bucket_policy(\n            Bucket=bucket_name,\n            Policy=json.dumps(bucket_policy, indent=4, default=str),\n            ExpectedBucketOwner=account_id\n        )\n        print(result)\n    except ClientError as ex:\n        exception_type = ex.response['Error']['Code']\n        exit(f'ERROR: Boto3 s3 ClientError: {exception_type} - {str(ex)}')\n    except Exception as e:\n        exit(f'ERROR putting bucket policy for {bucket_name}: {str(e)}')\n\n    print(f'New policy: {bucket_policy}')"
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SetSSLBucketPolicy",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR SetSSLBucketPolicy"
   }
  },
  "ASRReplaceCodeBuildClearTextCredentials": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-ReplaceCodeBuildClearTextCredentials\n\n## What does this document do?\nThis document is used to replace environment variables containing clear text credentials in a CodeBuild project with Amazon EC2 Systems Manager Parameters.\n\n## Input Parameters\n* ProjectName: (Required) Name of the CodeBuild project (not the ARN).\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* CreateParameters.Parameters - results of the API calls to create SSM parameters\n* CreateParameters.Policy - result of the API call to create an IAM policy for the project to access the new parameters\n* CreateParameters.AttachResponse - result of the API call to attach the new IAM policy to the project service role\n* UpdateProject.Output - result of the API call to update the project environment with the new parameters\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "CreateParameters.Parameters",
      "CreateParameters.Policy",
      "CreateParameters.AttachResponse",
      "UpdateProject.Output"
     ],
     "parameters": {
      "ProjectName": {
       "type": "String",
       "description": "(Required) The project name (not the ARN).",
       "allowedPattern": "^[A-Za-z0-9][A-Za-z0-9\\-_]{1,254}$"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "BatchGetProjects",
       "action": "aws:executeAwsApi",
       "description": "## BatchGetProjects\nGets information about one or more build projects.\n",
       "inputs": {
        "Service": "codebuild",
        "Api": "BatchGetProjects",
        "names": [
         "{{ ProjectName }}"
        ]
       },
       "isCritical": true,
       "maxAttempts": 2,
       "timeoutSeconds": 600,
       "outputs": [
        {
         "Name": "ProjectInfo",
         "Selector": "$.projects[0]",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "CreateParameters",
       "action": "aws:executeScript",
       "description": "## CreateParameters\nParses project environment variables for credentials.\nCreates SSM parameters.\nReturns new project environment variables and SSM parameter information (without values).\n",
       "timeoutSeconds": 600,
       "isCritical": true,
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "replace_credentials",
        "InputPayload": {
         "ProjectInfo": "{{ BatchGetProjects.ProjectInfo }}"
        },
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nfrom json import dumps\nfrom boto3 import client\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\nimport re\n\nboto_config = Config(retries = {'mode': 'standard'})\n\nCREDENTIAL_NAMES_UPPER = [\n    'AWS_ACCESS_KEY_ID',\n    'AWS_SECRET_ACCESS_KEY'\n]\n\ndef connect_to_ssm(boto_config):\n    return client('ssm', config = boto_config)\n\ndef connect_to_iam(boto_config):\n    return client('iam', config = boto_config)\n\ndef is_clear_text_credential(env_var):\n    if env_var.get('type') != 'PLAINTEXT':\n        return False\n    return any(env_var.get('name').upper() == credential_name for credential_name in CREDENTIAL_NAMES_UPPER)\n\ndef get_project_ssm_namespace(project_name):\n    return f'/CodeBuild/{ project_name }'\n\ndef create_parameter(project_name, env_var):\n    env_var_name = env_var.get('name')\n    parameter_name = f'{ get_project_ssm_namespace(project_name) }/env/{ env_var_name }'\n\n    ssm_client = connect_to_ssm(boto_config)\n    try:\n        response = ssm_client.put_parameter(\n            Name = parameter_name,\n            Description = 'Automatically created by ASR',\n            Value = env_var.get(\"value\"),\n            Type = 'SecureString',\n            Overwrite = False,\n            DataType = 'text'\n        )\n    except ClientError as client_exception:\n        exception_type = client_exception.response['Error']['Code']\n        if exception_type == 'ParameterAlreadyExists':\n            print(f'Parameter { parameter_name } already exists. This remediation may have been run before.')\n            print('Ignoring exception - remediation continues.')\n            response = None\n        else:\n            exit(f'ERROR: Unhandled client exception: { client_exception }')\n    except Exception as e:\n        exit(f'ERROR: could not create SSM parameter { parameter_name }: { str(e) }')\n\n    return response, parameter_name\n\ndef create_policy(region, account, partition, project_name):\n    iam_client = connect_to_iam(boto_config)\n    policy_resource_filter = f'arn:{ partition }:ssm:{ region }:{ account }:parameter{ get_project_ssm_namespace(project_name) }/*'\n    policy_document = {\n        'Version': '2012-10-17',\n        'Statement': [\n            {\n                'Effect': 'Allow',\n                'Action': [\n                    'ssm:GetParameter',\n                    'ssm:GetParameters'\n                ],\n                'Resource': policy_resource_filter\n            }\n        ]\n    }\n    policy_name = f'CodeBuildSSMParameterPolicy-{ project_name }-{ region }'\n    try:\n        response = iam_client.create_policy(\n            Description = \"Automatically created by ASR\",\n            PolicyDocument = dumps(policy_document),\n            PolicyName = policy_name\n        )\n    except ClientError as client_exception:\n        exception_type = client_exception.response['Error']['Code']\n        if exception_type == 'EntityAlreadyExists':\n            print(f'Policy { \"\" } already exists. This remediation may have been run before.')\n            print('Ignoring exception - remediation continues.')\n            # Attach needs to know the ARN of the created policy\n            response = {\n                'Policy': {\n                    'Arn': f'arn:{ partition }:iam::{ account }:policy/{ policy_name }'\n                }\n            }\n        else:\n            exit(f'ERROR: Unhandled client exception: { client_exception }')\n    except Exception as e:\n        exit(f'ERROR: could not create access policy { policy_name }: { str(e) }')\n    return response\n\ndef attach_policy(policy_arn, service_role_name):\n    iam_client = connect_to_iam(boto_config)\n    try:\n        response = iam_client.attach_role_policy(\n            PolicyArn = policy_arn,\n            RoleName = service_role_name\n        )\n    except ClientError as client_exception:\n        exit(f'ERROR: Unhandled client exception: { client_exception }')\n    except Exception as e:\n        exit(f'ERROR: could not attach policy { policy_arn } to role { service_role_name }: { str(e) }')\n    return response\n\ndef parse_project_arn(arn):\n    pattern = re.compile(r'arn:(aws[a-zA-Z-]*):codebuild:([a-z]{2}(?:-gov)?-[a-z]+-\\d):(\\d{12}):project/[A-Za-z0-9][A-Za-z0-9\\-_]{1,254}$')\n    match = pattern.match(arn)\n    if match:\n        partition = match.group(1)\n        region = match.group(2)\n        account = match.group(3)\n        return partition, region, account\n    else:\n        raise ValueError\n\ndef replace_credentials(event, _):\n    project_info = event.get('ProjectInfo')\n    project_name = project_info.get('name')\n    project_env = project_info.get('environment')\n    project_env_vars = project_env.get('environmentVariables')\n    updated_project_env_vars = []\n    parameters = []\n\n    for env_var in project_env_vars:\n        if (is_clear_text_credential(env_var)):\n            parameter_response, parameter_name = create_parameter(project_name, env_var)\n            updated_env_var = {\n                'name': env_var.get('name'),\n                'type': 'PARAMETER_STORE',\n                'value': parameter_name\n            }\n            updated_project_env_vars.append(updated_env_var)\n            parameters.append(parameter_response)\n        else:\n            updated_project_env_vars.append(env_var)\n\n    updated_project_env = project_env\n    updated_project_env['environmentVariables'] = updated_project_env_vars\n\n    partition, region, account = parse_project_arn(project_info.get('arn'))\n    policy = create_policy(region, account, partition, project_name)\n    service_role_arn = project_info.get('serviceRole')\n    service_role_name = service_role_arn[service_role_arn.rfind('/') + 1:]\n    attach_response = attach_policy(policy['Policy']['Arn'], service_role_name)\n\n    # datetimes are not serializable, so convert them to ISO 8601 strings\n    policy_datetime_keys = ['CreateDate', 'UpdateDate']\n    for key in policy_datetime_keys:\n        if key in policy['Policy']:\n            policy['Policy'][key] = policy['Policy'][key].isoformat()\n\n    return {\n        'UpdatedProjectEnv': updated_project_env,\n        'Parameters': parameters,\n        'Policy': policy,\n        'AttachResponse': attach_response\n    }"
       },
       "outputs": [
        {
         "Name": "UpdatedProjectEnv",
         "Selector": "$.Payload.UpdatedProjectEnv",
         "Type": "StringMap"
        },
        {
         "Name": "Parameters",
         "Selector": "$.Payload.Parameters",
         "Type": "MapList"
        },
        {
         "Name": "Policy",
         "Selector": "$.Payload.Policy",
         "Type": "StringMap"
        },
        {
         "Name": "AttachResponse",
         "Selector": "$.Payload.AttachResponse",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "UpdateProject",
       "action": "aws:executeAwsApi",
       "description": "## UpdateProject\nChanges the settings of a build project.\n",
       "isEnd": true,
       "inputs": {
        "Service": "codebuild",
        "Api": "UpdateProject",
        "name": "{{ ProjectName }}",
        "environment": "{{ CreateParameters.UpdatedProjectEnv }}"
       },
       "isCritical": true,
       "maxAttempts": 2,
       "timeoutSeconds": 600,
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-ReplaceCodeBuildClearTextCredentials",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR ReplaceCodeBuildClearTextCredentials"
   }
  },
  "ASRS3BlockDenylist": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-S3BlockDenyList\n\n## What does this document do?\nThis document adds an explicit DENY to the bucket policy to prevent cross-account access to specific sensitive API calls. By default these are s3:DeleteBucketPolicy, s3:PutBucketAcl, s3:PutBucketPolicy, s3:PutEncryptionConfiguration, and s3:PutObjectAcl.\n\n## Input Parameters\n* BucketName: (Required) Bucket whose bucket policy is to be restricted.\n* DenyList: (Required) List of permissions to be explicitly denied when the Principal contains a role or user in another account.\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* PutS3BucketPolicyDeny.Output\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "BucketName": {
       "type": "String",
       "description": "(Required) The bucket name (not the ARN).",
       "allowedPattern": "(?=^.{3,63}$)(?!^(\\d+\\.)+\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])$)"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "DenyList": {
       "type": "String",
       "description": "(Required) Comma-delimited list (string) of permissions to be explicitly denied when the Principal contains a role or user in another account.",
       "allowedPattern": ".*"
      }
     },
     "outputs": [
      "PutS3BucketPolicyDeny.Output"
     ],
     "mainSteps": [
      {
       "name": "PutS3BucketPolicyDeny",
       "action": "aws:executeScript",
       "description": "## PutS3BucketPolicyDeny\nAdds an explicit deny to the bucket policy for specific restricted permissions.\n",
       "timeoutSeconds": 600,
       "inputs": {
        "InputPayload": {
         "accountid": "{{global:ACCOUNT_ID}}",
         "bucket": "{{BucketName}}",
         "denylist": "{{DenyList}}"
        },
        "Runtime": "python3.8",
        "Handler": "update_bucket_policy",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\n'''\nGiven a bucket name and list of \"sensitive\" IAM permissions that shall not be\nallowed cross-account, create an explicit deny policy for all cross-account\nprincipals, denying access to all IAM permissions in the deny list for all\nresources.\n\nNote:\n- The deny list is a comma-separated list configured on the Config rule in parameter blacklistedActionPattern\n'''\nimport json\nimport boto3\nimport copy\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nBOTO_CONFIG = Config(\n    retries = {\n            'mode': 'standard',\n            'max_attempts': 10\n        }\n    )\n\ndef connect_to_s3():\n    return boto3.client('s3', config=BOTO_CONFIG)\n\ndef get_partition():\n    return boto3.client('sts', config=BOTO_CONFIG).get_caller_identity().get('Arn').split(':')[1]\n\nclass BucketToRemediate:\n    def __init__(self, bucket_name):\n        self.bucket_name = bucket_name\n        self.get_partition_where_running()\n        self.initialize_bucket_policy_to_none()\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n    def initialize_bucket_policy_to_none(self):\n        self.bucket_policy = None\n\n    def get_partition_where_running(self):\n        self.partition = get_partition()\n\n    def set_account_id_from_event(self, event):\n        self.account_id = event.get('accountid') or exit('AWS Account not specified')\n\n    def set_denylist_from_event(self, event):\n        self.denylist = event.get('denylist').split(',') or exit('DenyList is empty or not a comma-delimited string') # Expect a comma seperated list in a string\n\n    def get_current_bucket_policy(self):\n        try:\n            self.bucket_policy = connect_to_s3().get_bucket_policy(\n                Bucket=self.bucket_name,\n                ExpectedBucketOwner=self.account_id\n            ).get('Policy')\n\n        except Exception as e:\n            print(e)\n            exit(f'Failed to retrieve the bucket policy: {self.account_id} {self.bucket_name}')\n\n    def update_bucket_policy(self):\n        try:\n            connect_to_s3().put_bucket_policy(\n                Bucket=self.bucket_name,\n                ExpectedBucketOwner=self.account_id,\n                Policy=self.bucket_policy\n            )\n        except Exception as e:\n            print(e)\n            exit(f'Failed to store the new bucket policy: {self.account_id} {self.bucket_name}')\n\n    def __principal_is_asterisk(self, principals):\n        return (True if isinstance(principals, str) and principals == '*' else False)\n\n    def get_account_principals_from_bucket_policy_statement(self, statement_principals):\n        aws_account_principals = []\n        for principal_type, principal in statement_principals.items():\n            if principal_type != 'AWS':\n                continue # not an AWS account\n            aws_account_principals = principal if isinstance(principal, list) else [ principal ]\n        return aws_account_principals\n\n    def create_explicit_deny_in_bucket_policy(self):\n        new_bucket_policy = json.loads(self.bucket_policy)\n        deny_statement = DenyStatement(self)\n        for statement in new_bucket_policy['Statement']:\n            principals = statement.get('Principal', None)\n            if principals and not self.__principal_is_asterisk(principals):\n                account_principals = self.get_account_principals_from_bucket_policy_statement(copy.deepcopy(principals))\n                deny_statement.add_next_principal_to_deny(account_principals, self.account_id)\n\n        if deny_statement.deny_statement_json:\n            new_bucket_policy['Statement'].append(deny_statement.deny_statement_json)\n            self.bucket_policy = json.dumps(new_bucket_policy)\n            return True\n\nclass DenyStatement:\n    def __init__(self, bucket_object):\n        self.bucket_object = bucket_object\n        self.initialize_deny_statement()\n\n    def initialize_deny_statement(self):\n        self.deny_statement_json = {}\n        self.deny_statement_json[\"Effect\"] = \"Deny\"\n        self.deny_statement_json[\"Principal\"] = {\n            \"AWS\": []\n        }\n        self.deny_statement_json[\"Action\"] = self.bucket_object.denylist\n        self.deny_statement_json[\"Resource\"] = [\n            f'arn:{self.bucket_object.partition}:s3:::{self.bucket_object.bucket_name}',\n            f'arn:{self.bucket_object.partition}:s3:::{self.bucket_object.bucket_name}/*',\n        ]\n\n    def __str__(self):\n        return json.dumps(self.deny_statement_json)\n\n    def add_next_principal_to_deny(self, principals_to_deny, bucket_account):\n        if len(principals_to_deny) == 0:\n            return\n        this_principal = principals_to_deny.pop()\n        principal_account = this_principal.split(':')[4]\n        if principal_account and principal_account != bucket_account:\n            self.add_deny_principal(this_principal)\n\n        self.add_next_principal_to_deny(principals_to_deny, bucket_account)\n\n    def add_deny_principal(self, principal_arn):\n        if principal_arn not in self.deny_statement_json[\"Principal\"][\"AWS\"]:\n            self.deny_statement_json[\"Principal\"][\"AWS\"].append(principal_arn)\n\n    def add_deny_resource(self, resource_arn):\n        if self.deny_statement_json[\"Resource\"] and resource_arn not in self.deny_statement_json.Resource:\n            self.deny_statement_json[\"Resource\"].append(resource_arn)\n\ndef update_bucket_policy(event, _):\n    def __get_bucket_from_event(event):\n        bucket = event.get('bucket') or exit('Bucket not specified')\n        return bucket\n\n    bucket_to_update = BucketToRemediate(__get_bucket_from_event(event))\n    bucket_to_update.set_denylist_from_event(event)\n    bucket_to_update.set_account_id_from_event(event)\n    bucket_to_update.get_current_bucket_policy()\n    if bucket_to_update.create_explicit_deny_in_bucket_policy():\n        bucket_to_update.update_bucket_policy()\n    else:\n        exit(f'Unable to create an explicit deny statement for {bucket_to_update.bucket_name}')"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-S3BlockDenylist",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR S3BlockDenylist"
   }
  },
  "ASREncryptRDSSnapshot": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-EncryptRDSSnapshot\n\n## What does this document do?\nThis document encrypts an RDS snapshot or cluster snapshot.\n\n## Input Parameters\n* SourceDBSnapshotIdentifier: (Required) The name of the unencrypted RDS snapshot. Note that this snapshot will be deleted as part of this document's execution.\n* TargetDBSnapshotIdentifier: (Required) The name of the encrypted RDS snapshot to create.\n* DBSnapshotType: (Required) The type of snapshot (DB or cluster).\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* KmsKeyId: (Optional) ID, ARN or Alias for the AWS KMS Customer-Managed Key (CMK) to use. If no key is specified, the default encryption key for snapshots (`alias/aws/rds`) will be used.\n\n## Output Parameters\n* CopyRdsSnapshotToEncryptedRdsSnapshot.EncryptedSnapshotId: The ID of the encrypted RDS snapshot.\n* CopyRdsClusterSnapshotToEncryptedRdsClusterSnapshot.EncryptedClusterSnapshotId: The ID of the encrypted RDS cluster snapshot.\n\n## Minimum Permissions Required\n* `rds:CopyDBSnapshot`\n* `rds:CopyDBClusterSnapshot`\n* `rds:DescribeDBSnapshots`\n* `rds:DescribeDBClusterSnapshots`\n* `rds:DeleteDBSnapshot`\n* `rds:DeleteDBClusterSnapshot`\n\n### Key Permissions\nIf KmsKeyId is a Customer-Managed Key (CMK), then AutomationAssumeRole must have the following permissions on that key:\n* `kms:DescribeKey`\n* `kms:CreateGrant`\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "parameters": {
      "SourceDBSnapshotIdentifier": {
       "type": "String",
       "description": "(Required) The name of the unencrypted RDS snapshot or cluster snapshot to copy.",
       "allowedPattern": "^(?:rds:)?(?!.*--.*)(?!.*-$)[a-zA-Z][a-zA-Z0-9-]{0,254}$"
      },
      "TargetDBSnapshotIdentifier": {
       "type": "String",
       "description": "(Required) The name of the encrypted RDS snapshot or cluster snapshot to create.",
       "allowedPattern": "^(?!.*--.*)(?!.*-$)[a-zA-Z][a-zA-Z0-9-]{0,254}$"
      },
      "DBSnapshotType": {
       "type": "String",
       "allowedValues": [
        "snapshot",
        "cluster-snapshot",
        "dbclustersnapshot"
       ]
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "KmsKeyId": {
       "type": "String",
       "description": "(Optional) ID, ARN or Alias for the AWS KMS Customer-Managed Key (CMK) to use to encrypt the snapshot.",
       "default": "alias/aws/rds",
       "allowedPattern": "^(?:arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:)?(?:(?:alias/[A-Za-z0-9/_-]+)|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      }
     },
     "outputs": [
      "CopyRdsSnapshotToEncryptedRdsSnapshot.EncryptedSnapshotId",
      "CopyRdsClusterSnapshotToEncryptedRdsClusterSnapshot.EncryptedClusterSnapshotId"
     ],
     "mainSteps": [
      {
       "name": "ChooseSnapshotOrClusterSnapshot",
       "action": "aws:branch",
       "inputs": {
        "Choices": [
         {
          "NextStep": "CopyRdsSnapshotToEncryptedRdsSnapshot",
          "Variable": "{{DBSnapshotType}}",
          "StringEquals": "snapshot"
         },
         {
          "Or": [
           {
            "Variable": "{{DBSnapshotType}}",
            "StringEquals": "cluster-snapshot"
           },
           {
            "Variable": "{{DBSnapshotType}}",
            "StringEquals": "dbclustersnapshot"
           }
          ],
          "NextStep": "CopyRdsClusterSnapshotToEncryptedRdsClusterSnapshot"
         }
        ]
       }
      },
      {
       "name": "CopyRdsSnapshotToEncryptedRdsSnapshot",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "rds",
        "Api": "CopyDBSnapshot",
        "SourceDBSnapshotIdentifier": "{{SourceDBSnapshotIdentifier}}",
        "TargetDBSnapshotIdentifier": "{{TargetDBSnapshotIdentifier}}",
        "CopyTags": true,
        "KmsKeyId": "{{KmsKeyId}}"
       },
       "outputs": [
        {
         "Name": "EncryptedSnapshotId",
         "Selector": "$.DBSnapshot.DBSnapshotIdentifier",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyRdsEncryptedSnapshot",
       "action": "aws:waitForAwsResourceProperty",
       "timeoutSeconds": 14400,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBSnapshots",
        "Filters": [
         {
          "Name": "db-snapshot-id",
          "Values": [
           "{{CopyRdsSnapshotToEncryptedRdsSnapshot.EncryptedSnapshotId}}"
          ]
         }
        ],
        "PropertySelector": "$.DBSnapshots[0].Status",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "DeleteUnencryptedRdsSnapshot",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "rds",
        "Api": "DeleteDBSnapshot",
        "DBSnapshotIdentifier": "{{SourceDBSnapshotIdentifier}}"
       },
       "isEnd": true
      },
      {
       "name": "CopyRdsClusterSnapshotToEncryptedRdsClusterSnapshot",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "rds",
        "Api": "CopyDBClusterSnapshot",
        "SourceDBClusterSnapshotIdentifier": "{{SourceDBSnapshotIdentifier}}",
        "TargetDBClusterSnapshotIdentifier": "{{TargetDBSnapshotIdentifier}}",
        "CopyTags": true,
        "KmsKeyId": "{{KmsKeyId}}"
       },
       "outputs": [
        {
         "Name": "EncryptedClusterSnapshotId",
         "Selector": "$.DBClusterSnapshot.DBClusterSnapshotIdentifier",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyRdsEncryptedClusterSnapshot",
       "action": "aws:waitForAwsResourceProperty",
       "timeoutSeconds": 14400,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBClusterSnapshots",
        "Filters": [
         {
          "Name": "db-cluster-snapshot-id",
          "Values": [
           "{{CopyRdsClusterSnapshotToEncryptedRdsClusterSnapshot.EncryptedClusterSnapshotId}}"
          ]
         }
        ],
        "PropertySelector": "$.DBClusterSnapshots[0].Status",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "DeleteUnencryptedRdsClusterSnapshot",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "rds",
        "Api": "DeleteDBClusterSnapshot",
        "DBSnapshotIdentifier": "{{SourceDBSnapshotIdentifier}}"
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EncryptRDSSnapshot",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EncryptRDSSnapshot"
   }
  },
  "ASRDisablePublicAccessToRedshiftCluster": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-DisablePublicAccessToRedshiftCluster\n\n## What does this document do?\nThe runbook disables public accessibility for the Amazon Redshift cluster you specify using the [ModifyCluster]\n(https://docs.aws.amazon.com/redshift/latest/APIReference/API_ModifyCluster.html) API.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n* ClusterIdentifier: (Required) The unique identifier of the cluster you want to disable the public accessibility.\n\n## Output Parameters\n* DisableRedshiftPubliclyAccessible.Response: The standard HTTP response from the ModifyCluster API call.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "ClusterIdentifier": {
       "type": "String",
       "description": "(Required) The unique identifier of the cluster you want to disable the public accessibility.",
       "allowedPattern": "^(?!.*--)[a-z][a-z0-9-]{0,62}(?<!-)$"
      }
     },
     "outputs": [
      "DisableRedshiftPubliclyAccessible.Response"
     ],
     "mainSteps": [
      {
       "name": "DisableRedshiftPubliclyAccessible",
       "action": "aws:executeAwsApi",
       "description": "## DisableRedshiftPubliclyAccessible\nDisables public accessibility for the cluster specified in the ClusterIdentifer parameter.\n## Outputs\n* Response: The standard HTTP response from the ModifyCluster API call.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "redshift",
        "Api": "ModifyCluster",
        "ClusterIdentifier": "{{ ClusterIdentifier }}",
        "PubliclyAccessible": false
       },
       "outputs": [
        {
         "Name": "Response",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "WaitForRedshiftClusterAvailability",
       "action": "aws:waitForAwsResourceProperty",
       "description": "## WaitForRedshiftClusterAvailability\nWaits for the state of the cluster to change to available.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeClusters",
        "ClusterIdentifier": "{{ ClusterIdentifier }}",
        "PropertySelector": "$.Clusters[0].ClusterStatus",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "VerifyRedshiftPubliclyAccessible",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## VerifyRedshiftPubliclyAccessible\nConfirms the public accessibility setting is disabled on the cluster.\n",
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeClusters",
        "ClusterIdentifier": "{{ ClusterIdentifier }}",
        "PropertySelector": "$.Clusters[0].PubliclyAccessible",
        "DesiredValues": [
         "False"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-DisablePublicAccessToRedshiftCluster",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR DisablePublicAccessToRedshiftCluster"
   }
  },
  "ASREnableRedshiftClusterAuditLogging": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document name - AWSConfigRemediation-EnableRedshiftClusterAuditLogging\n\n## What does this document do?\nThis automation document enables audit logging on the Amazon Redshift cluster using [EnableLogging](https://docs.aws.amazon.com/redshift/latest/APIReference/API_EnableLogging.html) API call with given bucket name and s3 key prefix.\n\n## Input Parameters\n* ClusterIdentifier: (Required) The unique identifier of the Amazon Redshift cluster on which logging to be started.\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* BucketName: (Required) The name of an existing Amazon S3 bucket where the log files are to be stored.\n* S3KeyPrefix: (Optional) The prefix applied to the log file names.\n\n## Output Parameters\n* EnableLoggingWithPrefix.Response: Standard HTTP response of the EnableLogging API.\n* EnableLoggingWithoutPrefix.Response: Standard HTTP response of the EnableLogging API.\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "EnableLoggingWithoutPrefix.Response",
      "EnableLoggingWithPrefix.Response"
     ],
     "parameters": {
      "ClusterIdentifier": {
       "type": "String",
       "description": "The unique identifier of the Amazon Redshift cluster on which the logging logging to be started.",
       "allowedPattern": "^(?!.*--)[a-z][a-z0-9-]{0,62}(?<!-)$"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "BucketName": {
       "type": "String",
       "description": "The name of an existing Amazon S3 bucket where the log files are to be stored.",
       "allowedPattern": "(?=^.{3,63}$)(?!^(\\d+\\.)+\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])$)"
      },
      "S3KeyPrefix": {
       "type": "String",
       "description": "The prefix applied to the log file names.",
       "allowedPattern": "^[^\"'\\\\ ]{0,512}$",
       "default": ""
      }
     },
     "mainSteps": [
      {
       "name": "CheckS3KeyPrefix",
       "description": "## CheckS3KeyPrefix\nChecks whether S3KeyPrefix provided in the input parameters.\n",
       "action": "aws:branch",
       "inputs": {
        "Choices": [
         {
          "NextStep": "EnableLoggingWithoutPrefix",
          "Variable": "{{S3KeyPrefix}}",
          "StringEquals": ""
         }
        ],
        "Default": "EnableLoggingWithPrefix"
       },
       "isEnd": true
      },
      {
       "name": "EnableLoggingWithoutPrefix",
       "nextStep": "AssertClusterLoggingEnabled",
       "action": "aws:executeAwsApi",
       "description": "## EnableLoggingWithoutPrefix\nEnables logging on the given Amazon Redshift cluster using the [EnableLogging](https://docs.aws.amazon.com/redshift/latest/APIReference/API_EnableLogging.html) API with given bucket name in input parameters.\n## Outputs\n* Response: Standard HTTP response of the EnableLogging API.\n",
       "inputs": {
        "Service": "redshift",
        "Api": "EnableLogging",
        "BucketName": "{{BucketName}}",
        "ClusterIdentifier": "{{ ClusterIdentifier }}"
       },
       "outputs": [
        {
         "Name": "Response",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "EnableLoggingWithPrefix",
       "action": "aws:executeAwsApi",
       "description": "## EnableLoggingWithPrefix\nEnables logging on the given Amazon Redshift cluster using the [EnableLogging](https://docs.aws.amazon.com/redshift/latest/APIReference/API_EnableLogging.html) API with given bucket name and s3 key prefix in input parameters.\n## Outputs\n* Response: Standard HTTP response of the EnableLogging API.\n",
       "inputs": {
        "Service": "redshift",
        "Api": "EnableLogging",
        "BucketName": "{{BucketName}}",
        "S3KeyPrefix": "{{S3KeyPrefix}}",
        "ClusterIdentifier": "{{ ClusterIdentifier }}"
       },
       "outputs": [
        {
         "Name": "Response",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "AssertClusterBucketPrefix",
       "description": "## AssertClusterBucketPrefix\nVerifies whether the value of the \"S3KeyPrefix\" parameter is used for logging for the given Amazon Redshift cluster.\n",
       "action": "aws:assertAwsResourceProperty",
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeLoggingStatus",
        "ClusterIdentifier": "{{ ClusterIdentifier }}",
        "PropertySelector": "$.S3KeyPrefix",
        "DesiredValues": [
         "{{S3KeyPrefix}}/"
        ]
       }
      },
      {
       "name": "AssertClusterLoggingEnabled",
       "description": "## AssertClusterLoggingEnabled\nVerifies whether the \"LoggingEnabled\" property is set to \"True\" for the given Amazon Redshift cluster.\n",
       "action": "aws:assertAwsResourceProperty",
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeLoggingStatus",
        "ClusterIdentifier": "{{ ClusterIdentifier }}",
        "PropertySelector": "$.LoggingEnabled",
        "DesiredValues": [
         "True"
        ]
       }
      },
      {
       "name": "AssertClusterLoggingBucket",
       "description": "## AssertClusterLoggingBucket\nChecks whether the value of the \"BucketName\" parameter is used for the audit logging configuration of the given Amazon Redshift cluster.\n",
       "action": "aws:assertAwsResourceProperty",
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeLoggingStatus",
        "ClusterIdentifier": "{{ ClusterIdentifier }}",
        "PropertySelector": "$.BucketName",
        "DesiredValues": [
         "{{BucketName}}"
        ]
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableRedshiftClusterAuditLogging",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableRedshiftClusterAuditLogging"
   }
  },
  "ASREnableAutomaticVersionUpgradeOnRedshiftCluster": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-EnableAutomaticVersionUpgradeOnRedshiftCluster\n\n## What does this document do?\nThe runbook enables automatic version upgrade on a Redshift cluster.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* ClusterIdentifier: (Required) The unique identifier of the cluster.\n* AllowVersionUpgrade: (Optional) Whether to allow version upgrade on the cluster.\n\n## Output Parameters\n* EnableAutomaticVersionUpgrade.Response: The response of the API call to enable automatic version upgrade on the cluster.\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "ClusterIdentifier": {
       "type": "String",
       "description": "(Required) The unique identifier of the cluster.",
       "allowedPattern": "^(?!.*--)[a-z][a-z0-9-]{0,62}(?<!-)$"
      },
      "AllowVersionUpgrade": {
       "type": "Boolean",
       "description": "(Optional) Whether to allow version upgrade on the cluster.",
       "default": true
      }
     },
     "outputs": [
      "EnableAutomaticVersionUpgrade.Response"
     ],
     "mainSteps": [
      {
       "name": "EnableAutomaticVersionUpgrade",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "redshift",
        "Api": "ModifyCluster",
        "ClusterIdentifier": "{{ClusterIdentifier}}",
        "AllowVersionUpgrade": "{{AllowVersionUpgrade}}"
       },
       "outputs": [
        {
         "Name": "Response",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "WaitForClusterAvailability",
       "action": "aws:waitForAwsResourceProperty",
       "timeoutSeconds": 600,
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeClusters",
        "ClusterIdentifier": "{{ClusterIdentifier}}",
        "PropertySelector": "$.Clusters[0].ClusterStatus",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "CastAllowVersionUpgradeToString",
       "action": "aws:executeScript",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "event_handler",
        "InputPayload": {
         "AllowVersionUpgrade": "{{AllowVersionUpgrade}}"
        },
        "Script": "def event_handler(event, context):\n    return str(event['AllowVersionUpgrade'])\n"
       },
       "outputs": [
        {
         "Name": "AllowVersionUpgradeString",
         "Selector": "$.Payload",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyAutomaticVersionUpgrade",
       "action": "aws:assertAwsResourceProperty",
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeClusters",
        "ClusterIdentifier": "{{ClusterIdentifier}}",
        "PropertySelector": "$.Clusters[0].AllowVersionUpgrade",
        "DesiredValues": [
         "{{CastAllowVersionUpgradeToString.AllowVersionUpgradeString}}"
        ]
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableAutomaticVersionUpgradeOnRedshiftCluster",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableAutomaticVersionUpgradeOnRedshiftCluster"
   }
  },
  "ASREnableAutomaticSnapshotsOnRedshiftCluster": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-EnableAutomaticSnapshotsOnRedshiftCluster\n\n## What does this document do?\nThe runbook enables automatic snapshots on a Redshift cluster.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* ClusterIdentifier: (Required) The unique identifier of the cluster.\n* RetentionPeriod: (Optional) The minimum retention period for the automatic snapshots in days.\n\n## Output Parameters\n* QueryRetentionPeriod.CurrentRetentionPeriod: The retention period of the cluster in days at the start of the automation.\n* ModifyRetentionPeriod.Response: The response of the API call to modify the retention period of the cluster.\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "ClusterIdentifier": {
       "type": "String",
       "description": "(Required) The unique identifier of the cluster.",
       "allowedPattern": "^(?!.*--)[a-z][a-z0-9-]{0,62}(?<!-)$"
      },
      "MinRetentionPeriod": {
       "type": "Integer",
       "description": "(Optional) The minimum retention period for the automatic snapshots in days.",
       "default": 7
      }
     },
     "outputs": [
      "QueryRetentionPeriod.CurrentRetentionPeriod",
      "ModifyRetentionPeriod.Response"
     ],
     "mainSteps": [
      {
       "name": "QueryRetentionPeriod",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeClusters",
        "ClusterIdentifier": "{{ClusterIdentifier}}"
       },
       "outputs": [
        {
         "Name": "CurrentRetentionPeriod",
         "Selector": "$.Clusters[0].AutomatedSnapshotRetentionPeriod",
         "Type": "Integer"
        }
       ]
      },
      {
       "name": "ChooseModifyRetentionPeriod",
       "action": "aws:branch",
       "inputs": {
        "Choices": [
         {
          "NextStep": "CastCurrentRetentionPeriodToString",
          "Variable": "{{QueryRetentionPeriod.CurrentRetentionPeriod}}",
          "NumericGreaterOrEquals": "{{MinRetentionPeriod}}"
         }
        ],
        "Default": "ModifyRetentionPeriod"
       }
      },
      {
       "name": "CastCurrentRetentionPeriodToString",
       "action": "aws:executeScript",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "event_handler",
        "InputPayload": {
         "RetentionPeriod": "{{QueryRetentionPeriod.CurrentRetentionPeriod}}"
        },
        "Script": "def event_handler(event, context):\n    return str(event['RetentionPeriod'])\n"
       },
       "outputs": [
        {
         "Name": "CurrentRetentionPeriodString",
         "Selector": "$.Payload",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyCurrentRetentionPeriod",
       "action": "aws:assertAwsResourceProperty",
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeClusters",
        "ClusterIdentifier": "{{ClusterIdentifier}}",
        "PropertySelector": "$.Clusters[0].AutomatedSnapshotRetentionPeriod",
        "DesiredValues": [
         "{{CastCurrentRetentionPeriodToString.CurrentRetentionPeriodString}}"
        ]
       },
       "isEnd": true
      },
      {
       "name": "ModifyRetentionPeriod",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "redshift",
        "Api": "ModifyCluster",
        "ClusterIdentifier": "{{ClusterIdentifier}}",
        "AutomatedSnapshotRetentionPeriod": "{{MinRetentionPeriod}}"
       },
       "outputs": [
        {
         "Name": "Response",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "WaitForClusterAvailability",
       "action": "aws:waitForAwsResourceProperty",
       "timeoutSeconds": 600,
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeClusters",
        "ClusterIdentifier": "{{ClusterIdentifier}}",
        "PropertySelector": "$.Clusters[0].ClusterStatus",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "CastRetentionPeriodToString",
       "action": "aws:executeScript",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "event_handler",
        "InputPayload": {
         "RetentionPeriod": "{{MinRetentionPeriod}}"
        },
        "Script": "def event_handler(event, context):\n    return str(event['RetentionPeriod'])\n"
       },
       "outputs": [
        {
         "Name": "MinRetentionPeriodString",
         "Selector": "$.Payload",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyModifiedRetentionPeriod",
       "action": "aws:assertAwsResourceProperty",
       "inputs": {
        "Service": "redshift",
        "Api": "DescribeClusters",
        "ClusterIdentifier": "{{ClusterIdentifier}}",
        "PropertySelector": "$.Clusters[0].AutomatedSnapshotRetentionPeriod",
        "DesiredValues": [
         "{{CastRetentionPeriodToString.MinRetentionPeriodString}}"
        ]
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableAutomaticSnapshotsOnRedshiftCluster",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableAutomaticSnapshotsOnRedshiftCluster"
   }
  },
  "ASRCreateIAMSupportRole": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-CreateIAMSupportRole\n\n## What does this document do?\nThis document creates a role to allow AWS Support access.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* CreateIAMRole.Output\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "CreateIAMSupportRole.Output"
     ],
     "mainSteps": [
      {
       "name": "CreateIAMSupportRole",
       "action": "aws:executeScript",
       "timeoutSeconds": 300,
       "isEnd": true,
       "description": "## CreateIAMSupportRole\n\nThis step deactivates IAM user access keys that have not been rotated in more than MaxCredentialUsageAge days\n## Outputs\n* Output: Success message or failure Exception.\n",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "create_iam_role",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\nfrom botocore.config import Config\nimport boto3\n\nBOTO_CONFIG = Config(retries={\"mode\": \"standard\"})\n\nresponses = {}\nresponses[\"CreateIAMRoleResponse\"] = []\n\n\ndef connect_to_iam(boto_config):\n    return boto3.client(\"iam\", config=boto_config)\n\n\ndef get_account(boto_config):\n    return boto3.client('sts', config=boto_config).get_caller_identity()['Account']\n\n\ndef get_partition(boto_config):\n    return boto3.client('sts', config=boto_config).get_caller_identity()['Arn'].split(':')[1]\n\n\ndef create_iam_role(_, __):\n    account = get_account(BOTO_CONFIG)\n    partition = get_partition(BOTO_CONFIG)\n\n    aws_support_policy = {\n        \"Version\": \"2012-10-17\",\n        \"Statement\": [\n            {\n                \"Effect\": \"Allow\",\n                \"Action\": \"sts:AssumeRole\",\n                \"Principal\": {\"AWS\": f\"arn:{partition}:iam::{account}:root\"},\n            }\n        ],\n    }\n\n    role_name = \"aws_incident_support_role\"\n    iam = connect_to_iam(BOTO_CONFIG)\n    if not does_role_exist(iam, role_name):\n        iam.create_role(\n            RoleName=role_name,\n            AssumeRolePolicyDocument=json.dumps(aws_support_policy),\n            Description=\"Created by ASR security hub remediation 1.20 rule\",\n            Tags=[\n                {\"Key\": \"Name\", \"Value\": \"CIS 1.20 aws support access role\"},\n            ],\n        )\n\n    iam.attach_role_policy(\n        RoleName=role_name,\n        PolicyArn=f\"arn:{partition}:iam::aws:policy/AWSSupportAccess\",\n    )\n\n    responses[\"CreateIAMRoleResponse\"].append(\n        {\"Account\": account, \"RoleName\": role_name}\n    )\n\n    return {\"output\": \"IAM role creation is successful.\", \"http_responses\": responses}\n\n\ndef does_role_exist(iam, role_name):\n    \"\"\"Check if the role name exists.\n\n    Parameters\n    ----------\n    iam: iam client, required\n    role_name: string, required\n\n    Returns\n    ------\n        bool: returns if the role exists\n    \"\"\"\n    role_exists = False\n\n    try:\n        response = iam.get_role(RoleName=role_name)\n\n        if \"Role\" in response:\n            role_exists = True\n\n    except iam.exceptions.NoSuchEntityException:\n        role_exists = False\n\n    return role_exists"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-CreateIAMSupportRole",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR CreateIAMSupportRole"
   }
  },
  "ASREnableEncryptionForSQSQueue": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-EnableEncryptionForSQSQueue\n\n## What does this document do?\nThis document enables encryption on given Amazon Simple Queue Service (Amazon SQS) queue using\n[SetQueueAttributes](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SetQueueAttributes.html) API.\n\nThis document must only be used as a baseline to ensure that your Amazon SQS queues are encrypted with the minimum security best practice of using an AWS KMS customer managed CMK.\nBased on your data policy, Amazon SQS queues should be encrypted with different customer managed CMKs as documented [here](https://docs.aws.amazon.com/kms/latest/developerguide/best-practices.html).\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* SQSQueueName: (Required)  The name of the Amazon SQS Queue.\n* KmsKeyArn: (Required) The ARN of AWS KMS Key.\n\n## Security Standards / Controls\n* AFSBP v1.0.0:   SQS.1\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "KmsKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for this remediation",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      },
      "SQSQueueName": {
       "type": "String",
       "description": "(Required) The name of the Amazon SQS Queue.",
       "allowedPattern": "^[a-zA-Z0-9_-]{1,80}(?:\\.fifo)?$"
      }
     },
     "outputs": [
      "EncryptSQSQueue.Response"
     ],
     "mainSteps": [
      {
       "name": "GetQueueUrl",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "sqs",
        "Api": "GetQueueUrl",
        "QueueName": "{{ SQSQueueName }}"
       },
       "outputs": [
        {
         "Name": "QueueUrl",
         "Selector": "$.QueueUrl",
         "Type": "String"
        }
       ]
      },
      {
       "name": "EncryptSQSQueue",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "sqs",
        "Api": "SetQueueAttributes",
        "QueueUrl": "{{ GetQueueUrl.QueueUrl }}",
        "Attributes": {
         "KmsMasterKeyId": "{{ KmsKeyArn }}"
        }
       },
       "outputs": [
        {
         "Name": "Response",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyQueueEncryption",
       "action": "aws:waitForAwsResourceProperty",
       "timeoutSeconds": 300,
       "inputs": {
        "Service": "sqs",
        "Api": "GetQueueAttributes",
        "QueueUrl": "{{ GetQueueUrl.QueueUrl }}",
        "AttributeNames": [
         "KmsMasterKeyId"
        ],
        "PropertySelector": "$.Attributes.KmsMasterKeyId",
        "DesiredValues": [
         "{{ KmsKeyArn }}"
        ]
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableEncryptionForSQSQueue",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableEncryptionForSQSQueue"
   }
  },
  "ASRConfigureSNSTopicForStack": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-ConfigureSNSTopicForStack\n\n## What does this document do?\nThis document creates an SNS topic if it does not already exist, then updates the stack to notify the topic on changes\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* StackArn: (Required)  The ARN of the stack.\n\n## Security Standards / Controls\n* AFSBP v1.0.0:   CloudFormation.1\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "StackArn": {
       "type": "String",
       "description": "(Required) The ARN of the CloudFormation stack.",
       "allowedPattern": "^(arn:(?:aws|aws-us-gov|aws-cn):cloudformation:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:stack/[a-zA-Z][a-zA-Z0-9-]{0,127}/[a-fA-F0-9]{8}-(?:[a-fA-F0-9]{4}-){3}[a-fA-F0-9]{12})$"
      },
      "TopicName": {
       "type": "String",
       "description": "(Optional) The name of the SNS topic to create and configure for notifications.",
       "allowedPattern": "^[a-zA-Z0-9][a-zA-Z0-9-_]{0,255}$",
       "default": "SO0111-ASR-CloudFormationNotifications"
      }
     },
     "outputs": [
      "ConfigureSNSTopic.Output"
     ],
     "mainSteps": [
      {
       "name": "ConfigureSNSTopic",
       "action": "aws:executeScript",
       "timeoutSeconds": 600,
       "inputs": {
        "InputPayload": {
         "stack_arn": "{{ StackArn }}",
         "topic_name": "SO0111-ASR-CloudFormationNotifications"
        },
        "Runtime": "python3.8",
        "Handler": "lambda_handler",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\n\"\"\"\nConfigure a CloudFormation stack with an SNS topic for notifications, creating the topic if it does\nnot already exist\n\"\"\"\n\nfrom time import time, sleep\nimport boto3\nfrom botocore.config import Config\n\nboto_config = Config(retries={ 'mode': 'standard' })\n\ndef lambda_handler(event, _):\n    \"\"\"\n    Configure a CloudFormation stack with an SNS topic for notifications,\n    creating the topic if it does not already exist\n\n    `event` should have the following keys and values:\n    `stack_arn`: the ARN of the CloudFormation stack to be updated\n    `topic_name`: the name of the SQS Queue to create and configure for notifications\n\n    `context` is ignored\n    \"\"\"\n    stack_arn = event['stack_arn']\n    topic_name = event['topic_name']\n    topic_arn = get_or_create_topic(topic_name)\n    configure_notifications(stack_arn, topic_arn)\n    wait_for_update(stack_arn)\n    return assert_stack_configured(stack_arn, topic_arn)\n\ndef get_or_create_topic(topic_name: str):\n    \"\"\"Get the SQS topic arn for the given topic name, creating it if it does not already exist\"\"\"\n    sns = boto3.client('sns', config=boto_config)\n    response = sns.create_topic(Name=topic_name)\n    return response['TopicArn']\n\ndef configure_notifications(stack_arn: str, topic_arn: str):\n    \"\"\"Configure the stack with ARN `stack_arn` to notify the queue with ARN `topic_arn`\"\"\"\n    cloudformation = boto3.resource('cloudformation', config=boto_config)\n    stack = cloudformation.Stack(stack_arn)\n    kwargs = {\n        'UsePreviousTemplate': True,\n        'NotificationARNs': [topic_arn]}\n    if stack.parameters:\n        kwargs['Parameters'] = [{\n            'ParameterKey': param['ParameterKey'],\n            'UsePreviousValue': True\n        } for param in stack.parameters]\n    if stack.capabilities:\n        kwargs['Capabilities'] = stack.capabilities\n    stack.update(**kwargs)\n\nclass UpdateTimeoutException(Exception):\n    \"\"\"Timed out waiting for the CloudFormation stack to update\"\"\"\n\ndef wait_for_update(stack_arn: str):\n    \"\"\"Wait for the stack with ARN `stack_arn` to be in status `UPDATE_COMPLETE`\"\"\"\n    wait_interval_seconds = 10\n    timeout_seconds = 300\n    start = time()\n    while get_stack_status(stack_arn) != 'UPDATE_COMPLETE':\n        if time() - start > timeout_seconds:\n            raise UpdateTimeoutException('Timed out waiting for stack update')\n        wait_seconds(wait_interval_seconds)\n        wait_interval_seconds = wait_interval_seconds * 2\n\ndef get_stack_status(stack_arn):\n    \"\"\"Get the status of the CloudFormation stack with ARN `stack_arn`\"\"\"\n    cloudformation = boto3.client('cloudformation', config=boto_config)\n    response = cloudformation.describe_stacks(StackName=stack_arn)\n    return response['Stacks'][0]['StackStatus']\n\ndef wait_seconds(seconds):\n    \"\"\"Wait for `seconds` seconds\"\"\"\n    sleep(seconds)\n\ndef assert_stack_configured(stack_arn, topic_arn):\n    \"\"\"\n    Verify that the CloudFormation stack with ARN `stack_arn` is configured to update the SQS topic\n    with ARN `topic_arn`\n    \"\"\"\n    cloudformation = boto3.resource('cloudformation', config=boto_config)\n    stack = cloudformation.Stack(stack_arn)\n    wait_interval_seconds = 10\n    timeout_seconds = 300\n    start = time()\n    while stack.notification_arns != [topic_arn]:\n        if time() - start > timeout_seconds:\n            raise StackConfigurationFailedException(\n                'Timed out waiting for stack configuration to take effect')\n        wait_seconds(wait_interval_seconds)\n        wait_interval_seconds = wait_interval_seconds * 2\n        stack.reload()\n    return { 'NotificationARNs': stack.notification_arns }\n\nclass StackConfigurationFailedException(Exception):\n    \"\"\"An error occurred updating the CloudFormation stack to notify the SQS topic\"\"\""
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "StringMap"
        }
       ],
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-ConfigureSNSTopicForStack",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR ConfigureSNSTopicForStack"
   }
  },
  "ASRConfigureS3BucketPublicAccessBlock": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - AWSConfigRemediation-ConfigureS3BucketPublicAccessBlock\n\n## What does this document do?\nThis document is used to create or modify the PublicAccessBlock configuration for an Amazon S3 bucket.\n\n## Input Parameters\n* BucketName: (Required) Name of the S3 bucket (not the ARN).\n* RestrictPublicBuckets: (Optional) Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.\n  * Default: \"true\"\n* BlockPublicAcls: (Optional) Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket.\n  * Default: \"true\"\n* IgnorePublicAcls: (Optional) Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.\n  * Default: \"true\"\n* BlockPublicPolicy: (Optional) Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.\n  * Default: \"true\"\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* GetBucketPublicAccessBlock.Output - JSON formatted response from the GetPublicAccessBlock API call\n\n## Note: this is a local copy of the AWS-owned document to enable support in aws-cn and aws-us-gov partitions.\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "GetBucketPublicAccessBlock.Output"
     ],
     "parameters": {
      "BucketName": {
       "type": "String",
       "description": "(Required) The bucket name (not the ARN).",
       "allowedPattern": "(?=^.{3,63}$)(?!^(\\d+\\.)+\\d+$)(^(([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\-]*[a-z0-9])$)"
      },
      "RestrictPublicBuckets": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.",
       "default": true,
       "allowedValues": [
        true,
        false
       ]
      },
      "BlockPublicAcls": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket.",
       "default": true,
       "allowedValues": [
        true,
        false
       ]
      },
      "IgnorePublicAcls": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.",
       "default": true,
       "allowedValues": [
        true,
        false
       ]
      },
      "BlockPublicPolicy": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.",
       "default": true,
       "allowedValues": [
        true,
        false
       ]
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "PutBucketPublicAccessBlock",
       "action": "aws:executeAwsApi",
       "description": "## PutBucketPublicAccessBlock\nCreates or modifies the PublicAccessBlock configuration for a S3 Bucket.\n",
       "isEnd": false,
       "inputs": {
        "Service": "s3",
        "Api": "PutPublicAccessBlock",
        "Bucket": "{{BucketName}}",
        "PublicAccessBlockConfiguration": {
         "RestrictPublicBuckets": "{{ RestrictPublicBuckets }}",
         "BlockPublicAcls": "{{ BlockPublicAcls }}",
         "IgnorePublicAcls": "{{ IgnorePublicAcls }}",
         "BlockPublicPolicy": "{{ BlockPublicPolicy }}"
        }
       },
       "isCritical": true,
       "maxAttempts": 2,
       "timeoutSeconds": 600
      },
      {
       "name": "GetBucketPublicAccessBlock",
       "action": "aws:executeScript",
       "description": "## GetBucketPublicAccessBlock\nRetrieves the S3 PublicAccessBlock configuration for a S3 Bucket.\n## Outputs\n* Output: JSON formatted response from the GetPublicAccessBlock API call.\n",
       "timeoutSeconds": 600,
       "isCritical": true,
       "isEnd": true,
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "validate_s3_bucket_publicaccessblock",
        "InputPayload": {
         "Bucket": "{{BucketName}}",
         "RestrictPublicBuckets": "{{ RestrictPublicBuckets }}",
         "BlockPublicAcls": "{{ BlockPublicAcls }}",
         "IgnorePublicAcls": "{{ IgnorePublicAcls }}",
         "BlockPublicPolicy": "{{ BlockPublicPolicy }}"
        },
        "Script": "import boto3\n\ndef validate_s3_bucket_publicaccessblock(event, context):\n  s3_client = boto3.client(\"s3\")\n  bucket = event[\"Bucket\"]\n  restrict_public_buckets = event[\"RestrictPublicBuckets\"]\n  block_public_acls = event[\"BlockPublicAcls\"]\n  ignore_public_acls = event[\"IgnorePublicAcls\"]\n  block_public_policy = event[\"BlockPublicPolicy\"]\n\n  output = s3_client.get_public_access_block(Bucket=bucket)\n  updated_block_acl = output[\"PublicAccessBlockConfiguration\"][\"BlockPublicAcls\"]\n  updated_ignore_acl = output[\"PublicAccessBlockConfiguration\"][\"IgnorePublicAcls\"]\n  updated_block_policy = output[\"PublicAccessBlockConfiguration\"][\"BlockPublicPolicy\"]\n  updated_restrict_buckets = output[\"PublicAccessBlockConfiguration\"][\"RestrictPublicBuckets\"]\n\n  if updated_block_acl == block_public_acls and updated_ignore_acl == ignore_public_acls \\\n  and updated_block_policy == block_public_policy and updated_restrict_buckets == restrict_public_buckets:\n    return {\n      \"output\":\n        {\n          \"message\": \"Bucket public access block configuration successfully set.\",\n          \"configuration\": output[\"PublicAccessBlockConfiguration\"]\n        }\n    }\n  else:\n      info = \"CONFIGURATION VALUES DO NOT MATCH WITH PARAMETERS PROVIDED VALUES RestrictPublicBuckets: {}, BlockPublicAcls: {}, IgnorePublicAcls: {}, BlockPublicPolicy: {}\".format(\n                restrict_public_buckets,\n                block_public_acls,\n                ignore_public_acls,\n                block_public_policy\n              )\n      raise Exception(info)"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-ConfigureS3BucketPublicAccessBlock",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR ConfigureS3BucketPublicAccessBlock"
   }
  },
  "ASRConfigureS3PublicAccessBlock": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - AWSConfigRemediation-ConfigureS3PublicAccessBlock\n\n## What does this document do?\nThis document is used to create or modify the S3 [PublicAccessBlock](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-options) configuration for an AWS account.\n\n## Input Parameters\n* AccountId: (Required) Account ID of the account for which the S3 Account Public Access Block is to be configured.\n* RestrictPublicBuckets: (Optional) Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only AWS services and authorized users within this account.\n  * Default: \"true\"\n* BlockPublicAcls: (Optional) Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account.\n  * Default: \"true\"\n* IgnorePublicAcls: (Optional) Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain.\n  * Default: \"true\"\n* BlockPublicPolicy: (Optional) Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.\n  * Default: \"true\"\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* GetPublicAccessBlock.Output - JSON formatted response from the GetPublicAccessBlock API call.\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AccountId": {
       "type": "String",
       "description": "(Required) The account ID for the AWS account whose PublicAccessBlock configuration you want to set.",
       "allowedPattern": "^\\d{12}$"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RestrictPublicBuckets": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only AWS services and authorized users within this account.",
       "default": true
      },
      "BlockPublicAcls": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account.",
       "default": true
      },
      "IgnorePublicAcls": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain.",
       "default": true
      },
      "BlockPublicPolicy": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.",
       "default": true
      }
     },
     "outputs": [
      "GetPublicAccessBlock.Output"
     ],
     "mainSteps": [
      {
       "name": "PutAccountPublicAccessBlock",
       "action": "aws:executeAwsApi",
       "description": "## PutAccountPublicAccessBlock\nCreates or modifies the S3 PublicAccessBlock configuration for an AWS account.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "s3control",
        "Api": "PutPublicAccessBlock",
        "AccountId": "{{ AccountId }}",
        "PublicAccessBlockConfiguration": {
         "RestrictPublicBuckets": "{{ RestrictPublicBuckets }}",
         "BlockPublicAcls": "{{ BlockPublicAcls }}",
         "IgnorePublicAcls": "{{ IgnorePublicAcls }}",
         "BlockPublicPolicy": "{{ BlockPublicPolicy }}"
        }
       },
       "outputs": [
        {
         "Name": "PutAccountPublicAccessBlockResponse",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "GetPublicAccessBlock",
       "action": "aws:executeScript",
       "description": "## GetPublicAccessBlock\nRetrieves the S3 PublicAccessBlock configuration for an AWS account.\n## Outputs\n* Output: JSON formatted response from the GetPublicAccessBlock API call.\n",
       "timeoutSeconds": 600,
       "isEnd": true,
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "handler",
        "InputPayload": {
         "AccountId": "{{ AccountId }}",
         "RestrictPublicBuckets": "{{ RestrictPublicBuckets }}",
         "BlockPublicAcls": "{{ BlockPublicAcls }}",
         "IgnorePublicAcls": "{{ IgnorePublicAcls }}",
         "BlockPublicPolicy": "{{ BlockPublicPolicy }}"
        },
        "Script": "import boto3\nfrom time import sleep\n\ndef verify_s3_public_access_block(account_id, restrict_public_buckets, block_public_acls, ignore_public_acls, block_public_policy):\n   s3control_client = boto3.client('s3control')\n   wait_time = 30\n   max_time = 480\n   retry_count = 1\n   max_retries = max_time/wait_time\n   while retry_count <= max_retries:\n       sleep(wait_time)\n       retry_count = retry_count + 1\n       get_public_access_response = s3control_client.get_public_access_block(AccountId=account_id)\n       updated_block_acl = get_public_access_response['PublicAccessBlockConfiguration']['BlockPublicAcls']\n       updated_ignore_acl = get_public_access_response['PublicAccessBlockConfiguration']['IgnorePublicAcls']\n       updated_block_policy = get_public_access_response['PublicAccessBlockConfiguration']['BlockPublicPolicy']\n       updated_restrict_buckets = get_public_access_response['PublicAccessBlockConfiguration']['RestrictPublicBuckets']\n       if updated_block_acl == block_public_acls and updated_ignore_acl == ignore_public_acls \\\n                 and updated_block_policy == block_public_policy and updated_restrict_buckets == restrict_public_buckets:\n                   return {\n                       \"output\": {\n                           \"message\": \"Verification successful. S3 Public Access Block Updated.\",\n                           \"HTTPResponse\": get_public_access_response[\"PublicAccessBlockConfiguration\"]\n                       },\n                   }\n   raise Exception(\n         \"VERFICATION FAILED. S3 GetPublicAccessBlock CONFIGURATION VALUES \"\n         \"DO NOT MATCH WITH PARAMETERS PROVIDED VALUES \"\n         \"RestrictPublicBuckets: {}, BlockPublicAcls: {}, IgnorePublicAcls: {}, BlockPublicPolicy: {}\"\n         .format(updated_restrict_buckets, updated_block_acl, updated_ignore_acl, updated_block_policy)\n   )\n\ndef handler(event, context):\n  account_id = event[\"AccountId\"]\n  restrict_public_buckets = event[\"RestrictPublicBuckets\"]\n  block_public_acls = event[\"BlockPublicAcls\"]\n  ignore_public_acls = event[\"IgnorePublicAcls\"]\n  block_public_policy = event[\"BlockPublicPolicy\"]\n  return verify_s3_public_access_block(account_id, restrict_public_buckets, block_public_acls, ignore_public_acls, block_public_policy)"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-ConfigureS3PublicAccessBlock",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR ConfigureS3PublicAccessBlock"
   }
  },
  "ASREnableCloudTrailLogFileValidation": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - AWSConfigRemediation-EnableCloudTrailLogFileValidation\n\n## What does this document do?\nThis runbook enables log file validation for your AWS CloudTrail trail using the [UpdateTrail](https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_UpdateTrail.html) API.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n* TrailName: (Required) The name or Amazon Resource Name (ARN) of the trail you want to enable log file validation for.\n\n## Output Parameters\n* UpdateTrail.Output: The response of the UpdateTrail API call.\n\n## Note: this is a local copy of the AWS-owned document to enable support in aws-cn and aws-us-gov partitions.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "TrailName": {
       "type": "String",
       "description": "(Required) The name or Amazon Resource Name (ARN) of the trail you want to enable log file validation for.",
       "allowedPattern": "(^arn:(aws[a-zA-Z-]*)?:cloudtrail:[a-z0-9-]+:\\d{12}:trail\\/(?![-_.])(?!.*[-_.]{2})(?!.*[-_.]$)(?!^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$)[-\\w.]{3,128}$)|(^(?![-_.])(?!.*[-_.]{2})(?!.*[-_.]$)(?!^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$)[-\\w.]{3,128}$)"
      }
     },
     "outputs": [
      "UpdateTrail.Output"
     ],
     "mainSteps": [
      {
       "name": "UpdateTrail",
       "action": "aws:executeAwsApi",
       "description": "## UpdateTrail\nEnables log file validation for the AWS CloudTrail trail you specify in the TrailName parameter.\n## Outputs\n* Output: Response from the UpdateTrail API call.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "cloudtrail",
        "Api": "UpdateTrail",
        "Name": "{{ TrailName }}",
        "EnableLogFileValidation": true
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyTrail",
       "action": "aws:assertAwsResourceProperty",
       "description": "## VerifyTrail\nVerifies log file validation is enabled for your trail.\n",
       "timeoutSeconds": 600,
       "isEnd": true,
       "inputs": {
        "Service": "cloudtrail",
        "Api": "GetTrail",
        "Name": "{{ TrailName }}",
        "PropertySelector": "$.Trail.LogFileValidationEnabled",
        "DesiredValues": [
         "True"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableCloudTrailLogFileValidation",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableCloudTrailLogFileValidation"
   }
  },
  "ASREnableEbsEncryptionByDefault": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - AWSConfigRemediation-EnableEbsEncryptionByDefault\n\n## What does this document do?\nThis document enables EBS encryption by default for an AWS account in the current region using the [EnableEbsEncryptionByDefault](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EnableEbsEncryptionByDefault.html) API.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* ModifyAccount.EnableEbsEncryptionByDefaultResponse: JSON formatted response from the EnableEbsEncryptionByDefault API.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "ModifyAccount.EnableEbsEncryptionByDefaultResponse"
     ],
     "mainSteps": [
      {
       "name": "ModifyAccount",
       "action": "aws:executeAwsApi",
       "description": "## ModifyAccount\nEnables EBS encryption by default for the account in the current region.\n## Outputs\n* EnableEbsEncryptionByDefaultResponse: Response from the EnableEbsEncryptionByDefault API.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "ec2",
        "Api": "EnableEbsEncryptionByDefault"
       },
       "outputs": [
        {
         "Name": "EnableEbsEncryptionByDefaultResponse",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyEbsEncryptionByDefault",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## VerifyEbsEncryptionByDefault\nChecks if EbsEncryptionByDefault is enabled correctly from the previous step.\n",
       "inputs": {
        "Service": "ec2",
        "Api": "GetEbsEncryptionByDefault",
        "PropertySelector": "$.EbsEncryptionByDefault",
        "DesiredValues": [
         "True"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableEbsEncryptionByDefault",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableEbsEncryptionByDefault"
   }
  },
  "ASREnableEnhancedMonitoringOnRDSInstance": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - AWSConfigRemediation-EnableEnhancedMonitoringOnRDSInstance\n\n## What does this document do?\nThis document is used to enable enhanced monitoring on an RDS Instance using the input parameter DB Instance resourceId.\n\n## Input Parameters\n* ResourceId: (Required) Resource ID of the RDS DB Instance.\n* MonitoringInterval: (Optional)\n   * The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.\n   * If MonitoringRoleArn is specified, then you must also set MonitoringInterval to a value other than 0.\n   * Valid Values: 1, 5, 10, 15, 30, 60\n   * Default: 60\n* MonitoringRoleArn: (Required) The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs.\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* EnableEnhancedMonitoring.DbInstance - The standard HTTP response from the ModifyDBInstance API.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "ResourceId": {
       "type": "String",
       "description": "(Required) Resource ID of the Amazon RDS instance for which Enhanced Monitoring needs to be enabled.",
       "allowedPattern": "db-[A-Z0-9]{26}"
      },
      "MonitoringInterval": {
       "type": "Integer",
       "description": "(Optional) The interval, in seconds, between points when Enhanced Monitoring metrics are collected for the DB instance.",
       "default": 60,
       "allowedValues": [
        1,
        5,
        10,
        15,
        30,
        60
       ]
      },
      "MonitoringRoleArn": {
       "type": "String",
       "description": "(Required) The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs.",
       "allowedPattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/[a-zA-Z0-9+=,.@_/-]+$"
      }
     },
     "outputs": [
      "EnableEnhancedMonitoring.DbInstance"
     ],
     "mainSteps": [
      {
       "name": "DescribeDBInstances",
       "action": "aws:executeAwsApi",
       "description": "## DescribeDBInstances\n  Makes describeDBInstances API call using RDS Instance DbiResourceId to get DBInstanceId.\n## Outputs\n* DbInstanceIdentifier: DBInstance Identifier of the RDS Instance.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "Filters": [
         {
          "Name": "dbi-resource-id",
          "Values": [
           "{{ ResourceId }}"
          ]
         }
        ]
       },
       "outputs": [
        {
         "Name": "DbInstanceIdentifier",
         "Selector": "$.DBInstances[0].DBInstanceIdentifier",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyDBInstanceStatus",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": false,
       "description": "## VerifyDBInstanceStatus\nVerifies if DB Instance status is available before enabling enhanced monitoring.\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "DBInstanceIdentifier": "{{ DescribeDBInstances.DbInstanceIdentifier }}",
        "PropertySelector": "$.DBInstances[0].DBInstanceStatus",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "EnableEnhancedMonitoring",
       "action": "aws:executeAwsApi",
       "description": "## EnableEnhancedMonitoring\n  Makes ModifyDBInstance API call to enable Enhanced Monitoring on the RDS Instance\n  using the DBInstanceId from the previous action.\n## Outputs\n  * DbInstance: The standard HTTP response from the ModifyDBInstance API.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "ModifyDBInstance",
        "ApplyImmediately": false,
        "DBInstanceIdentifier": "{{ DescribeDBInstances.DbInstanceIdentifier }}",
        "MonitoringInterval": "{{ MonitoringInterval }}",
        "MonitoringRoleArn": "{{ MonitoringRoleArn }}"
       },
       "outputs": [
        {
         "Name": "DbInstance",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyEnhancedMonitoringEnabled",
       "action": "aws:executeScript",
       "description": "## VerifyEnhancedMonitoringEnabled\nChecks that the enhanced monitoring is enabled on RDS Instance in the previous step exists.\n## Outputs\n* Output: The standard HTTP response from the ModifyDBInstance API.\n",
       "isEnd": true,
       "timeoutSeconds": 600,
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "handler",
        "InputPayload": {
         "MonitoringInterval": "{{ MonitoringInterval }}",
         "DBIdentifier": "{{ DescribeDBInstances.DbInstanceIdentifier }}"
        },
        "Script": "import boto3\nimport time\n\ndef handler(event, context):\n    rds_client = boto3.client(\"rds\")\n    db_instance_id = event[\"DBIdentifier\"]\n    monitoring_interval = event[\"MonitoringInterval\"]\n\n    try:\n        rds_waiter = rds_client.get_waiter(\"db_instance_available\")\n        rds_waiter.wait(DBInstanceIdentifier=db_instance_id)\n\n        db_instances = rds_client.describe_db_instances(\n            DBInstanceIdentifier=db_instance_id)\n\n        for db_instance in db_instances.get(\"DBInstances\", [{}]):\n            db_monitoring_interval = db_instance.get(\"MonitoringInterval\")\n\n        if db_monitoring_interval == monitoring_interval:\n            return {\n                      \"output\": db_instances[\"ResponseMetadata\"]\n                    }\n        else:\n            info = \"VERIFICATION FAILED. RDS INSTANCE MONITORING INTERVAL {} IS NOT ENABLED WITH THE REQUIRED VALUE {}\".format(\n                    db_monitoring_interval, monitoring_interval)\n            raise Exception(info)\n    except Exception as e:\n        raise e"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableEnhancedMonitoringOnRDSInstance",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableEnhancedMonitoringOnRDSInstance"
   }
  },
  "ASREnableKeyRotation": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - AWSConfigRemediation-EnableKeyRotation\n\n## What does this document do?\nThis document enables automatic key rotation for the given AWS Key Management Service (KMS) symmetric customer master key(CMK) using [EnableKeyRotation](https://docs.aws.amazon.com/kms/latest/APIReference/API_EnableKeyRotation.html) API.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* KeyId: (Required) The Key ID of the AWS KMS symmetric CMK.\n\n## Output Parameters\n* EnableKeyRotation.EnableKeyRotationResponse: The standard HTTP response from the EnableKeyRotation API.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "KeyId": {
       "type": "String",
       "description": "(Required) The Key ID of the AWS KMS symmetric CMK.",
       "allowedPattern": "[a-z0-9-]{1,2048}"
      }
     },
     "outputs": [
      "EnableKeyRotation.EnableKeyRotationResponse"
     ],
     "mainSteps": [
      {
       "name": "EnableKeyRotation",
       "action": "aws:executeAwsApi",
       "description": "## EnableKeyRotation\nEnables automatic key rotation for the given AWS KMS CMK.\n## Outputs\n* EnableKeyRotationResponse: The standard HTTP response from the EnableKeyRotation API.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "kms",
        "Api": "EnableKeyRotation",
        "KeyId": "{{ KeyId }}"
       },
       "outputs": [
        {
         "Name": "EnableKeyRotationResponse",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyKeyRotation",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## VerifyKeyRotation\nVerifies that the KeyRotationEnabled is set to true for the given AWS KMS CMK.\n",
       "inputs": {
        "Service": "kms",
        "Api": "GetKeyRotationStatus",
        "KeyId": "{{ KeyId }}",
        "PropertySelector": "$.KeyRotationEnabled",
        "DesiredValues": [
         "True"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableKeyRotation",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableKeyRotation"
   }
  },
  "ASREnableRDSClusterDeletionProtection": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - AWSConfigRemediation-EnableRDSClusterDeletionProtection\n\n## What does this document do?\nThis document enables `Deletion Protection` on a given Amazon RDS cluster using the [ModifyDBCluster](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBCluster.html) API.\nPlease note, AWS Config is required to be enabled in this region for this document to work as it requires the resource ID recorded by the AWS Config service.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* ClusterId: (Required) Resource ID of the Amazon RDS cluster.\n\n## Output Parameters\n* EnableRDSClusterDeletionProtection.ModifyDBClusterResponse: The standard HTTP response from the ModifyDBCluster API.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "ClusterId": {
       "type": "String",
       "description": "(Required) Amazon RDS cluster resourceId for which deletion protection needs to be enabled.",
       "allowedPattern": "^[a-zA-Z0-9-]{1,35}$"
      }
     },
     "outputs": [
      "EnableRDSClusterDeletionProtection.ModifyDBClusterResponse"
     ],
     "mainSteps": [
      {
       "name": "GetRDSClusterIdentifer",
       "action": "aws:executeAwsApi",
       "description": "## GetRDSClusterIdentifer\nAccepts the resource ID of the Amazon RDS Cluster as input and returns the cluster name.\n## Outputs\n* DbClusterIdentifier: The ID of the DB cluster for which the input parameter matches DbClusterResourceId element from the output of the DescribeDBClusters API call.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "config",
        "Api": "GetResourceConfigHistory",
        "resourceId": "{{ ClusterId }}",
        "resourceType": "AWS::RDS::DBCluster",
        "limit": 1
       },
       "outputs": [
        {
         "Name": "DbClusterIdentifier",
         "Selector": "$.configurationItems[0].resourceName",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyDBClusterStatus",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": false,
       "description": "## VerifyDBClusterStatus\nVerifies if the DB Cluster status is available before enabling cluster deletion protection.\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBClusters",
        "DBClusterIdentifier": "{{ GetRDSClusterIdentifer.DbClusterIdentifier }}",
        "PropertySelector": "$.DBClusters[0].Status",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "EnableRDSClusterDeletionProtection",
       "action": "aws:executeAwsApi",
       "description": "## EnableRDSClusterDeletionProtection\nEnables deletion protection on the Amazon RDS Cluster.\n## Outputs\n* ModifyDBClusterResponse: The standard HTTP response from the ModifyDBCluster API.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "ModifyDBCluster",
        "DBClusterIdentifier": "{{ GetRDSClusterIdentifer.DbClusterIdentifier }}",
        "DeletionProtection": true
       },
       "outputs": [
        {
         "Name": "ModifyDBClusterResponse",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyDBClusterModification",
       "action": "aws:assertAwsResourceProperty",
       "description": "## VerifyDBClusterModification\nVerifies that deletion protection has been enabled for the given Amazon RDS database cluster.\n",
       "timeoutSeconds": 600,
       "isEnd": true,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBClusters",
        "DBClusterIdentifier": "{{ GetRDSClusterIdentifer.DbClusterIdentifier }}",
        "PropertySelector": "$.DBClusters[0].DeletionProtection",
        "DesiredValues": [
         "True"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableRDSClusterDeletionProtection",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableRDSClusterDeletionProtection"
   }
  },
  "ASREnableCopyTagsToSnapshotOnRDSCluster": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - AWSConfigRemediation-EnableCopyTagsToSnapshotOnRDSCluster\n\n## What does this document do?\nThe document enables CopyTagsToSnapshot on an Amazon RDS cluster using the [ModifyDBCluster API](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBCluster.html).  Please note, AWS Config is required to be enabled in this region for this document to work as it requires the Resource ID recorded by the AWS Config service.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* DbClusterResourceId: (Required) Resource ID of the Amazon RDS Cluster for which CopyTagsToSnapshot needs to be enabled.\n* ApplyImmediately: (Optional) A value that indicates whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB instance. By default, this parameter is disabled.\n  * Default: false\n\n## Output Parameters\n* ModifyDBClusterResponse.Output: The response of the ModifyDBCluster API call.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "DbClusterResourceId": {
       "type": "String",
       "description": "(Required) Resource ID of the Amazon RDS Cluster for which CopyTagsToSnapshot needs to be enabled.",
       "allowedPattern": "^cluster-[A-Z0-9]+$"
      },
      "ApplyImmediately": {
       "type": "Boolean",
       "description": "(Optional) A value that indicates whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB instance.  By default, this parameter is disabled.",
       "default": false
      }
     },
     "outputs": [
      "EnableCopyTagsToSnapshot.Output"
     ],
     "mainSteps": [
      {
       "name": "GetDBClusterIdentifier",
       "action": "aws:executeAwsApi",
       "description": "## GetDBClusterIdentifier\nAccepts the Resource ID as input and returns the DB cluster identifier.\n## Outputs\n* DBClusterIdentifier: The ID of the DB cluster.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "config",
        "Api": "GetResourceConfigHistory",
        "resourceId": "{{ DbClusterResourceId }}",
        "resourceType": "AWS::RDS::DBCluster"
       },
       "outputs": [
        {
         "Name": "DBClusterIdentifier",
         "Selector": "$.configurationItems[0].resourceName",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyStatus",
       "action": "aws:assertAwsResourceProperty",
       "description": "## VerifyStatus\nVerifies if `Status` is available before proeeding to the next step.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBClusters",
        "DBClusterIdentifier": "{{ GetDBClusterIdentifier.DBClusterIdentifier }}",
        "PropertySelector": "$.DBClusters[0].Status",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "EnableCopyTagsToSnapshot",
       "action": "aws:executeAwsApi",
       "description": "## EnableCopyTagsToSnapshot\nAccepts the cluster name as input and modifies it to set true for `CopyTagsToSnapshot`.\n## Outputs\n* Output: Response from the ModifyDBCluster API call.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "ModifyDBCluster",
        "DBClusterIdentifier": "{{ GetDBClusterIdentifier.DBClusterIdentifier }}",
        "ApplyImmediately": "{{ ApplyImmediately }}",
        "CopyTagsToSnapshot": true
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyDBClusterCopyTagsToSnapshotEnabled",
       "action": "aws:assertAwsResourceProperty",
       "description": "## VerifyDBClusterCopyTagsToSnapshotEnabled\nVerifies that `CopyTagsToSnapshot` has been enabled on the target resource.\n## Outputs\n* Output: A success message or failure exception.\n",
       "timeoutSeconds": 600,
       "isEnd": true,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBClusters",
        "DBClusterIdentifier": "{{ GetDBClusterIdentifier.DBClusterIdentifier }}",
        "PropertySelector": "$.DBClusters[0].CopyTagsToSnapshot",
        "DesiredValues": [
         "True"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableCopyTagsToSnapshotOnRDSCluster",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableCopyTagsToSnapshotOnRDSCluster"
   }
  },
  "ASREnableRDSInstanceDeletionProtection": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-EnableRDSInstanceDeletionProtection\n\n## What does this document do?\nThis document enables `Deletion Protection` on a given Amazon RDS instance using the [ModifyDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBInstance.html) API.\n\n## Input Parameters\n* ApplyImmediately: (Optional) A value that indicates whether the modifications in this request and any pending modifications\n  are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB instance.\n  * Default: \"false\"\n* DbInstanceResourceId: (Required) Amazon RDS Instance resourceId for which deletion protection needs to be enabled.\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* EnableRDSInstanceDeletionProtection.ModifyDBInstanceResponse - The standard HTTP response from the ModifyDBInstance API.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "ApplyImmediately": {
       "type": "Boolean",
       "description": "(Optional) A value that indicates whether the modifications in this request and any pending modifications are asynchronously applied as soon as possible, regardless of the PreferredMaintenanceWindow setting for the DB instance.",
       "default": false
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "DbInstanceResourceId": {
       "type": "String",
       "description": "(Required) Resource ID of the Amazon RDS instance for which deletion protection needs to be enabled.",
       "allowedPattern": "^db-[A-Z0-9]{26}$"
      }
     },
     "outputs": [
      "EnableRDSInstanceDeletionProtection.ModifyDBInstanceResponse"
     ],
     "mainSteps": [
      {
       "name": "GetRDSInstanceIdentifier",
       "action": "aws:executeAwsApi",
       "description": "## GetRDSInstanceIdentifier\nMakes DescribeDBInstances API call using Amazon RDS Instance DbiResourceId to get DBInstance Identifier.\n## Outputs\n* DbInstanceIdentifier: DBInstance Identifier of the Amazon RDS Instance.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "Filters": [
         {
          "Name": "dbi-resource-id",
          "Values": [
           "{{ DbInstanceResourceId }}"
          ]
         }
        ]
       },
       "outputs": [
        {
         "Name": "DbInstanceIdentifier",
         "Selector": "$.DBInstances[0].DBInstanceIdentifier",
         "Type": "String"
        }
       ]
      },
      {
       "name": "EnableRDSInstanceDeletionProtection",
       "action": "aws:executeAwsApi",
       "description": "## EnableRDSInstanceDeletionProtection\nMakes ModifyDBInstance API call to enable deletion protection on the Amazon RDS Instance using the DBInstanceId from the previous action.\n## Outputs\n* DbInstance: The standard HTTP response from the ModifyDBInstance API.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "ModifyDBInstance",
        "ApplyImmediately": "{{ ApplyImmediately }}",
        "DBInstanceIdentifier": "{{ GetRDSInstanceIdentifier.DbInstanceIdentifier }}",
        "DeletionProtection": true
       },
       "outputs": [
        {
         "Name": "ModifyDBInstanceResponse",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyDBInstanceModification",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## VerifyDBInstanceModification\nChecks whether deletion protection is enabled on Amazon RDS Instance.\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "DBInstanceIdentifier": "{{ GetRDSInstanceIdentifier.DbInstanceIdentifier }}",
        "PropertySelector": "$.DBInstances[0].DeletionProtection",
        "DesiredValues": [
         "True"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableRDSInstanceDeletionProtection",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableRDSInstanceDeletionProtection"
   }
  },
  "ASREnableMultiAZOnRDSInstance": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-EnableMultiAZOnRDSInstance\n\n## What does this document do?\nThis document enables MultiAZ on an RDS instance.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* DbiResourceId: (Required) Resource ID of the RDS instance to be modified.\n* ApplyImmediately: (Optional) The MultiAZ on an RDS instance change is applied during the next maintenance window unless the ApplyImmediately parameter is enabled (true) for this request. By default, this parameter is disabled (false).\n\n## Output Parameters\n* EnableMultiAZ.DBInstance: The standard HTTP response from the ModifyDBInstance API.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "DbiResourceId": {
       "type": "String",
       "description": "(Required) Resource ID of the RDS instance for which MultiAZ needs to be enabled.",
       "allowedPattern": "^db-[A-Z0-9]{26}$"
      },
      "ApplyImmediately": {
       "type": "Boolean",
       "description": "(Optional) MultiAZ on an RDS instance change is applied during the next maintenance window unless the ApplyImmediately parameter is enabled (true) for this request. By default, this parameter is disabled (false).",
       "default": false,
       "allowedValues": [
        true,
        false
       ]
      }
     },
     "outputs": [
      "EnableMultiAZ.DBInstance"
     ],
     "mainSteps": [
      {
       "name": "DescribeDBInstances",
       "action": "aws:executeAwsApi",
       "description": "## DescribeDBInstances\nMakes DescribeDBInstances API call using RDS DB instance resource identifiers to get DBInstanceIdentifier.\n## Outputs\n* DBInstanceIdentifier: DBInstance identifier of the RDS instance.\n* MultiAZ: MultiAZ state of the RDS instance.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "Filters": [
         {
          "Name": "dbi-resource-id",
          "Values": [
           "{{ DbiResourceId }}"
          ]
         }
        ]
       },
       "outputs": [
        {
         "Name": "DBInstanceIdentifier",
         "Selector": "$.DBInstances[0].DBInstanceIdentifier",
         "Type": "String"
        },
        {
         "Name": "MultiAZ",
         "Selector": "$.DBInstances[0].MultiAZ",
         "Type": "Boolean"
        }
       ]
      },
      {
       "name": "VerifyDBInstanceStatus",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": false,
       "description": "## VerifyDBInstanceStatus\nVerifies if DB instance status is available before enabling MultiAZ.\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "DBInstanceIdentifier": "{{ DescribeDBInstances.DBInstanceIdentifier }}",
        "PropertySelector": "$.DBInstances[0].DBInstanceStatus",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "EndIfMultiAZAlreadyEnabled",
       "action": "aws:branch",
       "description": "## EndIfMultiAZAlreadyEnabled\nChecks if MultiAZ is not enabled on the DB instance. If not enabled, proceed with EnableMultiAZ step. Otherwise, end the flow.\n",
       "inputs": {
        "Choices": [
         {
          "NextStep": "EnableMultiAZ",
          "Variable": "{{ DescribeDBInstances.MultiAZ }}",
          "BooleanEquals": false
         }
        ]
       },
       "isEnd": true
      },
      {
       "name": "EnableMultiAZ",
       "action": "aws:executeAwsApi",
       "description": "## EnableMultiAZ\nMakes ModifyDBInstance API call to enable MultiAZ on the RDS instance using the DBInstanceIdentifier from the previous step and MultiAZ as true.\n## Outputs\n* DBInstance: The standard HTTP response from the ModifyDBInstance API.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "ModifyDBInstance",
        "DBInstanceIdentifier": "{{ DescribeDBInstances.DBInstanceIdentifier }}",
        "MultiAZ": true,
        "ApplyImmediately": "{{ ApplyImmediately }}"
       },
       "outputs": [
        {
         "Name": "DBInstance",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyMultiAZEnabled",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## VerifyMultiAZEnabled\nVerifies that the RDS Instance's `PendingModifiedValues.MultiAZ` value is `True`.\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "DBInstanceIdentifier": "{{ DescribeDBInstances.DBInstanceIdentifier }}",
        "PropertySelector": "$.DBInstances[0].PendingModifiedValues.MultiAZ",
        "DesiredValues": [
         "True"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableMultiAZOnRDSInstance",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableMultiAZOnRDSInstance"
   }
  },
  "ASRRemoveVPCDefaultSecurityGroupRules": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document name - AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules\n\n## What does this document do?\nThis document removes all inbound and outbound rules from the default security group in an Amazon VPC. A default security group is defined as any security group whose name is `default`. If the security group ID passed to this automation document belongs to a non-default security group, this document does not perform any changes to the AWS account.\n\n## Input Parameters\n* GroupId: (Required) The unique ID of the security group.\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* RemoveRulesAndVerify.Output - Success message or failure exception.\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "GroupId": {
       "type": "String",
       "description": "(Required) The unique ID of the security group.",
       "allowedPattern": "sg-[a-z0-9]+$"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "RemoveRulesAndVerify.Output"
     ],
     "mainSteps": [
      {
       "name": "CheckDefaultSecurityGroup",
       "action": "aws:assertAwsResourceProperty",
       "isCritical": true,
       "onFailure": "Abort",
       "maxAttempts": 3,
       "timeoutSeconds": 20,
       "description": "## CheckDefaultSecurityGroup\nVerifies that the security group name does match `default`. If the group name does match `default`, go to the next step: DescribeSecurityGroups.\n",
       "inputs": {
        "Service": "ec2",
        "Api": "DescribeSecurityGroups",
        "GroupIds": [
         "{{ GroupId }}"
        ],
        "PropertySelector": "$.SecurityGroups[0].GroupName",
        "DesiredValues": [
         "default"
        ]
       },
       "nextStep": "RemoveRulesAndVerify"
      },
      {
       "name": "RemoveRulesAndVerify",
       "action": "aws:executeScript",
       "isCritical": true,
       "onFailure": "Abort",
       "maxAttempts": 3,
       "timeoutSeconds": 180,
       "isEnd": true,
       "description": "## RemoveRulesAndVerify\nRemoves all rules from the default security group.\n## Outputs\n* Output: Success message or failure exception.\n",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "handler",
        "InputPayload": {
         "GroupId": "{{ GroupId }}"
        },
        "Script": "import boto3\nfrom botocore.exceptions import ClientError\nfrom time import sleep\n\n\nec2_client = boto3.client(\"ec2\")\n\n\ndef get_permissions(group_id):\n    default_group = ec2_client.describe_security_groups(GroupIds=[group_id]).get(\"SecurityGroups\")[0]\n    return default_group.get(\"IpPermissions\"), default_group.get(\"IpPermissionsEgress\")\n\n\ndef handler(event, context):\n    group_id = event.get(\"GroupId\")\n    ingress_permissions, egress_permissions = get_permissions(group_id)\n\n    if ingress_permissions:\n        ec2_client.revoke_security_group_ingress(GroupId=group_id, IpPermissions=ingress_permissions)\n    if egress_permissions:\n        ec2_client.revoke_security_group_egress(GroupId=group_id, IpPermissions=egress_permissions)\n\n    ingress_permissions, egress_permissions = get_permissions(group_id)\n    if ingress_permissions or egress_permissions:\n        raise Exception(f\"VERIFICATION FAILED. SECURITY GROUP {group_id} NOT CLOSED.\")\n\n    return {\n        \"output\": \"Security group closed successfully.\"\n    }"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "String"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-RemoveVPCDefaultSecurityGroupRules",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR RemoveVPCDefaultSecurityGroupRules"
   }
  },
  "ASRRevokeUnusedIAMUserCredentials": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - AWSConfigRemediation-RevokeUnusedIAMUserCredentials\n\n## What does this document do?\nThis document revokes unused IAM passwords and active access keys. This document will deactivate expired access keys by using the [UpdateAccessKey API](https://docs.aws.amazon.com/IAM/latest/APIReference/API_UpdateAccessKey.html) and delete expired login profiles by using the [DeleteLoginProfile API](https://docs.aws.amazon.com/IAM/latest/APIReference/API_DeleteLoginProfile.html). Please note, this automation document requires AWS Config to be enabled.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* IAMResourceId: (Required) IAM resource unique identifier.\n* MaxCredentialUsageAge: (Required) Maximum number of days within which a credential must be used. The default value is 90 days.\n\n## Output Parameters\n* RevokeUnusedIAMUserCredentialsAndVerify.Output - Success message or failure Exception.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "IAMResourceId": {
       "type": "String",
       "description": "(Required) IAM resource unique identifier.",
       "allowedPattern": "^[\\w+=,.@_-]{1,128}$"
      },
      "MaxCredentialUsageAge": {
       "type": "String",
       "description": "(Required) Maximum number of days within which a credential must be used. The default value is 90 days.",
       "allowedPattern": "^(\\b([0-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|10000)\\b)$",
       "default": "90"
      }
     },
     "outputs": [
      "RevokeUnusedIAMUserCredentialsAndVerify.Output"
     ],
     "mainSteps": [
      {
       "name": "RevokeUnusedIAMUserCredentialsAndVerify",
       "action": "aws:executeScript",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## RevokeUnusedIAMUserCredentialsAndVerify\nThis step deactivates expired IAM User access keys, deletes expired login profiles and verifies credentials were revoked\n## Outputs\n* Output: Success message or failure Exception.\n",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "unused_iam_credentials_handler",
        "InputPayload": {
         "IAMResourceId": "{{ IAMResourceId }}",
         "MaxCredentialUsageAge": "{{ MaxCredentialUsageAge }}"
        },
        "Script": "import boto3\nfrom datetime import datetime\nfrom datetime import timedelta\n\niam_client = boto3.client(\"iam\")\nconfig_client = boto3.client(\"config\")\n\nresponses = {}\nresponses[\"DeactivateUnusedKeysResponse\"] = []\n\ndef list_access_keys(user_name):\n  return iam_client.list_access_keys(UserName=user_name).get(\"AccessKeyMetadata\")\n\ndef deactivate_key(user_name, access_key):\n  responses[\"DeactivateUnusedKeysResponse\"].append({\"AccessKeyId\": access_key, \"Response\": iam_client.update_access_key(UserName=user_name, AccessKeyId=access_key, Status=\"Inactive\")})\n\ndef deactivate_unused_keys(access_keys, max_credential_usage_age, user_name):\n  for key in access_keys:\n    last_used = iam_client.get_access_key_last_used(AccessKeyId=key.get(\"AccessKeyId\")).get(\"AccessKeyLastUsed\")\n    if last_used.get(\"LastUsedDate\"):\n      last_used_date = last_used.get(\"LastUsedDate\").replace(tzinfo=None)\n      last_used_days = (datetime.now() - last_used_date).days\n      if last_used_days >= max_credential_usage_age:\n        deactivate_key(user_name, key.get(\"AccessKeyId\"))\n    else:\n      create_date = key.get(\"CreateDate\").replace(tzinfo=None)\n      days_since_creation = (datetime.now() - create_date).days\n      if days_since_creation >= max_credential_usage_age:\n        deactivate_key(user_name, key.get(\"AccessKeyId\"))\n\ndef get_login_profile(user_name):\n  try:\n    return iam_client.get_login_profile(UserName=user_name)[\"LoginProfile\"]\n  except iam_client.exceptions.NoSuchEntityException:\n    return False\n\ndef delete_unused_password(user_name, max_credential_usage_age):\n  user = iam_client.get_user(UserName=user_name).get(\"User\")\n  password_last_used_days = 0\n  login_profile = get_login_profile(user_name)\n  if login_profile and user.get(\"PasswordLastUsed\"):\n    password_last_used = user.get(\"PasswordLastUsed\").replace(tzinfo=None)\n    password_last_used_days = (datetime.now() - password_last_used).days\n  elif login_profile and not user.get(\"PasswordLastUsed\"):\n    password_creation_date = login_profile.get(\"CreateDate\").replace(tzinfo=None)\n    password_last_used_days = (datetime.now() - password_creation_date).days\n  if password_last_used_days >= max_credential_usage_age:\n    responses[\"DeleteUnusedPasswordResponse\"] = iam_client.delete_login_profile(UserName=user_name)\n\ndef verify_expired_credentials_revoked(responses, user_name):\n  if responses.get(\"DeactivateUnusedKeysResponse\"):\n    for key in responses.get(\"DeactivateUnusedKeysResponse\"):\n      key_data = next(filter(lambda x: x.get(\"AccessKeyId\") == key.get(\"AccessKeyId\"), list_access_keys(user_name)))\n      if key_data.get(\"Status\") != \"Inactive\":\n        error_message = \"VERIFICATION FAILED. ACCESS KEY {} NOT DEACTIVATED\".format(key_data.get(\"AccessKeyId\"))\n        raise Exception(error_message)\n  if responses.get(\"DeleteUnusedPasswordResponse\"):\n    try:\n      iam_client.get_login_profile(UserName=user_name)\n      error_message = \"VERIFICATION FAILED. IAM USER {} LOGIN PROFILE NOT DELETED\".format(user_name)\n      raise Exception(error_message)\n    except iam_client.exceptions.NoSuchEntityException:\n      pass\n  return {\n      \"output\": \"Verification of unused IAM User credentials is successful.\",\n      \"http_responses\": responses\n  }\n\ndef get_user_name(resource_id):\n  list_discovered_resources_response = config_client.list_discovered_resources(\n      resourceType='AWS::IAM::User',\n      resourceIds=[resource_id]\n  )\n  resource_name = list_discovered_resources_response.get(\"resourceIdentifiers\")[0].get(\"resourceName\")\n  return resource_name\n\ndef unused_iam_credentials_handler(event, context):\n  iam_resource_id = event.get(\"IAMResourceId\")\n  user_name = get_user_name(iam_resource_id)\n\n  max_credential_usage_age = int(event.get(\"MaxCredentialUsageAge\"))\n\n  access_keys = list_access_keys(user_name)\n  unused_keys = deactivate_unused_keys(access_keys, max_credential_usage_age, user_name)\n\n  delete_unused_password(user_name, max_credential_usage_age)\n\n  return verify_expired_credentials_revoked(responses, user_name)"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-RevokeUnusedIAMUserCredentials",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR RevokeUnusedIAMUserCredentials"
   }
  },
  "ASRSetIAMPasswordPolicy": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document name - AWSConfigRemediation-SetIAMPasswordPolicy\n\n## What does this document do?\nThis document sets the AWS Identity and Access Management (IAM) user password policy for the AWS account using the [UpdateAccountPasswordPolicy](https://docs.aws.amazon.com/IAM/latest/APIReference/API_UpdateAccountPasswordPolicy.html) API.\n\n## Input Parameters\n* AllowUsersToChangePassword: (Optional) Allows all IAM users in your account to use the AWS Management Console to change their own passwords.\n* HardExpiry: (Optional) Prevents IAM users from setting a new password after their password has expired.\n* MaxPasswordAge: (Optional) The number of days that an IAM user password is valid.\n* MinimumPasswordLength: (Optional) The minimum number of characters allowed in an IAM user password.\n* PasswordReusePrevention: (Optional) Specifies the number of previous passwords that IAM users are prevented from reusing.\n* RequireLowercaseCharacters: (Optional) Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).\n* RequireNumbers: (Optional) Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).\n* RequireSymbols: (Optional) pecifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters :! @ \\# $ % ^ * ( ) _ + - = [ ] { } | '\n* RequireUppercaseCharacters: (Optional) Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n## Output Parameters\n* UpdateAndVerifyIamUserPasswordPolicy.Output\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "AllowUsersToChangePassword": {
       "type": "Boolean",
       "description": "(Optional) Allows all IAM users in your AWS account to use the AWS Management Console to change their own passwords.",
       "default": false
      },
      "HardExpiry": {
       "type": "Boolean",
       "description": "(Optional) Prevents IAM users from setting a new password after their password has expired.",
       "default": false
      },
      "MaxPasswordAge": {
       "type": "Integer",
       "description": "(Optional) The number of days that an IAM user password is valid.",
       "allowedPattern": "^\\d{0,3}$|^10[0-8]\\d$|^109[0-5]$",
       "default": 0
      },
      "MinimumPasswordLength": {
       "type": "Integer",
       "description": "(Optional) The minimum number of characters allowed in an IAM user password.",
       "allowedPattern": "^[6-9]$|^[1-9]\\d$|^1[01]\\d$|^12[0-8]$",
       "default": 6
      },
      "PasswordReusePrevention": {
       "type": "Integer",
       "description": "(Optional) Specifies the number of previous passwords that IAM users are prevented from reusing.",
       "allowedPattern": "^\\d{0,1}$|^1\\d$|^2[0-4]$",
       "default": 0
      },
      "RequireLowercaseCharacters": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether IAM user passwords must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).",
       "default": false
      },
      "RequireNumbers": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether IAM user passwords must contain at least one numeric character (0 to 9).",
       "default": false
      },
      "RequireSymbols": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether IAM user passwords must contain at least one of the following non-alphanumeric characters :! @ \\# $ % ^ * ( ) _ + - = [ ] { } | '.",
       "default": false
      },
      "RequireUppercaseCharacters": {
       "type": "Boolean",
       "description": "(Optional) Specifies whether IAM user passwords must contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).",
       "default": false
      }
     },
     "outputs": [
      "UpdateAndVerifyIamUserPasswordPolicy.Output"
     ],
     "mainSteps": [
      {
       "name": "UpdateAndVerifyIamUserPasswordPolicy",
       "action": "aws:executeScript",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## UpdateAndVerifyIamUserPasswordPolicy\nSets or updates the AWS account password policy using input parameters using UpdateAccountPasswordPolicy API.\nVerify AWS account password policy using GetAccountPasswordPolicy API.\n## Outputs\n* Output: Success message with HTTP Response from GetAccountPasswordPolicy API call or failure exception.\n",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "update_and_verify_iam_user_password_policy",
        "InputPayload": {
         "AllowUsersToChangePassword": "{{ AllowUsersToChangePassword }}",
         "HardExpiry": "{{ HardExpiry }}",
         "MaxPasswordAge": "{{ MaxPasswordAge }}",
         "MinimumPasswordLength": "{{ MinimumPasswordLength }}",
         "PasswordReusePrevention": "{{ PasswordReusePrevention }}",
         "RequireLowercaseCharacters": "{{ RequireLowercaseCharacters }}",
         "RequireNumbers": "{{ RequireNumbers }}",
         "RequireSymbols": "{{ RequireSymbols }}",
         "RequireUppercaseCharacters": "{{ RequireUppercaseCharacters }}"
        },
        "Script": "import boto3\n\n\ndef update_and_verify_iam_user_password_policy(event, context):\n    iam_client = boto3.client('iam')\n\n    try:\n        params = dict()\n        params[\"AllowUsersToChangePassword\"] = event[\"AllowUsersToChangePassword\"]\n        if \"HardExpiry\" in event:\n            params[\"HardExpiry\"] = event[\"HardExpiry\"]\n        if event[\"MaxPasswordAge\"]:\n            params[\"MaxPasswordAge\"] = event[\"MaxPasswordAge\"]\n        if event[\"PasswordReusePrevention\"]:\n            params[\"PasswordReusePrevention\"] = event[\"PasswordReusePrevention\"]\n        params[\"MinimumPasswordLength\"] = event[\"MinimumPasswordLength\"]\n        params[\"RequireLowercaseCharacters\"] = event[\"RequireLowercaseCharacters\"]\n        params[\"RequireNumbers\"] = event[\"RequireNumbers\"]\n        params[\"RequireSymbols\"] = event[\"RequireSymbols\"]\n        params[\"RequireUppercaseCharacters\"] = event[\"RequireUppercaseCharacters\"]\n\n        update_api_response = iam_client.update_account_password_policy(**params)\n\n        # Verifies IAM Password Policy configuration for AWS account using GetAccountPasswordPolicy() api call.\n        response = iam_client.get_account_password_policy()\n        if all([response[\"PasswordPolicy\"][\"AllowUsersToChangePassword\"] == event[\"AllowUsersToChangePassword\"],\n                response[\"PasswordPolicy\"][\"MinimumPasswordLength\"] == event[\"MinimumPasswordLength\"],\n                response[\"PasswordPolicy\"][\"RequireLowercaseCharacters\"] == event[\"RequireLowercaseCharacters\"],\n                response[\"PasswordPolicy\"][\"RequireNumbers\"] == event[\"RequireNumbers\"],\n                response[\"PasswordPolicy\"][\"RequireUppercaseCharacters\"] == event[\"RequireUppercaseCharacters\"],\n                ((response[\"PasswordPolicy\"][\"HardExpiry\"] == event[\"HardExpiry\"]) if \"HardExpiry\" in event else True),\n                ((response[\"PasswordPolicy\"][\"MaxPasswordAge\"] == event[\"MaxPasswordAge\"]) if event[\"MaxPasswordAge\"] else True),\n                ((response[\"PasswordPolicy\"][\"PasswordReusePrevention\"] == event[\"PasswordReusePrevention\"]) if event[\"PasswordReusePrevention\"] else True)]):\n            return {\n                \"output\": {\n                    \"Message\": \"AWS Account Password Policy setting is SUCCESSFUL.\",\n                    \"UpdatePolicyHTTPResponse\": update_api_response,\n                    \"GetPolicyHTTPResponse\": response\n                }\n            }\n        raise Exception(\"VERIFICATION FAILED. AWS ACCOUNT PASSWORD POLICY NOT UPDATED.\")\n\n    except iam_client.exceptions.NoSuchEntityException:\n        raise Exception(\"VERIFICATION FAILED. UNABLE TO UPDATE AWS ACCOUNT PASSWORD POLICY.\")"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.output",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SetIAMPasswordPolicy",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR SetIAMPasswordPolicy"
   }
  },
  "ASRDisablePublicAccessToRDSInstance": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - AWSConfigRemediation-DisablePublicAccessToRDSInstance\n\n## What does this document do?\nThe runbook disables public accessibility for the Amazon RDS database instance you specify using\nthe [ModifyDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBInstance.html) API.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.\n* DbiResourceId: (Required) The resource identifier for the DB instance you want to disable public accessibility.\n\n## Output Parameters\n* DisablePubliclyAccessibleOnRDS.Response: The standard HTTP response from the ModifyDBInstance API.\n\n## Troubleshooting\n* ModifyDBInstance isn't supported for a DB instance in a Multi-AZ DB Cluster.\n - This remediation will not work on an instance within a MySQL or PostgreSQL Multi-AZ Cluster due to limitations with the RDS API.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "DbiResourceId": {
       "type": "String",
       "description": "(Required) The resource identifier for the DB instance you want to disable public accessibility.",
       "allowedPattern": "db-[A-Z0-9]{26}"
      }
     },
     "outputs": [
      "DisablePubliclyAccessibleOnRDS.Response"
     ],
     "mainSteps": [
      {
       "name": "GetRDSInstanceIdentifier",
       "action": "aws:executeAwsApi",
       "description": "## GetRDSInstanceIdentifier\nGathers the DB instance identifier from the DB instance resource identifier.\n## Outputs\n* DbInstanceIdentifier: The Amazon RDS DB instance identifier.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "Filters": [
         {
          "Name": "dbi-resource-id",
          "Values": [
           "{{ DbiResourceId }}"
          ]
         }
        ]
       },
       "outputs": [
        {
         "Name": "DbInstanceIdentifier",
         "Selector": "$.DBInstances[0].DBInstanceIdentifier",
         "Type": "String"
        }
       ]
      },
      {
       "name": "VerifyDBInstanceStatus",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": false,
       "description": "## VerifyDBInstanceStatus\nVerifies the DB instances is in an AVAILABLE state.\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "DBInstanceIdentifier": "{{ GetRDSInstanceIdentifier.DbInstanceIdentifier }}",
        "PropertySelector": "$.DBInstances[0].DBInstanceStatus",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "DisablePubliclyAccessibleOnRDS",
       "action": "aws:executeAwsApi",
       "description": "## DisablePubliclyAccessibleOnRDS\nDisables public accessibility on your DB instance.\n## Outputs\n* Response: The standard HTTP response from the ModifyDBInstance API.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "rds",
        "Api": "ModifyDBInstance",
        "DBInstanceIdentifier": "{{ GetRDSInstanceIdentifier.DbInstanceIdentifier }}",
        "PubliclyAccessible": false
       },
       "outputs": [
        {
         "Name": "Response",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "WaitForDBInstanceStatusToModify",
       "action": "aws:waitForAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": false,
       "description": "## WaitForDBInstanceStatusToModify\nWaits for the DB instance to change to a MODIFYING state.\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "DBInstanceIdentifier": "{{ GetRDSInstanceIdentifier.DbInstanceIdentifier }}",
        "PropertySelector": "$.DBInstances[0].DBInstanceStatus",
        "DesiredValues": [
         "modifying"
        ]
       }
      },
      {
       "name": "WaitForDBInstanceStatusToAvailableAfterModify",
       "action": "aws:waitForAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": false,
       "description": "## WaitForDBInstanceStatusToAvailableAfterModify\nWaits for the DB instance to change to an AVAILABLE state\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "DBInstanceIdentifier": "{{ GetRDSInstanceIdentifier.DbInstanceIdentifier }}",
        "PropertySelector": "$.DBInstances[0].DBInstanceStatus",
        "DesiredValues": [
         "available"
        ]
       }
      },
      {
       "name": "VerifyDBInstancePubliclyAccess",
       "action": "aws:assertAwsResourceProperty",
       "timeoutSeconds": 600,
       "isEnd": true,
       "description": "## VerifyDBInstancePubliclyAccess\nConfirms public accessibility is disabled on the DB instance.\n",
       "inputs": {
        "Service": "rds",
        "Api": "DescribeDBInstances",
        "DBInstanceIdentifier": "{{ GetRDSInstanceIdentifier.DbInstanceIdentifier }}",
        "PropertySelector": "$.DBInstances[0].PubliclyAccessible",
        "DesiredValues": [
         "False"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-DisablePublicAccessToRDSInstance",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR DisablePublicAccessToRDSInstance"
   }
  },
  "ASREnableMinorVersionUpgradeOnRDSDBInstance": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - AWSConfigRemediation-EnableMinorVersionUpgradeOnRDSDBInstance\n\n## What does this document do?\nThis document enables AutoMinorVersionUpgrade on the Amazon Relational Database Service (Amazon RDS) instance using the [ModifyDBInstance](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBInstance.html) API.\n\n## Input parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* DbiResourceId: (Required) Resource ID of the Amazon RDS instance to be modified.\n\n## Output parameters\n* ModifyDBInstance.Output: The standard HTTP response from the ModifyDBInstance API.\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "DBInstanceIdentifier": {
       "type": "String",
       "description": "(Required) Identifier of the Amazon RDS instance for which AutoMinorVersionUpgrade needs to be enabled.",
       "allowedPattern": "^(?!.*--)[a-zA-Z][a-zA-Z0-9.,$;-]{0,58}[^-]$"
      }
     },
     "outputs": [
      "ModifyDBInstance.Output"
     ],
     "mainSteps": [
      {
       "name": "ModifyDBInstance",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload.response",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "DBInstanceIdentifier": "{{DBInstanceIdentifier}}"
        },
        "Runtime": "python3.8",
        "Handler": "lambda_handler",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\n\nboto_config = Config(\n    retries = {\n            'mode': 'standard',\n            'max_attempts': 10\n        }\n    )\n\nmulti_az_cluster_engines = [\"mysql\",\"postgres\"]\n\ndef connect_to_rds():\n    return boto3.client('rds', config=boto_config)\n\ndef lambda_handler(event, _):\n    \"\"\"\n     Enable auto minor version upgrades on an instance or a Multi-AZ Cluster\n \n     `event` should have the following keys and values:\n     `DBInstanceIdentifier`: The identifier of the database instance that is to be modified.\n \n     `context` is ignored\n    \"\"\"\n    db_instance_id = event[\"DBInstanceIdentifier\"]\n\n    rds = connect_to_rds()\n\n    found_instance = rds.describe_db_instances(DBInstanceIdentifier=db_instance_id)\n\n    instance_info = found_instance['DBInstances'][0]\n\n    response = False\n\n    if (\"DBClusterIdentifier\" in instance_info.keys()):\n        if (multi_az_check(instance_info[\"DBClusterIdentifier\"])):\n            cluster_id = instance_info[\"DBClusterIdentifier\"]\n            enable_minor_version_upgrade_cluster(cluster_id)\n            response = verify_cluster_changes(cluster_id)\n        else:\n            enable_minor_version_upgrade_instance(db_instance_id)\n            response = verify_instance_changes(db_instance_id)\n    else:\n        enable_minor_version_upgrade_instance(db_instance_id)\n        response = verify_instance_changes(db_instance_id)\n        \n    if response == True:\n        return {\n            \"AutoMinorVersionUpgrade\": response\n        }\n    \n    raise RuntimeError(f'ASR Remediation failed - {db_instance_id} did not have enable auto minor version upgrades enabled.')\n\ndef multi_az_check(cluster_id):\n    \"\"\"\n    Checks to see if the cluster is Multi-AZ. Instances within clusters that match this check are not able to be modified.\n    \"\"\"  \n\n    rds = connect_to_rds()\n    try:\n        found_cluster = rds.describe_db_clusters(DBClusterIdentifier=cluster_id)\n        cluster_info = found_cluster['DBClusters'][0]\n    except Exception as e:\n        exit(f'Failed to get information about the cluster: {cluster_id}.  Error: {e}')\n\n    return ((cluster_info[\"MultiAZ\"] == True) and (cluster_info[\"Engine\"] in multi_az_cluster_engines))\n\n\ndef enable_minor_version_upgrade_cluster(cluster_id):\n    \"\"\"\n    Enables automatic minor version upgrade for a Multi-AZ Cluster.\n    \"\"\" \n\n    rds = connect_to_rds()\n    try:\n        rds.modify_db_cluster(DBClusterIdentifier=cluster_id,AutoMinorVersionUpgrade=True)\n    except Exception as e:\n        exit(f'Failed to modify the cluster: {cluster_id}. Error: {e}')\n\ndef enable_minor_version_upgrade_instance(instance_id):\n    \"\"\"\n    Enables automatic minor version upgrade for an instance.\n    \"\"\" \n\n    rds = connect_to_rds()\n    try:\n        rds.modify_db_instance(DBInstanceIdentifier=instance_id,AutoMinorVersionUpgrade=True)\n    except Exception as e:\n        exit(f'Failed to modify the instance: {instance_id}. Error: {e}')\n\ndef verify_cluster_changes(cluster_id):\n    \"\"\"\n    Verifies automatic minor version upgrade for a Multi-AZ cluster.\n    \"\"\" \n    rds = connect_to_rds()\n    try:\n        found_cluster = rds.describe_db_clusters(DBClusterIdentifier=cluster_id, MaxRecords=100)\n        cluster_info = found_cluster['DBClusters'][0]\n\n    except Exception as e:\n        exit(f'Failed to verify cluster changes: {cluster_id}. Error: {e}')\n\n    return cluster_info['AutoMinorVersionUpgrade']\n        \ndef verify_instance_changes(instance_id):\n    \"\"\"\n    Verifies automatic minor version upgrade for an instance.\n    \"\"\" \n    rds = connect_to_rds()\n    try:\n        found_instance = rds.describe_db_instances(DBInstanceIdentifier=instance_id, MaxRecords=100)\n        instance_info = found_instance['DBInstances'][0]\n    except Exception as e:\n\n        exit(f'Failed to verify instance changes: {instance_id}. Error: {e}')\n\n    return instance_info['AutoMinorVersionUpgrade'] "
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableMinorVersionUpgradeOnRDSDBInstance",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableMinorVersionUpgradeOnRDSDBInstance"
   }
  },
  "ASREnableEncryptionForSNSTopic": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-EnableEncryptionForSNSTopic\n\n## What does this document do?\n This document enables encryption on given Amazon Simple Notification Service (Amazon SNS) topic using\n [SetTopicAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetTopicAttributes.html) API.\n\n This document must only be used as a baseline to ensure that your Amazon SNS topics are encrypted with the minimum security best practice of using an AWS KMS customer managed CMK.\n Based on your data policy, Amazon SNS topic should be encrypted with different customer managed CMKs as documented [here](https://docs.aws.amazon.com/kms/latest/developerguide/best-practices.html).\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* TopicArn: (Required)  The ARN of the Amazon SNS Topic.\n* KmsKeyArn: (Required) The ARN of AWS KMS Key.\n\n ## Security Standards / Controls\n * AFSBP v1.0.0:   SNS.1\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "KmsKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for this remediation",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      },
      "TopicArn": {
       "type": "String",
       "description": "(Required) The ARN of the Amazon SNS Topic.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):sns:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:([a-zA-Z0-9_-]{1,80}(?:\\.fifo)?)$"
      }
     },
     "outputs": [
      "EncryptSNSTopic.Response"
     ],
     "mainSteps": [
      {
       "name": "EncryptSNSTopic",
       "action": "aws:executeAwsApi",
       "description": "## EncryptSNSTopic\nMakes SetTopicAttributes API call using the Amazon SNS Topic ARN to enables encyption.\n## Outputs\n* Response: The standard HTTP response from the SetTopicAttributes API call.\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "sns",
        "Api": "SetTopicAttributes",
        "TopicArn": "{{TopicArn}}",
        "AttributeName": "KmsMasterKeyId",
        "AttributeValue": "{{KmsKeyArn}}"
       },
       "outputs": [
        {
         "Name": "Response",
         "Selector": "$",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "VerifyTopicEncryption",
       "action": "aws:assertAwsResourceProperty",
       "description": "## VerifyTopicEncryption\nVerifies the given Amazon SNS Topic is encrypted with AWS KMS Key ARN.\n",
       "timeoutSeconds": 600,
       "isEnd": true,
       "inputs": {
        "Service": "sns",
        "Api": "GetTopicAttributes",
        "TopicArn": "{{TopicArn}}",
        "PropertySelector": "Attributes.KmsMasterKeyId",
        "DesiredValues": [
         "{{ KmsKeyArn }}"
        ]
       }
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableEncryptionForSNSTopic",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableEncryptionForSNSTopic"
   }
  },
  "ASREnableDeliveryStatusLoggingForSNSTopic": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-EnableDeliveryStatusLoggingForSNSTopic\n\n## What does this document do?\n This document enables delivery status logging on given Amazon Simple Notification Service (Amazon SNS) topic using\n [SetTopicAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetTopicAttributes.html) API.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* LoggingRole: (Required) The ARN of the IAM Role used to log successful and failed deliveries.\n* SNSTopicArn: (Required)  The ARN of the Amazon SNS Topic.\n\n ## Security Standards / Controls\n * AFSBP v1.0.0:   SNS.2\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "LoggingRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Delivery Status Logging.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "SNSTopicArn": {
       "type": "String",
       "description": "(Required) The ARN of the Amazon SNS Topic.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):sns:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:([a-zA-Z0-9_-]{1,80}(?:\\.fifo)?)$"
      },
      "SampleRate": {
       "type": "String",
       "default": "0",
       "allowedPattern": "^(?:[0-9]|[1-9][0-9]|100)$"
      }
     },
     "outputs": [
      "EnableDeliveryStatusLogging.Output"
     ],
     "mainSteps": [
      {
       "name": "EnableDeliveryStatusLogging",
       "action": "aws:executeScript",
       "timeoutSeconds": 600,
       "inputs": {
        "InputPayload": {
         "logging_role": "{{ LoggingRole }}",
         "topic_arn": "{{ SNSTopicArn }}",
         "sample_rate": "{{ SampleRate }}"
        },
        "Runtime": "python3.8",
        "Handler": "lambda_handler",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n\nboto_config = Config(\n    retries = {\n            'mode': 'standard',\n            'max_attempts': 10\n        }\n    )\n\nfailureFeedbackRoleValue = \"LambdaFailureFeedbackRoleArn\"\nsuccessFeedbackRoleValue = \"LambdaSuccessFeedbackRoleArn\"\nsuccessRateRoleValue = \"LambdaSuccessFeedbackSampleRate\"\n\ndef connect_to_sns():\n    return boto3.client('sns', config=boto_config)\n\ndef lambda_handler(event, _):\n    \"\"\"\n     Enable delivery status logging on a SNS topic\n \n     `event` should have the following keys and values:\n     `logging_role`: the ARN of the IAM Role used to log successful and failed deliveries\n     `topic_arn`: the arn of the SNS Topic to enable delivery status logging on\n \n     `context` is ignored\n    \"\"\"\n\n    logging_role = event[\"logging_role\"]\n    topic_arn = event[\"topic_arn\"]\n    sample_rate = event[\"sample_rate\"]\n\n    add_roles_to_topic(logging_role, topic_arn)\n    add_sample_rate_to_topic(topic_arn, sample_rate)\n\n    topic_attributes = get_topic_attributes(topic_arn)\n\n    return {\n        \"FailureFeedbackRole\": topic_attributes[\"Attributes\"][failureFeedbackRoleValue],\n        \"SuccessFeedbackRole\": topic_attributes[\"Attributes\"][successFeedbackRoleValue],\n        \"SuccessSampleRate\": topic_attributes[\"Attributes\"][successRateRoleValue]\n    }\n\ndef add_roles_to_topic(logging_role, topic_arn):\n    \"\"\"\n    Configures the IAM role `logging_role` that will log successful and failed deliveries to SNS Topic `topic_arn`\n    \"\"\"  \n    sns = connect_to_sns()\n    try:\n        sns.set_topic_attributes(TopicArn=topic_arn, AttributeName=successFeedbackRoleValue, AttributeValue=logging_role)\n        sns.set_topic_attributes(TopicArn=topic_arn, AttributeName=failureFeedbackRoleValue, AttributeValue=logging_role)\n\n    except Exception as e:\n        reset_to_recognized_state(topic_arn)\n        exit(f'Failed to set success/failure role of topic '+topic_arn+': '+str(e))\n\ndef add_sample_rate_to_topic(topic_arn, sample_rate):\n    \"\"\"\n    Configures the Success sample rate, the percentage of successful messages for which you want to receive CloudWatch Logs.\n    \"\"\"    \n    sns = connect_to_sns()\n    try:\n        sns.set_topic_attributes(TopicArn=topic_arn, AttributeName=successRateRoleValue, AttributeValue=sample_rate)\n\n    except Exception as e:\n        reset_to_recognized_state(topic_arn)\n        exit(f'Failed to set success sample rate of SNS topic '+topic_arn+': '+str(e))\n\ndef get_topic_attributes(topic_arn):\n    \"\"\"\n    Grabs Topic Attributes to verify topic values were set as expected.\n    \"\"\"\n    sns = connect_to_sns()\n    try:\n        topic_attributes = sns.get_topic_attributes(TopicArn=topic_arn)\n        return topic_attributes\n\n    except Exception as e:\n        exit(f'Failed to get attributes of SNS topic '+topic_arn+': '+str(e))\n\ndef reset_to_recognized_state(topic_arn):\n    \"\"\"\n    Used in case of error, will unset all delivery status logging parameters.\n    \"\"\"\n    sns = connect_to_sns()\n    \n    sns.set_topic_attributes(TopicArn=topic_arn, AttributeName=successFeedbackRoleValue, AttributeValue='')\n    sns.set_topic_attributes(TopicArn=topic_arn, AttributeName=failureFeedbackRoleValue, AttributeValue='')"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload",
         "Type": "StringMap"
        }
       ],
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-EnableDeliveryStatusLoggingForSNSTopic",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait8"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR EnableDeliveryStatusLoggingForSNSTopic"
   }
  },
  "ASRDisablePublicIPAutoAssign": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document name - ASR-DisablePublicIPAutoAssign\n\n## What does this document do?\n  This document disables public IP auto assignment on given subnet using\n  [ModifySubnetAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySubnetAttribute.html) API.\n\n## Input Parameters\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* SubnetARN: (Required)  The ARN of the Amazon EC2 Subnet.\n\n## Security Standards / Controls\n* AFSBP v1.0.0:  EC2.15\n",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "SubnetARN": {
       "type": "String",
       "description": "(Required) The ARN of the Amazon EC2 Subnet.",
       "allowedPattern": "^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subnet\\/(subnet-[0-9a-f]*)$"
      }
     },
     "outputs": [
      "DisablePublicIPAutoAssign.Output"
     ],
     "mainSteps": [
      {
       "name": "DisablePublicIPAutoAssign",
       "action": "aws:executeScript",
       "timeoutSeconds": 600,
       "inputs": {
        "InputPayload": {
         "subnet_arn": "{{ SubnetARN }}"
        },
        "Runtime": "python3.8",
        "Handler": "lambda_handler",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\nfrom botocore.exceptions import ClientError\n \nboto_config = Config(\n     retries = {\n             'mode': 'standard',\n             'max_attempts': 10\n         }\n     )\n \n\n \ndef connect_to_ec2():\n    return boto3.client('ec2', config=boto_config)\n \ndef lambda_handler(event, _):\n     \"\"\"\n      Disable public IP auto assignment on a subnet.\n\n      `event` should have the following keys and values:\n      `subnet_arn`: the ARN of the subnet that has public IP auto assignment enabled.\n  \n      `context` is ignored\n     \"\"\"\n \n     subnet_arn = event['subnet_arn']\n\n     subnet_id = subnet_arn.split('/')[1]\n \n     disable_publicip_auto_assign(subnet_id)\n \n     subnet_attributes = describe_subnet(subnet_id)\n\n     public_ip_on_launch = subnet_attributes['Subnets'][0]['MapPublicIpOnLaunch']\n \n     if public_ip_on_launch == False:  \n        return {\n                \"MapPublicIpOnLaunch\": public_ip_on_launch\n            }\n\n     raise RuntimeError(f'ASR Remediation failed - {subnet_id} did not have public IP auto assignment turned off.')\n    \n \ndef disable_publicip_auto_assign(subnet_id):\n     \"\"\"\n     Disables public IP Auto Assign on the subnet `subnet_id`\n     \"\"\"  \n     ec2 = connect_to_ec2()\n     try:\n        ec2.modify_subnet_attribute(MapPublicIpOnLaunch={'Value':False},SubnetId=subnet_id)\n \n     except Exception as e:\n        exit(f'There was an error turning off public IP auto assignment: '+str(e))\n \ndef describe_subnet(subnet_id):\n    \"\"\"\n    Grabs Subnet Attributes to verify subnet values were set as expected.\n    \"\"\"\n    ec2 = connect_to_ec2()\n    try:\n        subnet_attributes = ec2.describe_subnets(SubnetIds=[subnet_id])\n        return subnet_attributes\n \n    except Exception as e:\n        exit(f'Failed to get attributes of subnet: '+str(e))"
       },
       "outputs": [
        {
         "Name": "Output",
         "Selector": "$.Payload",
         "Type": "StringMap"
        }
       ]
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-DisablePublicIPAutoAssign",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait8"
   ],
   "Metadata": {
    "aws:cdk:path": "RunbookStack/ASR DisablePublicIPAutoAssign"
   }
  },
  "CreateWait0": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "719574aea3525db420a0be68782edf4dab8ea536d6223b758a5f774a63d050b8"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait0/Default"
   }
  },
  "DeletWait0": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "719574aea3525db420a0be68782edf4dab8ea536d6223b758a5f774a63d050b8"
   },
   "DependsOn": [
    "ASRCreateCloudTrailMultiRegionTrail",
    "ASRCreateLogMetricFilterAndAlarm",
    "ASREnableAutoScalingGroupELBHealthCheck",
    "ASREnableAWSConfig",
    "ASREnableCloudTrailToCloudWatchLogging"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait0/Default"
   }
  },
  "CreateWait1": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "6ab2b917f1465b034999281244e7b4c1611300ea4929b3896fc7615dd3ba7e1f"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait1/Default"
   }
  },
  "DeletWait1": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "6ab2b917f1465b034999281244e7b4c1611300ea4929b3896fc7615dd3ba7e1f"
   },
   "DependsOn": [
    "ASRCreateAccessLoggingBucket",
    "ASREnableCloudTrailEncryption",
    "ASREnableDefaultEncryptionS3",
    "ASREnableVPCFlowLogs",
    "ASRMakeEBSSnapshotsPrivate",
    "DeletWait0"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait1/Default"
   }
  },
  "CreateWait2": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "d9d70554583f2debde0daaee77134a4f27f295524be0a9fbc1f5896899b12862"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait2/Default"
   }
  },
  "DeletWait2": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "d9d70554583f2debde0daaee77134a4f27f295524be0a9fbc1f5896899b12862"
   },
   "DependsOn": [
    "ASRMakeRDSSnapshotPrivate",
    "ASRRemoveLambdaPublicAccess",
    "ASRReplaceCodeBuildClearTextCredentials",
    "ASRRevokeUnrotatedKeys",
    "ASRSetSSLBucketPolicy",
    "DeletWait1"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait2/Default"
   }
  },
  "CreateWait3": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "d8cb9fbe52d6cb8d12cf3f418251ea9ecf2a823155b7aeceaefc304e2999d008"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait3/Default"
   }
  },
  "DeletWait3": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "d8cb9fbe52d6cb8d12cf3f418251ea9ecf2a823155b7aeceaefc304e2999d008"
   },
   "DependsOn": [
    "ASRDisablePublicAccessToRedshiftCluster",
    "ASREnableAutomaticVersionUpgradeOnRedshiftCluster",
    "ASREnableRedshiftClusterAuditLogging",
    "ASREncryptRDSSnapshot",
    "ASRS3BlockDenylist",
    "DeletWait2"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait3/Default"
   }
  },
  "CreateWait4": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "cbb21589711741582f016da0204b949e6bb393744d53b01dcc5383669d106dea"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait4/Default"
   }
  },
  "DeletWait4": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "cbb21589711741582f016da0204b949e6bb393744d53b01dcc5383669d106dea"
   },
   "DependsOn": [
    "ASRConfigureS3BucketPublicAccessBlock",
    "ASRConfigureSNSTopicForStack",
    "ASRCreateIAMSupportRole",
    "ASREnableAutomaticSnapshotsOnRedshiftCluster",
    "ASREnableEncryptionForSQSQueue",
    "DeletWait3"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait4/Default"
   }
  },
  "CreateWait5": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "6beab64cd1e1e29ec0dfac301f88b9a6eb2cf699bf743fbecf0fb88eca6f4f5c"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait5/Default"
   }
  },
  "DeletWait5": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "6beab64cd1e1e29ec0dfac301f88b9a6eb2cf699bf743fbecf0fb88eca6f4f5c"
   },
   "DependsOn": [
    "ASRConfigureS3PublicAccessBlock",
    "ASREnableCloudTrailLogFileValidation",
    "ASREnableEbsEncryptionByDefault",
    "ASREnableEnhancedMonitoringOnRDSInstance",
    "ASREnableKeyRotation",
    "DeletWait4"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait5/Default"
   }
  },
  "CreateWait6": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "76ac9234ed21512ab7274d9f95c6a1ef847748fa697d122f7c3e1d7a1d74f010"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait6/Default"
   }
  },
  "DeletWait6": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "76ac9234ed21512ab7274d9f95c6a1ef847748fa697d122f7c3e1d7a1d74f010"
   },
   "DependsOn": [
    "ASREnableCopyTagsToSnapshotOnRDSCluster",
    "ASREnableMultiAZOnRDSInstance",
    "ASREnableRDSClusterDeletionProtection",
    "ASREnableRDSInstanceDeletionProtection",
    "ASRRemoveVPCDefaultSecurityGroupRules",
    "DeletWait5"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait6/Default"
   }
  },
  "CreateWait7": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "971be703d38efdd2d75a17325953419f3244f959e839b5a0668b12146968ac0c"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait7/Default"
   }
  },
  "DeletWait7": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "971be703d38efdd2d75a17325953419f3244f959e839b5a0668b12146968ac0c"
   },
   "DependsOn": [
    "ASRDisablePublicAccessToRDSInstance",
    "ASREnableEncryptionForSNSTopic",
    "ASREnableMinorVersionUpgradeOnRDSDBInstance",
    "ASRRevokeUnusedIAMUserCredentials",
    "ASRSetIAMPasswordPolicy",
    "DeletWait6"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait7/Default"
   }
  },
  "CreateWait8": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "76a143310018a965418e9379eb90670ea780456ea33047bd55f0b597443d59ba"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/CreateWait8/Default"
   }
  },
  "DeletWait8": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "76a143310018a965418e9379eb90670ea780456ea33047bd55f0b597443d59ba"
   },
   "DependsOn": [
    "ASRDisablePublicIPAutoAssign",
    "ASREnableDeliveryStatusLoggingForSNSTopic",
    "DeletWait7"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "RunbookStack/DeletWait8/Default"
   }
  }
 }
}