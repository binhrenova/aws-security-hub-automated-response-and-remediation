{
 "Description": "(DEV-SO0111M) AWS Security Hub Automated Response & Remediation SC 2.0.0 Compliance Pack - Member Account, v1.5.1",
 "AWSTemplateFormatVersion": "2010-09-09",
 "Parameters": {
  "SecHubAdminAccount": {
   "Type": "String",
   "AllowedPattern": "^\\d{12}$",
   "Description": "Admin account number"
  },
  "WaitProviderServiceToken": {
   "Type": "String"
  },
  "ControlRunbooksEnableAutoScaling1851AF8B0": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control AutoScaling.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCloudFormation1B75725BB": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CloudFormation.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCloudTrail1F0F927F7": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CloudTrail.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCloudTrail28CC248AB": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CloudTrail.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCloudTrail4040C6EAB": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CloudTrail.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCloudTrail52CBFD019": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CloudTrail.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCloudTrail63394AC2B": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CloudTrail.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCloudTrail7FFC8DAB9": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CloudTrail.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCloudWatch19BE65F2B": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CloudWatch.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableCodeBuild26FB6E539": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control CodeBuild.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableConfig19F6E6FE3": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control Config.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableEC21395C7891": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control EC2.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableEC22F9B66A60": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control EC2.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableEC265685AB83": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control EC2.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableEC27108F6303": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control EC2.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableEC21349FA0A79": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control EC2.13 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableEC215DA64A549": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control EC2.15 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableIAM35D05519D": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control IAM.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableIAM766CB4E0A": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control IAM.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableIAM834577BE3": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control IAM.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableIAM18A4548D88": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control IAM.18 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableKMS415F4485B": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control KMS.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableLambda11AAE99FF": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control Lambda.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS18380A289": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS2004A67EB": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS4E2A98B6D": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS59E051E8F": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS6C46B2207": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS7CEA605AE": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS8FBE41D2B": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS13F10477DD": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.13 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRDS16F428962C": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control RDS.16 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRedshift1E5BFAC24": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control Redshift.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRedshift39346F065": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control Redshift.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRedshift40FBDF0D8": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control Redshift.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableRedshift648AC3FBB": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control Redshift.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableS3116A23B93": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control S3.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableS325CF1F81C": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control S3.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableS348078AE21": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control S3.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableS35B965D7F6": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control S3.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableS36B92F84BB": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control S3.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableSQS1A400C913": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control SQS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableSNS1B5923950": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control SNS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "ControlRunbooksEnableSNS232380485": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for security-control version 2.0.0 Control SNS.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  }
 },
 "Resources": {
  "ControlRunbooksAutoScaling1BA109277": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_AutoScaling.1\n\n## What does this document do?\nThis document enables ELB healthcheck on a given AutoScaling Group using the [UpdateAutoScalingGroup] API.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* HealthCheckGracePeriod: (Optional) Health check grace period when ELB health check is Enabled\nDefault: 30 seconds\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP AutoScaling.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-autoscaling-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the AutoScaling.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableAutoScalingGroupELBHealthCheck",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):autoscaling:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:autoScalingGroup:(?:[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}):autoScalingGroupName/(.{1,255})$",
         "expected_control_id": [
          "AutoScaling.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "AutoScalingGroupName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableAutoScalingGroupELBHealthCheck",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "AutoScalingGroupName": "{{ ParseInput.AutoScalingGroupName }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "ASG health check type updated to ELB",
         "UpdatedBy": "ASR-SC_2.0.0_AutoScaling.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_AutoScaling.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/AutoScaling.1/Resource"
   },
   "Condition": "ControlRunbooksEnableAutoScaling1ConditionD5DF4981"
  },
  "ControlRunbooksCloudFormation12CB945DB": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudFormation.1\n\n## What does this document do?\nThis document configures an SNS topic for notifications from a CloudFormation stack by calling another document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 CloudFormation.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudformation-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudFormation.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-ConfigureSNSTopicForStack",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^(arn:(?:aws|aws-us-gov|aws-cn):cloudformation:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:stack/[a-zA-Z][a-zA-Z0-9-]{0,127}/[a-fA-F0-9]{8}-(?:[a-fA-F0-9]{4}-){3}[a-fA-F0-9]{12})$",
         "expected_control_id": [
          "CloudFormation.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "StackArn",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-ConfigureSNSTopicForStack",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "StackArn": "{{ ParseInput.StackArn }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Configured SNS topic for notifications",
         "UpdatedBy": "ASR-SC_2.0.0_CloudFormation.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CloudFormation.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CloudFormation.1/Resource"
   },
   "Condition": "ControlRunbooksEnableCloudFormation1ConditionD8D32097"
  },
  "ControlRunbooksCloudTrail1B15F1A13": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudTrail.1\n## What does this document do?\nCreates a multi-region trail with KMS encryption and enables CloudTrail\nNote: this remediation will create a NEW trail.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP CloudTrail.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-CreateCloudTrailMultiRegionTrail",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "CloudTrail.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-CreateCloudTrailMultiRegionTrail",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "AWSPartition": "{{ global:AWS_PARTITION }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Multi-region, encrypted AWS CloudTrail successfully created",
         "UpdatedBy": "ASR-SC_2.0.0_CloudTrail.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CloudTrail.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CloudTrail.1/Resource"
   },
   "Condition": "ControlRunbooksEnableCloudTrail1ConditionB7EBAA86"
  },
  "ControlRunbooksCloudTrail2979D0B5D": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudTrail.2\n## What does this document do?\nThis document enables SSE KMS encryption for log files using the ASR remediation KMS CMK\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n## Output Parameters\n* Remediation.Output - Output from the remediation\n\n## Documentation Links\n* [AFSBP CloudTrail.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-2)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "KMSKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias\\/[A-Za-z0-9/_-])|(?:key\\/(?:[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})))$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableCloudTrailEncryption",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "CloudTrail.2"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "TrailArn",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableCloudTrailEncryption",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "TrailArn": "{{ ParseInput.TrailArn }}",
         "TrailRegion": "{{ ParseInput.RemediationRegion }}",
         "KMSKeyArn": "{{ KMSKeyArn }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Encryption enabled on CloudTrail",
         "UpdatedBy": "ASR-SC_2.0.0_CloudTrail.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CloudTrail.2",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CloudTrail.2/Resource"
   },
   "Condition": "ControlRunbooksEnableCloudTrail2ConditionC182A10F"
  },
  "ControlRunbooksCloudTrail4057F669F": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudTrail.4\n\n## What does this document do?\nThis document enables CloudTrail log file validation.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 CloudTrail.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-4)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableCloudTrailLogFileValidation",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail\\/([A-Za-z0-9._-]{3,128})$",
         "expected_control_id": [
          "CloudTrail.4"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "TrailName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableCloudTrailLogFileValidation",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "TrailName": "{{ ParseInput.TrailName }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enabled CloudTrail log file validation.",
         "UpdatedBy": "ASR-SC_2.0.0_CloudTrail.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CloudTrail.4",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CloudTrail.4/Resource"
   },
   "Condition": "ControlRunbooksEnableCloudTrail4Condition587734A2"
  },
  "ControlRunbooksCloudTrail54F5ED8E4": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudTrail.5\n\n## What does this document do?\nThis document configures CloudTrail to log to CloudWatch Logs.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Remediation results\n\n## Documentation Links\n* [AFSBP v1.0.0 CloudTrail.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-5)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.5 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableCloudTrailToCloudWatchLogging",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail\\/([A-Za-z0-9._-]{3,128})$",
         "expected_control_id": [
          "CloudTrail.5"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "TrailName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableCloudTrailToCloudWatchLogging",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "TrailName": "{{ ParseInput.TrailName }}",
         "CloudWatchLogsRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/DEV-SO0111-CloudTrailToCloudWatchLogs",
         "LogGroupName": "CloudTrail/{{ ParseInput.TrailName }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Configured CloudTrail logging to CloudWatch Logs Group CloudTrail/{{ ParseInput.TrailName }}",
         "UpdatedBy": "ASR-SC_2.0.0_CloudTrail.5"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CloudTrail.5",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CloudTrail.5/Resource"
   },
   "Condition": "ControlRunbooksEnableCloudTrail5Condition17B6B536"
  },
  "ControlRunbooksCloudTrail6526C5643": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-CIS_1.2.0_2.3\n\n## What does this document do?\nThis document blocks public access to the CloudTrail S3 bucket.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [CIS v1.2.0 2.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.3)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.6 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-ConfigureS3BucketPublicAccessBlock",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "CloudTrail.6"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-ConfigureS3BucketPublicAccessBlock",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "BucketName": "{{ ParseInput.BucketName }}",
         "RestrictPublicBuckets": true,
         "BlockPublicAcls": true,
         "IgnorePublicAcls": true,
         "BlockPublicPolicy": true
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Disabled public access to CloudTrail logs bucket.",
         "UpdatedBy": "ASR-SC_2.0.0_CloudTrail.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CloudTrail.6",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CloudTrail.6/Resource"
   },
   "Condition": "ControlRunbooksEnableCloudTrail6Condition486CC2C3"
  },
  "ControlRunbooksCloudTrail7C6D85038": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-CIS_1.2.0_2.6\n\n## What does this document do?\nConfigures access logging for a CloudTrail S3 bucket.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Remediation results\n\n## Documentation Links\n* [CIS v1.2.0 2.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.6)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.7 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-ConfigureS3BucketLogging",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "CloudTrail.7"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "CreateAccessLoggingBucket",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-CreateAccessLoggingBucket",
        "RuntimeParameters": {
         "BucketName": "dev-so0111-cloudtrailaccesslogs-{{ global:ACCOUNT_ID }}-{{ global:REGION }}",
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/DEV-SO0111-CreateAccessLoggingBucket"
        }
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "AWS-ConfigureS3BucketLogging",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "BucketName": "{{ ParseInput.BucketName }}",
         "GrantedPermission": [
          "READ"
         ],
         "GranteeType": [
          "Group"
         ],
         "GranteeUri": [
          "http://acs.amazonaws.com/groups/s3/LogDelivery"
         ],
         "TargetPrefix": [
          "{{ ParseInput.BucketName }}"
         ],
         "TargetBucket": [
          "dev-so0111-cloudtrailaccesslogs-{{ global:ACCOUNT_ID }}-{{ global:REGION }}"
         ]
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Created S3 bucket dev-so0111-cloudtrailaccesslogs-{{ global:ACCOUNT_ID }}-{{ global:REGION }} for logging access to {{ ParseInput.BucketName }}",
         "UpdatedBy": "ASR-SC_2.0.0_CloudTrail.7"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CloudTrail.7",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CloudTrail.7/Resource"
   },
   "Condition": "ControlRunbooksEnableCloudTrail7ConditionA4FF88B2"
  },
  "ControlRunbooksCloudWatch1A05F543A": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-CIS_1.2.0_3.x\n\n## What does this document do?\nRemediates the following CIS findings:\n\n3.1 - Creates a log metric filter and alarm for unauthorized API calls\n3.2 - Creates a log metric filter and alarm for AWS Management Console sign-in without MFA\n3.3 - Creates a log metric filter and alarm for usage of \"root\" account\n3.4 - Creates a log metric filter and alarm for for IAM policy changes\n3.5 - Creates a log metric filter and alarm for CloudTrail configuration changes\n3.6 - Creates a log metric filter and alarm for AWS Management Console authentication failures\n3.7 - Creates a log metric filter and alarm for disabling or scheduled deletion of customer created CMKs\n3.8 - Creates a log metric filter and alarm for S3 bucket policy changes\n3.9 - Creates a log metric filter and alarm for AWS Config configuration changes\n3.10 - Creates a log metric filter and alarm for security group changes\n3.11 - Creates a log metric filter and alarm for changes to Network Access Control Lists (NACL)\n3.12 - Creates a log metric filter and alarm for changes to network gateways\n3.13 - Creates a log metric filter and alarm for route table changes\n3.14 - Creates a log metric filter and alarm for VPC changes\n\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Output of remediation runbook.\n\n## Documentation Links\n[CIS v1.2.0 3.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.1)\n[CIS v1.2.0 3.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.2)\n[CIS v1.2.0 3.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.3)\n[CIS v1.2.0 3.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.4)\n[CIS v1.2.0 3.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.5)\n[CIS v1.2.0 3.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.6)\n[CIS v1.2.0 3.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.7)\n[CIS v1.2.0 3.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.8)\n[CIS v1.2.0 3.9](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.9)\n[CIS v1.2.0 3.10](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.10)\n[CIS v1.2.0 3.11](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.11)\n[CIS v1.2.0 3.12](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.12)\n[CIS v1.2.0 3.13](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.13)\n[CIS v1.2.0 3.14](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.14)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "LogGroupName": {
       "type": "String",
       "description": "The name of the Log group to be used to create filters and metric alarms",
       "default": "{{ssm:/Solutions/DEV-SO0111/Metrics_LogGroupName}}",
       "allowedPattern": ".*"
      },
      "MetricNamespace": {
       "type": "String",
       "description": "The name of the metric namespace where the metrics will be logged",
       "default": "LogMetrics",
       "allowedPattern": ".*"
      },
      "KMSKeyArn": {
       "type": "String",
       "description": "The ARN of the KMS key created by ASR for remediations",
       "default": "{{ssm:/Solutions/DEV-SO0111/CMK_REMEDIATION_ARN}}",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias\\/[A-Za-z0-9/-_])|(?:key\\/(?:[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})))$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudWatch.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-CreateLogMetricFilterAndAlarm",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "CloudWatch.1",
          "CloudWatch.2",
          "CloudWatch.3",
          "CloudWatch.4",
          "CloudWatch.5",
          "CloudWatch.6",
          "CloudWatch.7",
          "CloudWatch.8",
          "CloudWatch.9",
          "CloudWatch.10",
          "CloudWatch.11",
          "CloudWatch.12",
          "CloudWatch.13",
          "CloudWatch.14"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "ControlId",
         "Selector": "$.Payload.control_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "GetMetricFilterAndAlarmInputValue",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "verify",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\n\nunauthorizedAPICallsFilter = {\n        \"filter_name\": \"UnauthorizedAPICalls\",\n        \"filter_pattern\": '{($.errorCode=\"*UnauthorizedOperation\") || ($.errorCode=\"AccessDenied*\")}',\n        \"metric_name\": \"UnauthorizedAPICalls\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"UnauthorizedAPICalls\",\n        \"alarm_desc\": \"Alarm for UnauthorizedAPICalls > 0\",\n        \"alarm_threshold\": 1\n}\n\nconsoleSignInWithoutMFAFilter = {\n        \"filter_name\": \"ConsoleSigninWithoutMFA\",\n        \"filter_pattern\": '{($.eventName=\"ConsoleLogin\") && ($.additionalEventData.MFAUsed !=\"Yes\")}',\n        \"metric_name\": \"ConsoleSigninWithoutMFA\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"ConsoleSigninWithoutMFA\",\n        \"alarm_desc\": \"Alarm for ConsoleSigninWithoutMFA > 0\",\n        \"alarm_threshold\": 1\n }\n\nrootAccountUsageFilter = {\n        \"filter_name\": \"RootAccountUsage\",\n        \"filter_pattern\": '{$.userIdentity.type=\"Root\" && $.userIdentity.invokedBy NOT EXISTS && $.eventType !=\"AwsServiceEvent\"}',\n        \"metric_name\": \"RootAccountUsage\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"RootAccountUsage\",\n        \"alarm_desc\": \"Alarm for RootAccountUsage > 0\",\n        \"alarm_threshold\": 1\n}\n\niamPolicyChangesFilter = {\n        \"filter_name\": \"IAMPolicyChanges\",\n        \"filter_pattern\": '{($.eventName=DeleteGroupPolicy) || ($.eventName=DeleteRolePolicy) || ($.eventName=DeleteUserPolicy) || ($.eventName=PutGroupPolicy) || ($.eventName=PutRolePolicy) || ($.eventName=PutUserPolicy) || ($.eventName=CreatePolicy) || ($.eventName=DeletePolicy) || ($.eventName=CreatePolicyVersion) || ($.eventName=DeletePolicyVersion) || ($.eventName=AttachRolePolicy) || ($.eventName=DetachRolePolicy) || ($.eventName=AttachUserPolicy) || ($.eventName=DetachUserPolicy) || ($.eventName=AttachGroupPolicy) || ($.eventName=DetachGroupPolicy)}',\n        \"metric_name\": \"IAMPolicyChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"IAMPolicyChanges\",\n        \"alarm_desc\": \"Alarm for IAMPolicyChanges > 0\",\n        \"alarm_threshold\": 1\n }\n\ncloudtrailChangesFilter = {\n        \"filter_name\": \"CloudTrailChanges\",\n        \"filter_pattern\": '{($.eventName=CreateTrail) || ($.eventName=UpdateTrail) || ($.eventName=DeleteTrail) || ($.eventName=StartLogging) || ($.eventName=StopLogging)}',\n        \"metric_name\": \"CloudTrailChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"CloudTrailChanges\",\n        \"alarm_desc\": \"Alarm for CloudTrailChanges > 0\",\n        \"alarm_threshold\": 1\n}\n\nconsoleAuthenticationFailureFilter = {\n        \"filter_name\": \"ConsoleAuthenticationFailure\",\n        \"filter_pattern\": '{($.eventName=ConsoleLogin) && ($.errorMessage=\"Failed authentication\")}',\n        \"metric_name\": \"ConsoleAuthenticationFailure\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"ConsoleAuthenticationFailure\",\n        \"alarm_desc\": \"Alarm for ConsoleAuthenticationFailure > 0\",\n        \"alarm_threshold\": 1\n }\n\ndisableOrDeleteCMKFilter = {\n        \"filter_name\": \"DisableOrDeleteCMK\",\n        \"filter_pattern\": '{($.eventSource=kms.amazonaws.com) && (($.eventName=DisableKey) || ($.eventName=ScheduleKeyDeletion))}',\n        \"metric_name\": \"DisableOrDeleteCMK\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"DisableOrDeleteCMK\",\n        \"alarm_desc\": \"Alarm for DisableOrDeleteCMK > 0\",\n        \"alarm_threshold\": 1\n}\n\ns3BucketPolicyChangesFilter = {\n        \"filter_name\": \"S3BucketPolicyChanges\",\n        \"filter_pattern\": '{($.eventSource=s3.amazonaws.com) && (($.eventName=PutBucketAcl) || ($.eventName=PutBucketPolicy) || ($.eventName=PutBucketCors) || ($.eventName=PutBucketLifecycle) || ($.eventName=PutBucketReplication) || ($.eventName=DeleteBucketPolicy) || ($.eventName=DeleteBucketCors) || ($.eventName=DeleteBucketLifecycle) || ($.eventName=DeleteBucketReplication))}',\n        \"metric_name\": \"S3BucketPolicyChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"S3BucketPolicyChanges\",\n        \"alarm_desc\": \"Alarm for S3BucketPolicyChanges > 0\",\n        \"alarm_threshold\": 1\n}\n\nawsConfigChangesFilter = {\n        \"filter_name\": \"AWSConfigChanges\",\n        \"filter_pattern\": '{($.eventSource=config.amazonaws.com) && (($.eventName=StopConfigurationRecorder) || ($.eventName=DeleteDeliveryChannel) || ($.eventName=PutDeliveryChannel) || ($.eventName=PutConfigurationRecorder))}',\n        \"metric_name\": \"AWSConfigChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"AWSConfigChanges\",\n        \"alarm_desc\": \"Alarm for AWSConfigChanges > 0\",\n        \"alarm_threshold\": 1\n}\n\nsecurityGroupChangesFilter = {\n        \"filter_name\": \"SecurityGroupChanges\",\n        \"filter_pattern\": '{($.eventName=AuthorizeSecurityGroupIngress) || ($.eventName=AuthorizeSecurityGroupEgress) || ($.eventName=RevokeSecurityGroupIngress) || ($.eventName=RevokeSecurityGroupEgress) || ($.eventName=CreateSecurityGroup) || ($.eventName=DeleteSecurityGroup)}',\n        \"metric_name\": \"SecurityGroupChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"SecurityGroupChanges\",\n        \"alarm_desc\": \"Alarm for SecurityGroupChanges > 0\",\n        \"alarm_threshold\": 1\n}\n\nnetworkACLChangesFilter = {\n        \"filter_name\": \"NetworkACLChanges\",\n        \"filter_pattern\": '{($.eventName=CreateNetworkAcl) || ($.eventName=CreateNetworkAclEntry) || ($.eventName=DeleteNetworkAcl) || ($.eventName=DeleteNetworkAclEntry) || ($.eventName=ReplaceNetworkAclEntry) || ($.eventName=ReplaceNetworkAclAssociation)}',\n        \"metric_name\": \"NetworkACLChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"NetworkACLChanges\",\n        \"alarm_desc\": \"Alarm for NetworkACLChanges > 0\",\n        \"alarm_threshold\": 1\n}\n\nnetworkGatewayChangesFilter = {\n        \"filter_name\": \"NetworkGatewayChanges\",\n        \"filter_pattern\": '{($.eventName=CreateCustomerGateway) || ($.eventName=DeleteCustomerGateway) || ($.eventName=AttachInternetGateway) || ($.eventName=CreateInternetGateway) || ($.eventName=DeleteInternetGateway) || ($.eventName=DetachInternetGateway)}',\n        \"metric_name\": \"NetworkGatewayChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"NetworkGatewayChanges\",\n        \"alarm_desc\": \"Alarm for NetworkGatewayChanges > 0\",\n        \"alarm_threshold\": 1\n}\n\nrouteTableChangesFilter = {\n        \"filter_name\": \"RouteTableChanges\",\n        \"filter_pattern\": '{($.eventName=CreateRoute) || ($.eventName=CreateRouteTable) || ($.eventName=ReplaceRoute) || ($.eventName=ReplaceRouteTableAssociation) || ($.eventName=DeleteRouteTable) || ($.eventName=DeleteRoute) || ($.eventName=DisassociateRouteTable)}',\n        \"metric_name\": \"RouteTableChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"RouteTableChanges\",\n        \"alarm_desc\": \"Alarm for RouteTableChanges > 0\",\n        \"alarm_threshold\": 1\n}\n\nvpcChangesFilter = {\n        \"filter_name\": \"VPCChanges\",\n        \"filter_pattern\": '{($.eventName=CreateVpc) || ($.eventName=DeleteVpc) || ($.eventName=ModifyVpcAttribute) || ($.eventName=AcceptVpcPeeringConnection) || ($.eventName=CreateVpcPeeringConnection) || ($.eventName=DeleteVpcPeeringConnection) || ($.eventName=RejectVpcPeeringConnection) || ($.eventName=AttachClassicLinkVpc) || ($.eventName=DetachClassicLinkVpc) || ($.eventName=DisableVpcClassicLink) || ($.eventName=EnableVpcClassicLink)}',\n        \"metric_name\": \"VPCChanges\",\n        \"metric_value\": 1,\n        \"alarm_name\": \"VPCChanges\",\n        \"alarm_desc\": \"Alarm for VPCChanges > 0\",\n        \"alarm_threshold\": 1\n}\n\nCloudwatch_mappings = {\n    'cis-aws-foundations-benchmark': {\n        '1.2.0': {\n            '3.1': unauthorizedAPICallsFilter,\n            '3.2': consoleSignInWithoutMFAFilter,\n            '3.3': rootAccountUsageFilter,\n            '3.4': iamPolicyChangesFilter,\n            '3.5': cloudtrailChangesFilter,\n            '3.6': consoleAuthenticationFailureFilter,\n            '3.7': disableOrDeleteCMKFilter,\n            '3.8': s3BucketPolicyChangesFilter,\n            '3.9': awsConfigChangesFilter,\n            '3.10': securityGroupChangesFilter,\n            '3.11': networkACLChangesFilter,\n            '3.12': networkGatewayChangesFilter,\n            '3.13': routeTableChangesFilter,\n            '3.14': vpcChangesFilter\n        },\n        '1.4.0': {\n            '4.3': rootAccountUsageFilter,\n            '4.4': iamPolicyChangesFilter,\n            '4.5': cloudtrailChangesFilter,\n            '4.6': consoleAuthenticationFailureFilter,\n            '4.7': disableOrDeleteCMKFilter,\n            '4.8': s3BucketPolicyChangesFilter,\n            '4.9': awsConfigChangesFilter,\n            '4.10': securityGroupChangesFilter,\n            '4.11': networkACLChangesFilter,\n            '4.12': networkGatewayChangesFilter,\n            '4.13': routeTableChangesFilter,\n            '4.14': vpcChangesFilter\n        }\n    },\n    'security-control': {\n        '2.0.0': {\n           \"CloudWatch.1\": rootAccountUsageFilter,\n           \"CloudWatch.2\": unauthorizedAPICallsFilter,\n           \"CloudWatch.3\": consoleSignInWithoutMFAFilter,\n           \"CloudWatch.4\": iamPolicyChangesFilter,\n           \"CloudWatch.5\": cloudtrailChangesFilter,\n           \"CloudWatch.6\": consoleAuthenticationFailureFilter,\n           \"CloudWatch.7\": disableOrDeleteCMKFilter,\n           \"CloudWatch.8\": s3BucketPolicyChangesFilter,\n           \"CloudWatch.9\": awsConfigChangesFilter,\n           \"CloudWatch.10\": securityGroupChangesFilter,\n           \"CloudWatch.11\": networkACLChangesFilter,\n           \"CloudWatch.12\": networkGatewayChangesFilter,\n           \"CloudWatch.13\": routeTableChangesFilter,\n           \"CloudWatch.14\": vpcChangesFilter\n        }\n    }\n}\n\ndef verify(event, _):\n    try:\n        standard_mapping = Cloudwatch_mappings.get(event['StandardLongName']).get(event['StandardVersion'])\n        return standard_mapping.get(event['ControlId'], None) \n    except KeyError as ex:\n        exit(f'ERROR: Could not find associated metric filter. Missing parameter: {str(ex)}')\n\n ",
        "InputPayload": {
         "ControlId": "{{ ParseInput.ControlId }}",
         "StandardLongName": "security-control",
         "StandardVersion": "2.0.0"
        }
       },
       "outputs": [
        {
         "Name": "FilterName",
         "Selector": "$.Payload.filter_name",
         "Type": "String"
        },
        {
         "Name": "FilterPattern",
         "Selector": "$.Payload.filter_pattern",
         "Type": "String"
        },
        {
         "Name": "MetricName",
         "Selector": "$.Payload.metric_name",
         "Type": "String"
        },
        {
         "Name": "MetricValue",
         "Selector": "$.Payload.metric_value",
         "Type": "Integer"
        },
        {
         "Name": "AlarmName",
         "Selector": "$.Payload.alarm_name",
         "Type": "String"
        },
        {
         "Name": "AlarmDesc",
         "Selector": "$.Payload.alarm_desc",
         "Type": "String"
        },
        {
         "Name": "AlarmThreshold",
         "Selector": "$.Payload.alarm_threshold",
         "Type": "Integer"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-CreateLogMetricFilterAndAlarm",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "FilterName": "{{ GetMetricFilterAndAlarmInputValue.FilterName }}",
         "FilterPattern": "{{ GetMetricFilterAndAlarmInputValue.FilterPattern }}",
         "MetricName": "{{ GetMetricFilterAndAlarmInputValue.MetricName }}",
         "MetricValue": "{{ GetMetricFilterAndAlarmInputValue.MetricValue }}",
         "MetricNamespace": "{{ MetricNamespace }}",
         "AlarmName": "{{ GetMetricFilterAndAlarmInputValue.AlarmName }}",
         "AlarmDesc": "{{ GetMetricFilterAndAlarmInputValue.AlarmDesc }}",
         "AlarmThreshold": "{{ GetMetricFilterAndAlarmInputValue.AlarmThreshold }}",
         "LogGroupName": "{{ LogGroupName }}",
         "SNSTopicName": "DEV-SO0111-SHARR-LocalAlarmNotification",
         "KMSKeyArn": "{{ KMSKeyArn }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Added metric filter to the log group and notifications to SNS topic DEV-SO0111-ASR-LocalAlarmNotification.",
         "UpdatedBy": "ASR-SC_2.0.0_CloudWatch.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CloudWatch.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CloudWatch.1/Resource"
   },
   "Condition": "ControlRunbooksEnableCloudWatch1ConditionAB0DF2E5"
  },
  "ControlRunbooksCodeBuild2A2751671": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CodeBuild.2\n\n## What does this document do?\nThis document removes CodeBuild project environment variables containing clear text credentials and replaces them with Amazon EC2 Systems Manager Parameters.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 CodeBuild.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-codebuild-2)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CodeBuild.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-ReplaceCodeBuildClearTextCredentials",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):codebuild:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:project\\/([A-Za-z0-9][A-Za-z0-9\\-_]{1,254})$",
         "expected_control_id": [
          "CodeBuild.2"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "ProjectName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-ReplaceCodeBuildClearTextCredentials",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "ProjectName": "{{ ParseInput.ProjectName }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Replaced clear text credentials with SSM parameters.",
         "UpdatedBy": "ASR-SC_2.0.0_CodeBuild.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_CodeBuild.2",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/CodeBuild.2/Resource"
   },
   "Condition": "ControlRunbooksEnableCodeBuild2ConditionB01F473D"
  },
  "ControlRunbooksConfig1512B566F": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_Config.1\n## What does this document do?\nEnables AWS Config:\n* Turns on recording for all resources.\n* Creates an encrypted bucket for Config logging.\n* Creates a logging bucket for access logs for the config bucket\n* Creates an SNS topic for Config notifications\n* Creates a service-linked role\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP Config.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-config-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "KMSKeyArn": {
       "type": "String",
       "description": "The ARN of the KMS key created by ASR for remediations",
       "default": "{{ssm:/Solutions/DEV-SO0111/CMK_REMEDIATION_ARN}}",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias\\/[A-Za-z0-9/-_])|(?:key\\/(?:[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})))$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Config.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableAWSConfig",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "Config.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableAWSConfig",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "SNSTopicName": "DEV-SO0111-SHARR-AWSConfigNotification",
         "KMSKeyArn": "{{ KMSKeyArn }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "AWS Config enabled",
         "UpdatedBy": "ASR-SC_2.0.0_Config.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_Config.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/Config.1/Resource"
   },
   "Condition": "ControlRunbooksEnableConfig1Condition8CEB8627"
  },
  "ControlRunbooksEC214D3BB404": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.1\n## What does this document do?\nThis document changes all public EC2 snapshots to private\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP EC2.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-MakeEBSSnapshotsPrivate",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "EC2.1"
         ],
         "resource_index": 2
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "TestMode",
         "Selector": "$.Payload.testmode",
         "Type": "Boolean"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-MakeEBSSnapshotsPrivate",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "AccountId": "{{ ParseInput.RemediationAccount }}",
         "TestMode": "{{ ParseInput.TestMode }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "EBS Snapshot modified to private",
         "UpdatedBy": "ASR-SC_2.0.0_EC2.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_EC2.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/EC2.1/Resource"
   },
   "Condition": "ControlRunbooksEnableEC21ConditionD4F1277B"
  },
  "ControlRunbooksEC22ED852ADF": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.2\n\n## What does this document do?\nThis document deletes ingress and egress rules from default security\ngroup using the AWS SSM Runbook AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Output from AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules SSM doc\n\n## Documentation Links\n* [AFSBP EC2.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-2)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-RemoveVPCDefaultSecurityGroupRules",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:security-group\\/(sg-[0-9a-f]*)$",
         "expected_control_id": [
          "EC2.2"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "GroupId",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-RemoveVPCDefaultSecurityGroupRules",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "GroupId": "{{ ParseInput.GroupId }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Removed rules on default security group",
         "UpdatedBy": "ASR-SC_2.0.0_EC2.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_EC2.2",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/EC2.2/Resource"
   },
   "Condition": "ControlRunbooksEnableEC22ConditionB9E0D42E"
  },
  "ControlRunbooksEC267E3087AE": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.6\n\n## What does this document do?\nEnables VPC Flow Logs for a VPC\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Remediation results\n\n## Documentation Links\n* [AFSBP EC2.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-6)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.6 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableVPCFlowLogs",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):ec2:.*:\\d{12}:vpc\\/(vpc-[0-9a-f]{8,17})$",
         "expected_control_id": [
          "EC2.6"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "VPC",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableVPCFlowLogs",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "VPC": "{{ ParseInput.VPC }}",
         "RemediationRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/DEV-SO0111-EnableVPCFlowLogs-remediationRole"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Removed rules on default security group",
         "UpdatedBy": "ASR-SC_2.0.0_EC2.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_EC2.6",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/EC2.6/Resource"
   },
   "Condition": "ControlRunbooksEnableEC26ConditionF1F880B0"
  },
  "ControlRunbooksEC277719A4CD": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.7\n## What does this document do?\nThis document enables `EBS Encryption by default` for an AWS account in the current region by calling another SSM document\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP EC2.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-7)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.7 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableEbsEncryptionByDefault",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "EC2.7"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableEbsEncryptionByDefault",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enabled EBS encryption by default",
         "UpdatedBy": "ASR-SC_2.0.0_EC2.7"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_EC2.7",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/EC2.7/Resource"
   },
   "Condition": "ControlRunbooksEnableEC27ConditionC77CF056"
  },
  "ControlRunbooksEC213D7C9C1EB": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-PCI_3.2.1_EC2.5\n\n## What does this document do?\nRemoves public access to remove server administrative ports from an EC2 Security Group\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Output of AWS-DisablePublicAccessForSecurityGroup runbook.\n\n## Documentation Links\n* [PCI v3.2.1 EC2.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-5)\n* [CIS v1.2.0 4.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-4.1)\n* [CIS v1.2.0 4.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-4.2)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.13 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-DisablePublicAccessForSecurityGroup",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:security-group\\/(sg-[a-f\\d]{8,17})$",
         "expected_control_id": [
          "EC2.13",
          "EC2.14"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "GroupId",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "AWS-DisablePublicAccessForSecurityGroup",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "GroupId": "{{ ParseInput.GroupId }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Disabled public access to administrative ports in the security group {{ ParseInput.GroupId }}.",
         "UpdatedBy": "ASR-SC_2.0.0_EC2.13"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_EC2.13",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/EC2.13/Resource"
   },
   "Condition": "ControlRunbooksEnableEC213Condition567EA275"
  },
  "ControlRunbooksEC2153B43E7A8": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.15\n \n## What does this document do?\nThis document disables auto assignment of public IP addresses on a subnet.\n \n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n \n## Output Parameters\n* Remediation.Output\n \n## Documentation Links\n* [AFSBP v1.0.0 EC2.15](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-15)",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.15 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-DisablePublicIPAutoAssign",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "EC2.15"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "SubnetARN",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-DisablePublicIPAutoAssign",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "SubnetARN": "{{ ParseInput.SubnetARN }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Disabled public IP auto assignment for subnet.",
         "UpdatedBy": "ASR-SC_2.0.0_EC2.15"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_EC2.15",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/EC2.15/Resource"
   },
   "Condition": "ControlRunbooksEnableEC215Condition52A7DE4B"
  },
  "ControlRunbooksIAM3DC25477E": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_IAM.3\n\n## What does this document do?\nThis document disables active keys that have not been rotated for more than 90 days. Note that this remediation is **DISRUPTIVE**.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 IAM.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-3)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "MaxCredentialUsageAge": {
       "type": "String",
       "description": "(Required) Maximum number of days a key can be unrotated. The default value is 90 days.",
       "default": "90",
       "allowedPattern": "^(?:[1-9]\\d{0,3}|10000)$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the IAM.3 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-RevokeUnrotatedKeys",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):iam::\\d{12}:user(?:(?:\\u002F)|(?:\\u002F[\\u0021-\\u007F]{1,510}\\u002F))([\\w+=,.@-]{1,64})$",
         "expected_control_id": [
          "IAM.3"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "IAMUser",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "IAMResourceId",
         "Selector": "$.Payload.details.AwsIamUser.UserId",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-RevokeUnrotatedKeys",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "IAMResourceId": "{{ ParseInput.IAMResourceId }}",
         "MaxCredentialUsageAge": "{{ MaxCredentialUsageAge }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Deactivated unrotated keys for {{ ParseInput.IAMUser }}.",
         "UpdatedBy": "ASR-SC_2.0.0_IAM.3"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_IAM.3",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/IAM.3/Resource"
   },
   "Condition": "ControlRunbooksEnableIAM3Condition3AA0E892"
  },
  "ControlRunbooksIAM70A808F7C": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_IAM.7\n\n## What does this document do?\nThis document establishes a default password policy.\n\n## Security Standards and Controls\n* AFSBP IAM.7\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP IAM.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-7)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the IAM.7 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-SetIAMPasswordPolicy",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "IAM.7",
          "IAM.11",
          "IAM.12",
          "IAM.13",
          "IAM.14",
          "IAM.15",
          "IAM.16",
          "IAM.17"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-SetIAMPasswordPolicy",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "AllowUsersToChangePassword": true,
         "HardExpiry": true,
         "MaxPasswordAge": 90,
         "MinimumPasswordLength": 14,
         "RequireSymbols": true,
         "RequireNumbers": true,
         "RequireUppercaseCharacters": true,
         "RequireLowercaseCharacters": true,
         "PasswordReusePrevention": 24
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Established a baseline password policy using the ASR-SetIAMPasswordPolicy runbook.",
         "UpdatedBy": "ASR-SC_2.0.0_IAM.7"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_IAM.7",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/IAM.7/Resource"
   },
   "Condition": "ControlRunbooksEnableIAM7ConditionDF8E776B"
  },
  "ControlRunbooksIAM8632E03ED": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_IAM.8\n\n## What does this document do?\nThis document ensures that credentials unused for 90 days or greater are disabled.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Output of remediation runbook\n\nSEE AWSConfigRemediation-RevokeUnusedIAMUserCredentials\n\n## Documentation Links\n* [AFSBP IAM.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-8)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the IAM.8 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-RevokeUnusedIAMUserCredentials",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "IAM.8"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "IAMResourceId",
         "Selector": "$.Payload.details.AwsIamUser.UserId",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-RevokeUnusedIAMUserCredentials",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "IAMResourceId": "{{ ParseInput.IAMResourceId }}",
         "MaxCredentialUsageAge": "90"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Deactivated unused keys and expired logins using the ASR-RevokeUnusedIAMUserCredentials runbook.",
         "UpdatedBy": "ASR-SC_2.0.0_IAM.8"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_IAM.8",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/IAM.8/Resource"
   },
   "Condition": "ControlRunbooksEnableIAM8Condition9CA5CB4B"
  },
  "ControlRunbooksIAM18ACE62321": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-CIS_1.2.0_1.20\n\n## What does this document do?\nCreates a support role to allow AWS Support access.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Output of CreateRole API.\n\n## Documentation Links\n* [CIS v1.2.0 1.20](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.20)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the IAM.18 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-CreateIAMSupportRole",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "IAM.18"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-CreateIAMSupportRole",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Create an IAM role to allow authorized users to manage incidents with AWS Support using the ASR-CreateIAMSupportRole runbook.",
         "UpdatedBy": "ASR-SC_2.0.0_IAM.18"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_IAM.18",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/IAM.18/Resource"
   },
   "Condition": "ControlRunbooksEnableIAM18ConditionC6288150"
  },
  "ControlRunbooksKMS41A22BB8D": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-CIS_1.2.0_2.8\n\n## What does this document do?\nEnables rotation for customer-managed KMS keys.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Remediation results\n\n## Documentation Links\n* [CIS v1.2.0 2.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.8)\n* [PCI v3.2.1 PCI.KMS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-kms-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the KMS.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableKeyRotation",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:key\\/([A-Za-z0-9-]{36})$",
         "expected_control_id": [
          "KMS.4"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "KeyId",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableKeyRotation",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "KeyId": "{{ ParseInput.KeyId }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enabled KMS Customer Managed Key rotation for {{ ParseInput.KeyId }}",
         "UpdatedBy": "ASR-SC_2.0.0_KMS.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_KMS.4",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/KMS.4/Resource"
   },
   "Condition": "ControlRunbooksEnableKMS4Condition710C0C5C"
  },
  "ControlRunbooksLambda1F6ECACF8": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_Lambda.1\n\n## What does this document do?\nThis document removes the public resource policy. A public resource policy\ncontains a principal \"*\" or AWS: \"*\", which allows public access to the\nfunction. The remediation is to remove the SID of the public policy.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP Lambda.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-lambda-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Lambda.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-RemoveLambdaPublicAccess",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-us-gov|aws-cn):lambda:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:function:([a-zA-Z0-9\\-_]{1,64})$",
         "expected_control_id": [
          "Lambda.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FunctionName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-RemoveLambdaPublicAccess",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "FunctionName": "{{ ParseInput.FunctionName }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Lamdba {{ ParseInput.FunctionName }} policy updated to remove public access",
         "UpdatedBy": "ASR-SC_2.0.0_Lambda.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_Lambda.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/Lambda.1/Resource"
   },
   "Condition": "ControlRunbooksEnableLambda1Condition077CECAF"
  },
  "ControlRunbooksRDS1D73701E9": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.1\n## What does this document do?\nThis document changes public RDS snapshot to private\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP RDS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-MakeRDSSnapshotPrivate",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(cluster-snapshot|snapshot):([a-zA-Z](?:[0-9a-zA-Z]+-)*[0-9a-zA-Z]+)$",
         "expected_control_id": [
          "RDS.1"
         ],
         "resource_index": 2
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "DBSnapshotId",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "DBSnapshotType",
         "Selector": "$.Payload.matches[0]",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-MakeRDSSnapshotPrivate",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "DBSnapshotId": "{{ ParseInput.DBSnapshotId }}",
         "DBSnapshotType": "{{ ParseInput.DBSnapshotType }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "RDS DB Snapshot modified to private",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.1/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS1ConditionFAE5B7EA"
  },
  "ControlRunbooksRDS2FBE04686": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.2\n## What does this document do?\nThis document disables public access to RDS instances by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP RDS.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-2)\n\n## Troubleshooting\n* ModifyDBInstance isn't supported for a DB instance in a Multi-AZ DB Cluster.\n - This remediation will not work on an instance within a MySQL or PostgreSQL Multi-AZ Cluster due to limitations with the RDS API. \n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-DisablePublicAccessToRDSInstance",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:db:((?!.*--.*)(?!.*-$)[a-z][a-z0-9-]{0,62})$",
         "expected_control_id": [
          "RDS.2"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "DbiResourceId",
         "Selector": "$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-DisablePublicAccessToRDSInstance",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "DbiResourceId": "{{ ParseInput.DbiResourceId }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Disabled public access to RDS instance",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.2",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.2/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS2Condition4FD00FE6"
  },
  "ControlRunbooksRDS4C82F2410": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.4\n\n## What does this document do?\nThis document encrypts an unencrypted RDS snapshot by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n* KMSKeyId: (Optional) ID, ARN or Alias for the AWS KMS Customer-Managed Key (CMK) to use to encrypt the snapshot.\n\n## Documentation Links\n* [AFSBP RDS.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-4)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "KMSKeyId": {
       "type": "String",
       "description": "(Optional) ID, ARN or Alias for the AWS KMS Customer-Managed Key (CMK) to use to encrypt the snapshot.",
       "default": "alias/aws/rds",
       "allowedPattern": "^(?:arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:)?(?:(?:alias\\/[A-Za-z0-9/_-]+)|(?:key\\/(?:[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})))$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EncryptRDSSnapshot",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:((?:cluster-)?snapshot|dbclustersnapshot):((?:rds:)?((?!.*--.*)(?!.*-$)[a-zA-Z][a-zA-Z0-9-]{0,254}))$",
         "expected_control_id": [
          "RDS.4"
         ],
         "resource_index": 2
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "SourceDBSnapshotIdentifier",
         "Selector": "$.Payload.matches[1]",
         "Type": "String"
        },
        {
         "Name": "SourceDBSnapshotIdentifierNoPrefix",
         "Selector": "$.Payload.matches[2]",
         "Type": "String"
        },
        {
         "Name": "DBSnapshotType",
         "Selector": "$.Payload.matches[0]",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EncryptRDSSnapshot",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "SourceDBSnapshotIdentifier": "{{ ParseInput.SourceDBSnapshotIdentifier }}",
         "TargetDBSnapshotIdentifier": "{{ ParseInput.SourceDBSnapshotIdentifierNoPrefix }}-encrypted",
         "DBSnapshotType": "{{ ParseInput.DBSnapshotType }}",
         "KmsKeyId": "{{ KMSKeyId }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Encrypted RDS snapshot",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.4",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.4/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS4Condition2E89346E"
  },
  "ControlRunbooksRDS5CECD9314": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.RDS.5\n\n## What does this document do?\nThis document configures an RDS DB instance for multiple Availability Zones by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP RDS.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-5)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.5 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableMultiAZOnRDSInstance",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.5"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "DbiResourceId",
         "Selector": "$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableMultiAZOnRDSInstance",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "DbiResourceId": "{{ ParseInput.DbiResourceId }}",
         "ApplyImmediately": true
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Configured RDS cluster for multiple Availability Zones",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.5"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.5",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.5/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS5ConditionEC2574C3"
  },
  "ControlRunbooksRDS6082B0D6B": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.6\n\n## What does this document do?\nThis document enables `Enhanced Monitoring` on a given Amazon RDS instance by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* VerifyRemediation.Output - The standard HTTP response from the ModifyDBInstance API.\n## Documentation Links\n\n* [AFSBP RDS.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-6)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.6 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableEnhancedMonitoringOnRDSInstance",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.6"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "DbiResourceId",
         "Selector": "$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId",
         "Type": "String"
        }
       ]
      },
      {
       "name": "GetMonitoringRoleArn",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "iam",
        "Api": "GetRole",
        "RoleName": "DEV-SO0111-RDSMonitoring-remediationRole"
       },
       "outputs": [
        {
         "Name": "Arn",
         "Selector": "$.Role.Arn",
         "Type": "String"
        }
       ],
       "timeoutSeconds": 600
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableEnhancedMonitoringOnRDSInstance",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "ResourceId": "{{ ParseInput.DbiResourceId }}",
         "MonitoringRoleArn": "{{ GetMonitoringRoleArn.Arn }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enhanced Monitoring enabled on RDS DB cluster",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.6",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.6/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS6Condition4A60A39B"
  },
  "ControlRunbooksRDS715C0A01A": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.7\n\n## What does this document do?\nThis document enables `Deletion Protection` on a given Amazon RDS cluster by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - The standard HTTP response from the ModifyDBCluster API.\n\n## Documentation Links\n* [AFSBP RDS.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-7)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.7 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableRDSClusterDeletionProtection",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.7"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "DbiResourceId",
         "Selector": "$.Payload.details.AwsRdsDbCluster.DbClusterResourceId",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableRDSClusterDeletionProtection",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "ClusterId": "{{ ParseInput.DbiResourceId }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Deletion protection enabled on RDS DB cluster",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.7"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.7",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.7/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS7ConditionE53509B0"
  },
  "ControlRunbooksRDS89256480A": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.RDS.8\n\n## What does this document do?\nThis document enables `Deletion Protection` on a given Amazon RDS cluster by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP RDS.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-8)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.8 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableRDSInstanceDeletionProtection",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.8"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "DbiResourceId",
         "Selector": "$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableRDSInstanceDeletionProtection",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "DbInstanceResourceId": "{{ ParseInput.DbiResourceId }}",
         "ApplyImmediately": true
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enabled deletion protection on RDS instance",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.8"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.8",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.8/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS8Condition8F460AB5"
  },
  "ControlRunbooksRDS13FCEA51BD": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.13\n\n## What does this document do?\nThis document enables `Auto minor version upgrade` on a given Amazon RDS instance by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - The standard HTTP response from the ModifyDBInstance API.\n\n## Documentation Links\n* [AFSBP RDS.13](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-13)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.13 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableMinorVersionUpgradeOnRDSDBInstance",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.13"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "DBInstanceIdentifier",
         "Selector": "$.Payload.resource.Details.AwsRdsDbInstance.DBInstanceIdentifier",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableMinorVersionUpgradeOnRDSDBInstance",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "DBInstanceIdentifier": "{{ ParseInput.DBInstanceIdentifier }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Minor Version enabled on the RDS Instance or Multi-AZ RDS Cluster.",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.13"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.13",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.13/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS13Condition0E8A44B3"
  },
  "ControlRunbooksRDS16EB04DCBF": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.16\n\n## What does this document do?\nThis document enables `Copy tags to snapshots` on a given Amazon RDS cluster by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - The standard HTTP response from the ModifyDBCluster API.\n\n## Documentation Links\n* [AFSBP RDS.16](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-16)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.16 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableCopyTagsToSnapshotOnRDSCluster",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.16"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "DbiResourceId",
         "Selector": "$.Payload.details.AwsRdsDbCluster.DbClusterResourceId",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableCopyTagsToSnapshotOnRDSCluster",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "DbClusterResourceId": "{{ ParseInput.DbiResourceId }}",
         "ApplyImmediately": true
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Copy Tags to Snapshots enabled on RDS DB cluster",
         "UpdatedBy": "ASR-SC_2.0.0_RDS.16"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_RDS.16",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/RDS.16/Resource"
   },
   "Condition": "ControlRunbooksEnableRDS16ConditionCB5C3E8F"
  },
  "ControlRunbooksRedshift1789871EB": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_Redshift.1\n\n## What does this document do?\nThis document disables public access to a Redshift cluster by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP Redshift.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Redshift.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-DisablePublicAccessToRedshiftCluster",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$",
         "expected_control_id": [
          "Redshift.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "ClusterIdentifier",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-DisablePublicAccessToRedshiftCluster",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "ClusterIdentifier": "{{ ParseInput.ClusterIdentifier }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Disabled public access to Redshift cluster",
         "UpdatedBy": "ASR-SC_2.0.0_Redshift.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_Redshift.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/Redshift.1/Resource"
   },
   "Condition": "ControlRunbooksEnableRedshift1Condition3449D560"
  },
  "ControlRunbooksRedshift3106C10FF": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_Redshift.3\n\n## What does this document do?\nThis document enables automatic snapshots on a Redshift cluster by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP Redshift.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-3)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Redshift.3 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableAutomaticSnapshotsOnRedshiftCluster",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$",
         "expected_control_id": [
          "Redshift.3"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "ClusterIdentifier",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RetentionPeriodSerialized",
         "Selector": "$.Payload.aws_config_rule.InputParameters",
         "Type": "String"
        }
       ]
      },
      {
       "name": "ExtractConfigRuleParameters",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "event_handler",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\n\ndef event_handler(event, _):\n    try:\n        return json.loads(event['SerializedJson'])\n    except Exception as e:\n        print(e)\n        exit('Failed to deserialize data')\n",
        "InputPayload": {
         "SerializedJson": "{{ ParseInput.RetentionPeriodSerialized }}"
        }
       },
       "outputs": [
        {
         "Name": "MinRetentionPeriod",
         "Selector": "$.Payload.MinRetentionPeriod",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableAutomaticSnapshotsOnRedshiftCluster",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "ClusterIdentifier": "{{ ParseInput.ClusterIdentifier }}",
         "MinRetentionPeriod": "{{ ExtractConfigRuleParameters.MinRetentionPeriod }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enabled automatic snapshots on Redshift cluster",
         "UpdatedBy": "ASR-SC_2.0.0_Redshift.3"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_Redshift.3",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/Redshift.3/Resource"
   },
   "Condition": "ControlRunbooksEnableRedshift3ConditionC65BAEF6"
  },
  "ControlRunbooksRedshift475A78168": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_Redshift.4\n\n## What does this document do?\nThis document disables public access to a Redshift cluster by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP Redshift.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Redshift.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableRedshiftClusterAuditLogging",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$",
         "expected_control_id": [
          "Redshift.4"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "ClusterIdentifier",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RetentionPeriodSerialized",
         "Selector": "$.Payload.aws_config_rule.InputParameters",
         "Type": "String"
        }
       ]
      },
      {
       "name": "CheckIfSSMParameterWithS3BucketNameIsAvailable",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "check_for_s3_bucket_name",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef check_for_s3_bucket_name(_, __):\n    try:\n        ssm = connect_to_ssm(\n            Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n            )\n        )\n        s3_bucket_name_for_audit_logging = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/afsbp/1.0.0/REDSHIFT.4/S3BucketNameForAuditLogging'\n        )['Parameter'].get('Value', 'unknown')\n    except Exception:\n        return {\n            \"s3_bucket_name_for_redshift_audit_logging\": \"NOT_AVAILABLE\"\n        }\n    return {\n        \"s3_bucket_name_for_redshift_audit_logging\": s3_bucket_name_for_audit_logging\n    }\n",
        "InputPayload": {
         "SerializedJson": "{{ ParseInput.RetentionPeriodSerialized }}"
        }
       },
       "outputs": [
        {
         "Name": "BucketName",
         "Selector": "$.Payload.s3_bucket_name_for_redshift_audit_logging",
         "Type": "String"
        }
       ]
      },
      {
       "name": "ValidateIfS3BucketNameIsConfigured",
       "action": "aws:branch",
       "inputs": {
        "Choices": [
         {
          "NextStep": "UpdateFindingThatS3BucketNameIsNotConfigured",
          "Variable": "{{ CheckIfSSMParameterWithS3BucketNameIsAvailable.BucketName }}",
          "StringEquals": "NOT_AVAILABLE"
         }
        ],
        "Default": "Remediation"
       }
      },
      {
       "description": "Abort remediation as s3 bucket name is unavailable.",
       "name": "UpdateFindingThatS3BucketNameIsNotConfigured",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Remediation failed the s3 bucket name is not available, review the cloudformation template and select the option Yes for create redshift.4 s3 bucket cloudformation parameter.",
         "UpdatedBy": "ASR-SC_2.0.0_Redshift.4"
        },
        "Workflow": {
         "Status": "NOTIFIED"
        }
       },
       "isEnd": true
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableRedshiftClusterAuditLogging",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "ClusterIdentifier": "{{ ParseInput.ClusterIdentifier }}",
         "BucketName": "{{ CheckIfSSMParameterWithS3BucketNameIsAvailable.BucketName }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enabled Audit logging for the Redshift cluster.",
         "UpdatedBy": "ASR-SC_2.0.0_Redshift.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_Redshift.4",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/Redshift.4/Resource"
   },
   "Condition": "ControlRunbooksEnableRedshift4Condition2377F6B5"
  },
  "ControlRunbooksRedshift658631424": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_Redshift.6\n\n## What does this document do?\nThis document enables automatic version upgrade on a Redshift cluster by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP Redshift.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-6)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Redshift.6 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableAutomaticVersionUpgradeOnRedshiftCluster",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$",
         "expected_control_id": [
          "Redshift.6"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "ClusterIdentifier",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "AllowVersionUpgradeSerialized",
         "Selector": "$.Payload.aws_config_rule.InputParameters",
         "Type": "String"
        }
       ]
      },
      {
       "name": "ExtractConfigRuleParameters",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "event_handler",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\n\ndef event_handler(event, _):\n    try:\n        return json.loads(event['SerializedJson'])\n    except Exception as e:\n        print(e)\n        exit('Failed to deserialize data')\n",
        "InputPayload": {
         "SerializedJson": "{{ ParseInput.AllowVersionUpgradeSerialized }}"
        }
       },
       "outputs": [
        {
         "Name": "AllowVersionUpgrade",
         "Selector": "$.Payload.allowVersionUpgrade",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableAutomaticVersionUpgradeOnRedshiftCluster",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "ClusterIdentifier": "{{ ParseInput.ClusterIdentifier }}",
         "AllowVersionUpgrade": "{{ ExtractConfigRuleParameters.AllowVersionUpgrade }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enabled automatic version upgrade on Redshift cluster",
         "UpdatedBy": "ASR-SC_2.0.0_Redshift.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_Redshift.6",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/Redshift.6/Resource"
   },
   "Condition": "ControlRunbooksEnableRedshift6Condition5A51FC97"
  },
  "ControlRunbooksS311C5AAD45": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.1\n\n## What does this document do?\nThis document blocks public access to all buckets by default at the account level.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-ConfigureS3PublicAccessBlock",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "S3.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-ConfigureS3PublicAccessBlock",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "AccountId": "{{ ParseInput.RemediationAccount }}",
         "RestrictPublicBuckets": true,
         "BlockPublicAcls": true,
         "IgnorePublicAcls": true,
         "BlockPublicPolicy": true
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Configured the account to block public S3 access.",
         "UpdatedBy": "ASR-SC_2.0.0_S3.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_S3.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/S3.1/Resource"
   },
   "Condition": "ControlRunbooksEnableS31Condition25C33B3F"
  },
  "ControlRunbooksS3260D6E897": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.2\n\n## What does this document do?\nThis document blocks all public access to an S3 bucket.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-2)\n* [AFSBP v1.0.0 S3.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-3)\n* [AFSBP v1.0.0 S3.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-8)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-ConfigureS3BucketPublicAccessBlock",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "S3.2",
          "S3.3",
          "S3.8"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-ConfigureS3BucketPublicAccessBlock",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "BucketName": "{{ ParseInput.BucketName }}",
         "RestrictPublicBuckets": true,
         "BlockPublicAcls": true,
         "IgnorePublicAcls": true,
         "BlockPublicPolicy": true
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Disabled public access to S3 bucket.",
         "UpdatedBy": "ASR-SC_2.0.0_S3.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_S3.2",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/S3.2/Resource"
   },
   "Condition": "ControlRunbooksEnableS32ConditionD6F8CCE9"
  },
  "ControlRunbooksS34F82DA9F1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.4\n\n## What does this document do?\nThis document enables AES-256 as the default encryption for an S3 bucket.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-4)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "KmsKeyAlias": {
       "type": "String",
       "description": "(Required) KMS Customer-Managed Key (CMK) alias or the default value which is created in the SSM parameter at solution deployment (default-s3-encryption) is used to identify that the s3 bucket encryption value should be set to AES-256.",
       "default": "{{ssm:/Solutions/SO0111/afsbp/1.0.0/S3.4/KmsKeyAlias}}",
       "allowedPattern": "^$|^[a-zA-Z0-9/_-]{1,256}$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableDefaultEncryptionS3",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "S3.4"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableDefaultEncryptionS3",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "BucketName": "{{ ParseInput.BucketName }}",
         "AccountId": "{{ ParseInput.RemediationAccount }}",
         "KmsKeyAlias": "{{ KmsKeyAlias }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Enabled default encryption for {{ ParseInput.BucketName }}",
         "UpdatedBy": "ASR-SC_2.0.0_S3.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_S3.4",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/S3.4/Resource"
   },
   "Condition": "ControlRunbooksEnableS34ConditionC23F6623"
  },
  "ControlRunbooksS356959B795": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.5\n\n## What does this document do?\nThis document adds a bucket policy to restrict internet access to https only.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-5)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.5 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-SetSSLBucketPolicy",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "S3.5"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-SetSSLBucketPolicy",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "BucketName": "{{ ParseInput.BucketName }}",
         "AccountId": "{{ ParseInput.RemediationAccount }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Added SSL-only access policy to S3 bucket.",
         "UpdatedBy": "ASR-SC_2.0.0_S3.5"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_S3.5",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/S3.5/Resource"
   },
   "Condition": "ControlRunbooksEnableS35ConditionD5E024B6"
  },
  "ControlRunbooksS360762680A": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.6\n\n## What does this document do?\nThis document restricts cross-account access to a bucket in the local account.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-6)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.6 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-S3BlockDenylist",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "S3.6"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "DenyListSerialized",
         "Selector": "$.Payload.aws_config_rule.InputParameters",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "ExtractSensitiveApis",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "runbook_handler",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\n\ndef runbook_handler(event, _):\n    try:\n        deserialized = json.loads(event['SerializedList'])\n        if 'blacklistedActionPattern' in deserialized:\n            return deserialized['blacklistedActionPattern'] # Returns comma-delimited list in a string\n        else:\n            exit('Missing blacklistedActionPattern in AWS Config data')\n    except Exception as e:\n        print(e)\n        exit('Failed getting comma-delimited string list of sensitive API calls input data')\n",
        "InputPayload": {
         "SerializedList": "{{ ParseInput.DenyListSerialized }}"
        }
       },
       "outputs": [
        {
         "Name": "ListOfApis",
         "Selector": "$.Payload",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-S3BlockDenylist",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "BucketName": "{{ ParseInput.BucketName }}",
         "DenyList": "{{ ExtractSensitiveApis.ListOfApis }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Added explicit deny for sensitive bucket access from another account.",
         "UpdatedBy": "ASR-SC_2.0.0_S3.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_S3.6",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait8"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/S3.6/Resource"
   },
   "Condition": "ControlRunbooksEnableS36ConditionD22273E2"
  },
  "ControlRunbooksSQS173AA7C81": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_SQS.1\n\n## What does this document do?\nThis document enables encryption at rest using AWS KMS for SQS Queues.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 SQS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-sqs-1)\n",
     "schemaVersion": "0.3",
     "parameters": {
      "KmsKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias\\/[A-Za-z0-9/-_])|(?:key\\/(?:[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})))$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the SQS.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableEncryptionForSQSQueue",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "^arn:(?:aws|aws-us-gov|aws-cn):sqs:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:([a-zA-Z0-9_-]{1,80}(?:\\.fifo)?)$",
         "expected_control_id": [
          "SQS.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "SQSQueueName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableEncryptionForSQSQueue",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "SQSQueueName": "{{ ParseInput.SQSQueueName }}",
         "KmsKeyArn": "{{ KmsKeyArn }}",
         "SNSTopicArn": "{{ ParseInput.SQSQueueName }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Encryption enabled on SQS Topic",
         "UpdatedBy": "ASR-SC_2.0.0_SQS.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_SQS.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait8"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/SQS.1/Resource"
   },
   "Condition": "ControlRunbooksEnableSQS1Condition3065B4F2"
  },
  "ControlRunbooksSNS145784CBB": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "  ### Document Name - ASR-AFSBP_1.0.0_SNS.1\n\n  ## What does this document do?\n  This document enables encryption at rest using AWS KMS for SNS topics.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [AFSBP v1.0.0 SNS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-sns-1)",
     "schemaVersion": "0.3",
     "parameters": {
      "KmsKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias\\/[A-Za-z0-9/-_])|(?:key\\/(?:[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12})))$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the SNS.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableEncryptionForSNSTopic",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "SNS.1"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "SNSTopicArn",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableEncryptionForSNSTopic",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "SNSTopicArn": "{{ ParseInput.SNSTopicArn }}",
         "KmsKeyArn": "{{ KmsKeyArn }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Encryption enabled on SNS Topic",
         "UpdatedBy": "ASR-SC_2.0.0_SNS.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_SNS.1",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait8"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/SNS.1/Resource"
   },
   "Condition": "ControlRunbooksEnableSNS1Condition7720D1CC"
  },
  "ControlRunbooksSNS2112179CC": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "  ### Document Name - ASR-AFSBP_1.0.0_SNS.2\n\n  ## What does this document do?\n  This document enables logging of delivery status for notification messages sent to a topic.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [AFSBP v1.0.0 SNS.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-sns-2)",
     "schemaVersion": "0.3",
     "parameters": {
      "LoggingRole": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/DeliveryStatusLoggingRole}}",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the SNS.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role\\/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableDeliveryLoggingForSNSTopic",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "Handler": "parse_event",
        "Runtime": "python3.8",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }\n",
        "InputPayload": {
         "Finding": "{{ Finding }}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "SNS.2"
         ]
        }
       },
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "SNSTopicArn",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableDeliveryLoggingForSNSTopic",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/{{ RemediationRoleName }}",
         "SNSTopicArn": "{{ ParseInput.SNSTopicArn }}",
         "LoggingRole": "{{ LoggingRole }}"
        },
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ]
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Delivery Status Logging enabled on SNS Topic",
         "UpdatedBy": "ASR-SC_2.0.0_SNS.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-SC_2.0.0_SNS.2",
    "Tags": [
     {
      "Key": "CdkGenerated",
      "Value": "true"
     }
    ],
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait8"
   ],
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/ControlRunbooks/SNS.2/Resource"
   },
   "Condition": "ControlRunbooksEnableSNS2Condition69621468"
  },
  "CreateWait0": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "77fd72f50243c942cc3d634e48b099c14da56e9193062ac7801a93c61f95f134"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait0/Default"
   }
  },
  "DeletWait0": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "77fd72f50243c942cc3d634e48b099c14da56e9193062ac7801a93c61f95f134"
   },
   "DependsOn": [
    "ControlRunbooksAutoScaling1BA109277",
    "ControlRunbooksCloudFormation12CB945DB",
    "ControlRunbooksCloudTrail1B15F1A13",
    "ControlRunbooksCloudTrail2979D0B5D",
    "ControlRunbooksCloudTrail4057F669F"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait0/Default"
   }
  },
  "CreateWait1": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "00c6dcb4b04ef1c04b2cb87e62d683383ab5f314d81add4b12935999bd635509"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait1/Default"
   }
  },
  "DeletWait1": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "00c6dcb4b04ef1c04b2cb87e62d683383ab5f314d81add4b12935999bd635509"
   },
   "DependsOn": [
    "ControlRunbooksCloudTrail54F5ED8E4",
    "ControlRunbooksCloudTrail6526C5643",
    "ControlRunbooksCloudTrail7C6D85038",
    "ControlRunbooksCloudWatch1A05F543A",
    "ControlRunbooksCodeBuild2A2751671",
    "DeletWait0"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait1/Default"
   }
  },
  "CreateWait2": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "604719f849229698ecc7249c5f1cfc43d28484382cfca52c5c27f76418a85f61"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait2/Default"
   }
  },
  "DeletWait2": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "604719f849229698ecc7249c5f1cfc43d28484382cfca52c5c27f76418a85f61"
   },
   "DependsOn": [
    "ControlRunbooksConfig1512B566F",
    "ControlRunbooksEC214D3BB404",
    "ControlRunbooksEC22ED852ADF",
    "ControlRunbooksEC267E3087AE",
    "ControlRunbooksEC277719A4CD",
    "DeletWait1"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait2/Default"
   }
  },
  "CreateWait3": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "5264f97777fbe7a0e09c895cd02729bd905701a9605748af7db380d9e00ce410"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait3/Default"
   }
  },
  "DeletWait3": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "5264f97777fbe7a0e09c895cd02729bd905701a9605748af7db380d9e00ce410"
   },
   "DependsOn": [
    "ControlRunbooksEC213D7C9C1EB",
    "ControlRunbooksEC2153B43E7A8",
    "ControlRunbooksIAM3DC25477E",
    "ControlRunbooksIAM70A808F7C",
    "ControlRunbooksIAM8632E03ED",
    "DeletWait2"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait3/Default"
   }
  },
  "CreateWait4": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "2de873e0c825f84b7414bf590f152c47022a602b8306ae28ceee889dfdff34ee"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait4/Default"
   }
  },
  "DeletWait4": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "2de873e0c825f84b7414bf590f152c47022a602b8306ae28ceee889dfdff34ee"
   },
   "DependsOn": [
    "ControlRunbooksIAM18ACE62321",
    "ControlRunbooksKMS41A22BB8D",
    "ControlRunbooksLambda1F6ECACF8",
    "ControlRunbooksRDS1D73701E9",
    "ControlRunbooksRDS2FBE04686",
    "DeletWait3"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait4/Default"
   }
  },
  "CreateWait5": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "32b8846192f739e4de7ef89d20fb222c74b02c478ad724f6a84244b624f19bb7"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait5/Default"
   }
  },
  "DeletWait5": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "32b8846192f739e4de7ef89d20fb222c74b02c478ad724f6a84244b624f19bb7"
   },
   "DependsOn": [
    "ControlRunbooksRDS4C82F2410",
    "ControlRunbooksRDS5CECD9314",
    "ControlRunbooksRDS6082B0D6B",
    "ControlRunbooksRDS715C0A01A",
    "ControlRunbooksRDS89256480A",
    "DeletWait4"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait5/Default"
   }
  },
  "CreateWait6": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "245559720e421ca07de29ca523ef6c4bc90e51c31ecd807f75739c4973210999"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait6/Default"
   }
  },
  "DeletWait6": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "245559720e421ca07de29ca523ef6c4bc90e51c31ecd807f75739c4973210999"
   },
   "DependsOn": [
    "ControlRunbooksRDS13FCEA51BD",
    "ControlRunbooksRDS16EB04DCBF",
    "ControlRunbooksRedshift1789871EB",
    "ControlRunbooksRedshift3106C10FF",
    "ControlRunbooksRedshift475A78168",
    "DeletWait5"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait6/Default"
   }
  },
  "CreateWait7": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "9c52198f5c9d329defc9e425bb4c3b61d10c5cfafa4195547251ced3ea32ad90"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait7/Default"
   }
  },
  "DeletWait7": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "9c52198f5c9d329defc9e425bb4c3b61d10c5cfafa4195547251ced3ea32ad90"
   },
   "DependsOn": [
    "ControlRunbooksRedshift658631424",
    "ControlRunbooksS311C5AAD45",
    "ControlRunbooksS3260D6E897",
    "ControlRunbooksS34F82DA9F1",
    "ControlRunbooksS356959B795",
    "DeletWait6"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait7/Default"
   }
  },
  "CreateWait8": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "b6305db58dddb4574bf8ddbedf75dc0f246b46b085d0a4f8922ac10b4c1685c8"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/CreateWait8/Default"
   }
  },
  "DeletWait8": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "b6305db58dddb4574bf8ddbedf75dc0f246b46b085d0a4f8922ac10b4c1685c8"
   },
   "DependsOn": [
    "ControlRunbooksS360762680A",
    "ControlRunbooksSNS145784CBB",
    "ControlRunbooksSNS2112179CC",
    "ControlRunbooksSQS173AA7C81",
    "DeletWait7"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "SCMemberStack/DeletWait8/Default"
   }
  }
 },
 "Conditions": {
  "ControlRunbooksEnableAutoScaling1ConditionD5DF4981": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableAutoScaling1851AF8B0"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCloudFormation1ConditionD8D32097": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCloudFormation1B75725BB"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCloudTrail1ConditionB7EBAA86": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCloudTrail1F0F927F7"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCloudTrail2ConditionC182A10F": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCloudTrail28CC248AB"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCloudTrail4Condition587734A2": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCloudTrail4040C6EAB"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCloudTrail5Condition17B6B536": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCloudTrail52CBFD019"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCloudTrail6Condition486CC2C3": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCloudTrail63394AC2B"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCloudTrail7ConditionA4FF88B2": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCloudTrail7FFC8DAB9"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCloudWatch1ConditionAB0DF2E5": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCloudWatch19BE65F2B"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableCodeBuild2ConditionB01F473D": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableCodeBuild26FB6E539"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableConfig1Condition8CEB8627": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableConfig19F6E6FE3"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableEC21ConditionD4F1277B": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableEC21395C7891"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableEC22ConditionB9E0D42E": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableEC22F9B66A60"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableEC26ConditionF1F880B0": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableEC265685AB83"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableEC27ConditionC77CF056": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableEC27108F6303"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableEC213Condition567EA275": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableEC21349FA0A79"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableEC215Condition52A7DE4B": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableEC215DA64A549"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableIAM3Condition3AA0E892": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableIAM35D05519D"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableIAM7ConditionDF8E776B": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableIAM766CB4E0A"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableIAM8Condition9CA5CB4B": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableIAM834577BE3"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableIAM18ConditionC6288150": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableIAM18A4548D88"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableKMS4Condition710C0C5C": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableKMS415F4485B"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableLambda1Condition077CECAF": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableLambda11AAE99FF"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS1ConditionFAE5B7EA": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS18380A289"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS2Condition4FD00FE6": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS2004A67EB"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS4Condition2E89346E": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS4E2A98B6D"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS5ConditionEC2574C3": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS59E051E8F"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS6Condition4A60A39B": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS6C46B2207"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS7ConditionE53509B0": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS7CEA605AE"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS8Condition8F460AB5": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS8FBE41D2B"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS13Condition0E8A44B3": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS13F10477DD"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRDS16ConditionCB5C3E8F": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRDS16F428962C"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRedshift1Condition3449D560": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRedshift1E5BFAC24"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRedshift3ConditionC65BAEF6": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRedshift39346F065"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRedshift4Condition2377F6B5": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRedshift40FBDF0D8"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableRedshift6Condition5A51FC97": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableRedshift648AC3FBB"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableS31Condition25C33B3F": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableS3116A23B93"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableS32ConditionD6F8CCE9": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableS325CF1F81C"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableS34ConditionC23F6623": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableS348078AE21"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableS35ConditionD5E024B6": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableS35B965D7F6"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableS36ConditionD22273E2": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableS36B92F84BB"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableSQS1Condition3065B4F2": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableSQS1A400C913"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableSNS1Condition7720D1CC": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableSNS1B5923950"
    },
    "Available"
   ]
  },
  "ControlRunbooksEnableSNS2Condition69621468": {
   "Fn::Equals": [
    {
     "Ref": "ControlRunbooksEnableSNS232380485"
    },
    "Available"
   ]
  }
 }
}