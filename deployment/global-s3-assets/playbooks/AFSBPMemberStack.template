{
 "Description": "(DEV-SO0111C) AWS Security Hub Automated Response & Remediation AFSBP 1.0.0 Compliance Pack - Member Account, v1.5.1",
 "AWSTemplateFormatVersion": "2010-09-09",
 "Parameters": {
  "SecHubAdminAccount": {
   "Type": "String",
   "AllowedPattern": "^\\d{12}$",
   "Description": "Admin account number"
  },
  "WaitProviderServiceToken": {
   "Type": "String"
  },
  "EnableAutoScaling1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control AutoScaling.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableCloudFormation1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudFormation.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableCloudTrail1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudTrail.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableCloudTrail2": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudTrail.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableCloudTrail4": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudTrail.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableCloudTrail5": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudTrail.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableCodeBuild2": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control CodeBuild.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableConfig1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control Config.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableEC21": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableEC22": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableEC26": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableEC27": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableEC215": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.15 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableIAM3": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control IAM.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableIAM7": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control IAM.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableIAM8": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control IAM.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableLambda1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control Lambda.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS2": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS4": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS5": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS6": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS7": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS8": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS13": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.13 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRDS16": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.16 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRedshift1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control Redshift.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRedshift3": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control Redshift.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRedshift4": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control Redshift.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableRedshift6": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control Redshift.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableS31": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableS32": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableS34": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableS35": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableS36": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableSNS1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control SNS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableSNS2": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control SNS.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnableSQS1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for AFSBP version 1.0.0 Control SQS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  }
 },
 "Conditions": {
  "EnableAutoScaling1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableAutoScaling1"
    },
    "Available"
   ]
  },
  "EnableCloudFormation1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableCloudFormation1"
    },
    "Available"
   ]
  },
  "EnableCloudTrail1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableCloudTrail1"
    },
    "Available"
   ]
  },
  "EnableCloudTrail2Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableCloudTrail2"
    },
    "Available"
   ]
  },
  "EnableCloudTrail4Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableCloudTrail4"
    },
    "Available"
   ]
  },
  "EnableCloudTrail5Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableCloudTrail5"
    },
    "Available"
   ]
  },
  "EnableCodeBuild2Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableCodeBuild2"
    },
    "Available"
   ]
  },
  "EnableConfig1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableConfig1"
    },
    "Available"
   ]
  },
  "EnableEC21Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableEC21"
    },
    "Available"
   ]
  },
  "EnableEC22Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableEC22"
    },
    "Available"
   ]
  },
  "EnableEC26Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableEC26"
    },
    "Available"
   ]
  },
  "EnableEC27Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableEC27"
    },
    "Available"
   ]
  },
  "EnableEC215Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableEC215"
    },
    "Available"
   ]
  },
  "EnableIAM3Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableIAM3"
    },
    "Available"
   ]
  },
  "EnableIAM7Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableIAM7"
    },
    "Available"
   ]
  },
  "EnableIAM8Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableIAM8"
    },
    "Available"
   ]
  },
  "EnableLambda1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableLambda1"
    },
    "Available"
   ]
  },
  "EnableRDS1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS1"
    },
    "Available"
   ]
  },
  "EnableRDS2Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS2"
    },
    "Available"
   ]
  },
  "EnableRDS4Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS4"
    },
    "Available"
   ]
  },
  "EnableRDS5Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS5"
    },
    "Available"
   ]
  },
  "EnableRDS6Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS6"
    },
    "Available"
   ]
  },
  "EnableRDS7Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS7"
    },
    "Available"
   ]
  },
  "EnableRDS8Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS8"
    },
    "Available"
   ]
  },
  "EnableRDS13Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS13"
    },
    "Available"
   ]
  },
  "EnableRDS16Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRDS16"
    },
    "Available"
   ]
  },
  "EnableRedshift1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRedshift1"
    },
    "Available"
   ]
  },
  "EnableRedshift3Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRedshift3"
    },
    "Available"
   ]
  },
  "EnableRedshift4Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRedshift4"
    },
    "Available"
   ]
  },
  "EnableRedshift6Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableRedshift6"
    },
    "Available"
   ]
  },
  "EnableS31Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableS31"
    },
    "Available"
   ]
  },
  "EnableS32Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableS32"
    },
    "Available"
   ]
  },
  "EnableS34Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableS34"
    },
    "Available"
   ]
  },
  "EnableS35Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableS35"
    },
    "Available"
   ]
  },
  "EnableS36Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableS36"
    },
    "Available"
   ]
  },
  "EnableSNS1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableSNS1"
    },
    "Available"
   ]
  },
  "EnableSNS2Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableSNS2"
    },
    "Available"
   ]
  },
  "EnableSQS1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnableSQS1"
    },
    "Available"
   ]
  }
 },
 "Resources": {
  "ControlAFSBPAutoScaling1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_AutoScaling.1\n\n## What does this document do?\nThis document enables ELB healthcheck on a given AutoScaling Group using the [UpdateAutoScalingGroup] API.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* HealthCheckGracePeriod: (Optional) Health check grace period when ELB health check is Enabled\nDefault: 30 seconds\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP AutoScaling.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-autoscaling-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the AutoScaling.1 finding"
      },
      "HealthCheckGracePeriod": {
       "type": "Integer",
       "default": 30,
       "description": "ELB Health Check Grace Period"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "AutoScalingGroupName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):autoscaling:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:autoScalingGroup:(?:[0-9a-fA-F]{8}-(?:[0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}):autoScalingGroupName/(.{1,255})$",
         "expected_control_id": [
          "AutoScaling.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableAutoScalingGroupELBHealthCheck",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "SO0111-EnableAutoScalingGroupELBHealthCheck"
         }
        ],
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAutoScalingGroupELBHealthCheck",
         "AutoScalingGroupName": "{{ParseInput.AutoScalingGroupName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "ASG health check type updated to ELB",
         "UpdatedBy": "ASR-AFSBP_1.0.0_AutoScaling.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_AutoScaling.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP AutoScaling.1"
   },
   "Condition": "EnableAutoScaling1Condition"
  },
  "ControlAFSBPCloudFormation1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudFormation.1\n\n## What does this document do?\nThis document configures an SNS topic for notifications from a CloudFormation stack by calling another document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 CloudFormation.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudformation-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudFormation.1 finding"
      }
     },
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "StackArn",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^(arn:(?:aws|aws-us-gov|aws-cn):cloudformation:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:stack/[a-zA-Z][a-zA-Z0-9-]{0,127}/[a-fA-F0-9]{8}-(?:[a-fA-F0-9]{4}-){3}[a-fA-F0-9]{12})$",
         "expected_control_id": [
          "CloudFormation.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-ConfigureSNSTopicForStack",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "SO0111-ConfigureSNSTopicForStack"
         }
        ],
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/SO0111-ConfigureSNSTopicForStack",
         "StackArn": "{{ ParseInput.StackArn }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Configured SNS topic for notifications",
         "UpdatedBy": "ASR-AFSBP_1.0.0_CloudFormation.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_CloudFormation.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP CloudFormation.1"
   },
   "Condition": "EnableCloudFormation1Condition"
  },
  "ControlAFSBPCloudTrail1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudTrail.1\n## What does this document do?\nCreates a multi-region trail with KMS encryption and enables CloudTrail\nNote: this remediation will create a NEW trail.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP CloudTrail.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.1 finding"
      },
      "KMSKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for this remediation",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      }
     },
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "region": "{{global:REGION}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "CloudTrail.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-CreateCloudTrailMultiRegionTrail",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateCloudTrailMultiRegionTrail",
         "AWSPartition": "{{global:AWS_PARTITION}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Multi-region, encrypted AWS CloudTrail successfully created",
         "UpdatedBy": "ASR-AFSBP_1.0.0_CloudTrail.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_CloudTrail.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP CloudTrail.1"
   },
   "Condition": "EnableCloudTrail1Condition"
  },
  "ControlAFSBPCloudTrail2": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudTrail.2\n## What does this document do?\nThis document enables SSE KMS encryption for log files using the ASR remediation KMS CMK\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n## Output Parameters\n* Remediation.Output - Output from the remediation\n\n## Documentation Links\n* [AFSBP CloudTrail.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-2)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.2 finding"
      },
      "KMSKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "TrailArn",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "TrailRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "CloudTrail.2"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableCloudTrailEncryption",
        "RuntimeParameters": {
         "TrailRegion": "{{ParseInput.TrailRegion}}",
         "TrailArn": "{{ParseInput.TrailArn}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableCloudTrailEncryption",
         "KMSKeyArn": "{{KMSKeyArn}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Encryption enabled on CloudTrail",
         "UpdatedBy": "ASR-AFSBP_1.0.0_CloudTrail.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_CloudTrail.2",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP CloudTrail.2"
   },
   "Condition": "EnableCloudTrail2Condition"
  },
  "ControlAFSBPCloudTrail4": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudTrail.4\n\n## What does this document do?\nThis document enables CloudTrail log file validation.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 CloudTrail.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-4)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableCloudTrailLogFileValidation",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "TrailName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail/([A-Za-z0-9._-]{3,128})$",
         "expected_control_id": [
          "CloudTrail.4"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableCloudTrailLogFileValidation",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "TrailName": "{{ParseInput.TrailName}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enabled CloudTrail log file validation.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_CloudTrail.2.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_CloudTrail.4",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP CloudTrail.4"
   },
   "Condition": "EnableCloudTrail4Condition"
  },
  "ControlAFSBPCloudTrail5": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CloudTrail.5\n\n## What does this document do?\nThis document configures CloudTrail to log to CloudWatch Logs.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Remediation results\n\n## Documentation Links\n* [AFSBP v1.0.0 CloudTrail.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-5)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CloudTrail.5 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableCloudTrailToCloudWatchLogging",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "TrailName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail/([A-Za-z0-9._-]{3,128})$",
         "expected_control_id": [
          "CloudTrail.5"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableCloudTrailToCloudWatchLogging",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "TrailName": "{{ ParseInput.TrailName }}",
         "CloudWatchLogsRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CloudTrailToCloudWatchLogs",
         "LogGroupName": "CloudTrail/{{ParseInput.TrailName}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Configured CloudTrail logging to CloudWatch Logs Group CloudTrail/{{ParseInput.TrailName}}",
         "UpdatedBy": "ASR-AFSBP_1.0.0_CloudTrail.5"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_CloudTrail.5",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP CloudTrail.5"
   },
   "Condition": "EnableCloudTrail5Condition"
  },
  "ControlAFSBPCodeBuild2": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_CodeBuild.2\n\n## What does this document do?\nThis document removes CodeBuild project environment variables containing clear text credentials and replaces them with Amazon EC2 Systems Manager Parameters.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 CodeBuild.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-codebuild-2)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the CodeBuild.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "ProjectName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):codebuild:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:project/([A-Za-z0-9][A-Za-z0-9\\-_]{1,254})$",
         "expected_control_id": [
          "CodeBuild.2"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-ReplaceCodeBuildClearTextCredentials",
        "RuntimeParameters": {
         "ProjectName": "{{ ParseInput.ProjectName }}",
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/SO0111-ReplaceCodeBuildClearTextCredentials"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Replaced clear text credentials with SSM parameters.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_CodeBuild.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_CodeBuild.2",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP CodeBuild.2"
   },
   "Condition": "EnableCodeBuild2Condition"
  },
  "ControlAFSBPConfig1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_Config.1\n## What does this document do?\nEnables AWS Config:\n* Turns on recording for all resources.\n* Creates an encrypted bucket for Config logging.\n* Creates a logging bucket for access logs for the config bucket\n* Creates an SNS topic for Config notifications\n* Creates a service-linked role\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP Config.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-config-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Config.1 finding"
      },
      "KMSKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for remediations",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      }
     },
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "Config.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableAWSConfig",
        "RuntimeParameters": {
         "SNSTopicName": "SO0111-SHARR-AWSConfigNotification",
         "KMSKeyArn": "{{KMSKeyArn}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAWSConfig"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "AWS Config enabled",
         "UpdatedBy": "ASR-AFSBP_1.0.0_Config.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_Config.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP Config.1"
   },
   "Condition": "EnableConfig1Condition"
  },
  "ControlAFSBPEC21": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.1\n## What does this document do?\nThis document changes all public EC2 snapshots to private\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP EC2.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "AccountId",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "TestMode",
         "Selector": "$.Payload.testmode",
         "Type": "Boolean"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "resource_index": 2,
         "expected_control_id": [
          "EC2.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-MakeEBSSnapshotsPrivate",
        "RuntimeParameters": {
         "AccountId": "{{ParseInput.AccountId}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-MakeEBSSnapshotsPrivate",
         "TestMode": "{{ParseInput.TestMode}}"
        }
       },
       "isEnd": false
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "EBS Snapshot modified to private",
         "UpdatedBy": "ASR-AFSBP_1.0.0_EC2.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_EC2.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP EC2.1"
   },
   "Condition": "EnableEC21Condition"
  },
  "ControlAFSBPEC22": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.2\n\n## What does this document do?\nThis document deletes ingress and egress rules from default security\ngroup using the AWS SSM Runbook AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Output from AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules SSM doc\n\n## Documentation Links\n* [AFSBP EC2.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-2)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.2 finding"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-RemoveVPCDefaultSecurityGroupRules",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "GroupId",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:security-group/(sg-[0-9a-f]*)$",
         "expected_control_id": [
          "EC2.2"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-RemoveVPCDefaultSecurityGroupRules",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "GroupId": "{{ParseInput.GroupId}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Removed rules on default security group",
         "UpdatedBy": "ASR-AFSBP_1.0.0_EC2.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_EC2.2",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP EC2.2"
   },
   "Condition": "EnableEC22Condition"
  },
  "ControlAFSBPEC26": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.6\n\n## What does this document do?\nEnables VPC Flow Logs for a VPC\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Remediation results\n\n## Documentation Links\n* [AFSBP EC2.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-6)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.6 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableVPCFlowLogs",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "VPC",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):ec2:.*:\\d{12}:vpc/(vpc-[0-9a-f]{8,17})$",
         "expected_control_id": [
          "EC2.6"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableVPCFlowLogs",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "VPC": "{{ParseInput.VPC}}",
         "RemediationRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableVPCFlowLogs-remediationRole",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enabled VPC Flow Logs for {{ParseInput.VPC}}",
         "UpdatedBy": "ASR-AFSBP_1.0.0_EC2.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_EC2.6",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP EC2.6"
   },
   "Condition": "EnableEC26Condition"
  },
  "ControlAFSBPEC27": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.7\n## What does this document do?\nThis document enables `EBS Encryption by default` for an AWS account in the current region by calling another SSM document\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP EC2.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-7)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.7 finding"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableEbsEncryptionByDefault",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "ExecRemediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "EC2.7"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "ExecRemediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableEbsEncryptionByDefault",
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enabled EBS encryption by default",
         "UpdatedBy": "ASR-AFSBP_1.0.0_EC2.7"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_EC2.7",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP EC2.7"
   },
   "Condition": "EnableEC27Condition"
  },
  "ControlAFSBPEC215": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_EC2.15\n\n## What does this document do?\nThis document disables auto assignment of public IP addresses.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 EC2.15](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-15)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the EC2.15 finding"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-DisablePublicIPAutoAssign",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "SubnetARN",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "EC2.15"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-DisablePublicIPAutoAssign",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{ RemediationRoleName }}"
         }
        ],
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}",
         "SubnetARN": "{{ParseInput.SubnetARN}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Disabled public IP auto assignment for subnet.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_EC2.15"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding"
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_EC2.15",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP EC2.15"
   },
   "Condition": "EnableEC215Condition"
  },
  "ControlAFSBPIAM3": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_IAM.3\n\n## What does this document do?\nThis document disables active keys that have not been rotated for more than 90 days. Note that this remediation is **DISRUPTIVE**.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 IAM.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-3)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the IAM.3 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "MaxCredentialUsageAge": {
       "type": "String",
       "description": "(Required) Maximum number of days a key can be unrotated. The default value is 90 days.",
       "allowedPattern": "^(?:[1-9]\\d{0,3}|10000)$",
       "default": "90"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-RevokeUnrotatedKeys",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "IAMUser",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "IAMResourceId",
         "Selector": "$.Payload.details.AwsIamUser.UserId",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):iam::\\d{12}:user(?:(?:\\u002F)|(?:\\u002F[\\u0021-\\u007F]{1,510}\\u002F))([\\w+=,.@-]{1,64})$",
         "expected_control_id": [
          "IAM.3"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-RevokeUnrotatedKeys",
        "RuntimeParameters": {
         "IAMResourceId": "{{ ParseInput.IAMResourceId }}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}",
         "MaxCredentialUsageAge": "{{MaxCredentialUsageAge}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Deactivated unrotated keys for {{ ParseInput.IAMUser }}.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_IAM.3"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_IAM.3",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP IAM.3"
   },
   "Condition": "EnableIAM3Condition"
  },
  "ControlAFSBPIAM7": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_IAM.7\n\n## What does this document do?\nThis document establishes a default password policy.\n\n## Security Standards and Controls\n* AFSBP IAM.7\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP IAM.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-7)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the IAM.7 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "IAM.7"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-SetIAMPasswordPolicy",
        "RuntimeParameters": {
         "AllowUsersToChangePassword": true,
         "HardExpiry": true,
         "MaxPasswordAge": 90,
         "MinimumPasswordLength": 14,
         "RequireSymbols": true,
         "RequireNumbers": true,
         "RequireUppercaseCharacters": true,
         "RequireLowercaseCharacters": true,
         "PasswordReusePrevention": 24,
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetIAMPasswordPolicy"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Established a baseline password policy using the AWSConfigRemediation-SetIAMPasswordPolicy runbook.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_IAM.7"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_IAM.7",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP IAM.7"
   },
   "Condition": "EnableIAM7Condition"
  },
  "ControlAFSBPIAM8": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_IAM.8\n\n## What does this document do?\nThis document ensures that credentials unused for 90 days or greater are disabled.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - Output of remediation runbook\n\nSEE AWSConfigRemediation-RevokeUnusedIAMUserCredentials\n\n## Documentation Links\n* [AFSBP IAM.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-8)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the IAM.8 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "IAMResourceId",
         "Selector": "$.Payload.details.AwsIamUser.UserId",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "IAM.8"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-RevokeUnusedIAMUserCredentials",
        "RuntimeParameters": {
         "IAMResourceId": "{{ ParseInput.IAMResourceId }}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-RevokeUnusedIAMUserCredentials"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Deactivated unused keys and expired logins using the AWSConfigRemediation-RevokeUnusedIAMUserCredentials runbook.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_IAM.8"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_IAM.8",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP IAM.8"
   },
   "Condition": "EnableIAM8Condition"
  },
  "ControlAFSBPLambda1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_Lambda.1\n\n## What does this document do?\nThis document removes the public resource policy. A public resource policy\ncontains a principal \"*\" or AWS: \"*\", which allows public access to the\nfunction. The remediation is to remove the SID of the public policy.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP Lambda.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-lambda-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Lambda.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-RemoveLambdaPublicAccess",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FunctionName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-us-gov|aws-cn):lambda:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:function:([a-zA-Z0-9\\-_]{1,64})$",
         "expected_control_id": [
          "Lambda.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-RemoveLambdaPublicAccess",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "FunctionName": "{{ ParseInput.FunctionName }}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Lamdba {{ParseInput.FunctionName}} policy updated to remove public access",
         "UpdatedBy": "ASR-AFSBP_1.0.0_Lambda.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_Lambda.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP Lambda.1"
   },
   "Condition": "EnableLambda1Condition"
  },
  "ControlAFSBPRDS1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.1\n## What does this document do?\nThis document changes public RDS snapshot to private\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP RDS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-MakeRDSSnapshotPrivate",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "DBSnapshotId",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "DBSnapshotType",
         "Selector": "$.Payload.matches[0]",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "Type",
         "Selector": "$.Payload.type",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(cluster-snapshot|snapshot):([a-zA-Z](?:[0-9a-zA-Z]+-)*[0-9a-zA-Z]+)$",
         "resource_index": 2,
         "expected_control_id": [
          "RDS.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "nextStep": "Remediation"
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-MakeRDSSnapshotPrivate",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "DBSnapshotId": "{{ParseInput.DBSnapshotId}}",
         "DBSnapshotType": "{{ParseInput.DBSnapshotType}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       },
       "nextStep": "UpdateFinding"
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "RDS DB Snapshot modified to private",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.1"
   },
   "Condition": "EnableRDS1Condition"
  },
  "ControlAFSBPRDS2": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.2\n## What does this document do?\nThis document disables public access to RDS instances by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Documentation Links\n* [AFSBP RDS.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-2)\n\n## Troubleshooting\n* ModifyDBInstance isn't supported for a DB instance in a Multi-AZ DB Cluster.\n  - This remediation will not work on an instance within a MySQL or PostgreSQL Multi-AZ Cluster due to limitations with the RDS API.\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{AutomationAssumeRole}}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-DisablePublicAccessToRDSInstance",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:db:((?!.*--.*)(?!.*-$)[a-z][a-z0-9-]{0,62})$",
         "expected_control_id": [
          "RDS.2"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "outputs": [
        {
         "Name": "DbiResourceId",
         "Selector": "$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-DisablePublicAccessToRDSInstance",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "DbiResourceId": "{{ParseInput.DbiResourceId}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Disabled public access to RDS instance",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.2",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.2"
   },
   "Condition": "EnableRDS2Condition"
  },
  "ControlAFSBPRDS4": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.4\n\n## What does this document do?\nThis document encrypts an unencrypted RDS snapshot by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n* KMSKeyId: (Optional) ID, ARN or Alias for the AWS KMS Customer-Managed Key (CMK) to use to encrypt the snapshot.\n\n## Documentation Links\n* [AFSBP RDS.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-4)\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EncryptRDSSnapshot",
       "allowedPattern": "^[\\w+=,.@-]+$"
      },
      "KMSKeyId": {
       "type": "String",
       "default": "alias/aws/rds",
       "description": "(Optional) ID, ARN or Alias for the AWS KMS Customer-Managed Key (CMK) to use to encrypt the snapshot.",
       "allowedPattern": "^(?:arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:)?(?:(?:alias/[A-Za-z0-9/_-]+)|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "SourceDBSnapshotIdentifier",
         "Selector": "$.Payload.matches[1]",
         "Type": "String"
        },
        {
         "Name": "SourceDBSnapshotIdentifierNoPrefix",
         "Selector": "$.Payload.matches[2]",
         "Type": "String"
        },
        {
         "Name": "DBSnapshotType",
         "Selector": "$.Payload.matches[0]",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:((?:cluster-)?snapshot|dbclustersnapshot):((?:rds:)?((?!.*--.*)(?!.*-$)[a-zA-Z][a-zA-Z0-9-]{0,254}))$",
         "resource_index": 2,
         "expected_control_id": [
          "RDS.4"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EncryptRDSSnapshot",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "SourceDBSnapshotIdentifier": "{{ParseInput.SourceDBSnapshotIdentifier}}",
         "TargetDBSnapshotIdentifier": "{{ParseInput.SourceDBSnapshotIdentifierNoPrefix}}-encrypted",
         "DBSnapshotType": "{{ParseInput.DBSnapshotType}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}",
         "KmsKeyId": "{{KMSKeyId}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Encrypted RDS snapshot",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.4",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.4"
   },
   "Condition": "EnableRDS4Condition"
  },
  "ControlAFSBPRDS5": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-AFSBP_1.0.RDS.5\n\n## What does this document do?\nThis document configures an RDS DB instance for multiple Availability Zones by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP RDS.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-5)\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.5 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableMultiAZOnRDSInstance",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.5"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "outputs": [
        {
         "Name": "DbInstanceResourceId",
         "Selector": "$.Payload.details.AwsRdsDbInstance.DbiResourceId",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableMultiAZOnRDSInstance",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "DbiResourceId": "{{ParseInput.DbInstanceResourceId}}",
         "ApplyImmediately": true,
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Configured RDS cluster for multiple Availability Zones",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.5"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.5",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.5"
   },
   "Condition": "EnableRDS5Condition"
  },
  "ControlAFSBPRDS6": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.6\n\n## What does this document do?\nThis document enables `Enhanced Monitoring` on a given Amazon RDS instance by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* VerifyRemediation.Output - The standard HTTP response from the ModifyDBInstance API.\n## Documentation Links\n\n* [AFSBP RDS.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-6)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.6 finding"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableEnhancedMonitoringOnRDSInstance",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "ResourceId",
         "Selector": "$.Payload.details.AwsRdsDbInstance.DbiResourceId",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.6"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "GetMonitoringRoleArn",
       "action": "aws:executeAwsApi",
       "description": "## GetRole API to get EnhancedMonitoring IAM role ARN\n",
       "timeoutSeconds": 600,
       "isEnd": false,
       "inputs": {
        "Service": "iam",
        "Api": "GetRole",
        "RoleName": "SO0111-RDSMonitoring-remediationRole"
       },
       "outputs": [
        {
         "Name": "Arn",
         "Selector": "$.Role.Arn",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableEnhancedMonitoringOnRDSInstance",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "ResourceId": "{{ ParseInput.ResourceId }}",
         "MonitoringRoleArn": "{{GetMonitoringRoleArn.Arn}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enhanced Monitoring enabled on RDS DB cluster",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.6",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.6"
   },
   "Condition": "EnableRDS6Condition"
  },
  "ControlAFSBPRDS7": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.7\n\n## What does this document do?\nThis document enables `Deletion Protection` on a given Amazon RDS cluster by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - The standard HTTP response from the ModifyDBCluster API.\n\n## Documentation Links\n* [AFSBP RDS.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-7)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.7 finding"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableRDSClusterDeletionProtection",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "ResourceId",
         "Selector": "$.Payload.details.AwsRdsDbCluster.DbClusterResourceId",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.7"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableRDSClusterDeletionProtection",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "ClusterId": "{{ ParseInput.ResourceId }}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Deletion protection enabled on RDS DB cluster",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.7"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.7",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.7"
   },
   "Condition": "EnableRDS7Condition"
  },
  "ControlAFSBPRDS8": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-AFSBP_1.0.RDS.8\n\n## What does this document do?\nThis document enables `Deletion Protection` on a given Amazon RDS cluster by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP RDS.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-8)\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.8 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableRDSInstanceDeletionProtection",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.8"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "outputs": [
        {
         "Name": "DbInstanceResourceId",
         "Selector": "$.Payload.details.AwsRdsDbInstance.DbiResourceId",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableRDSInstanceDeletionProtection",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "DbInstanceResourceId": "{{ParseInput.DbInstanceResourceId}}",
         "ApplyImmediately": true,
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enabled deletion protection on RDS instance",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.8"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.8",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.8"
   },
   "Condition": "EnableRDS8Condition"
  },
  "ControlAFSBPRDS13": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.13\n\n## What does this document do?\nThis document enables `Auto minor version upgrade` on a given Amazon RDS instance by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - The standard HTTP response from the ModifyDBInstance API.\n\n## Documentation Links\n* [AFSBP RDS.13](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-13)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.13 finding"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableMinorVersionUpgradeOnRDSDBInstance",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "DBInstanceIdentifier",
         "Selector": "$.Payload.resource.Details.AwsRdsDbInstance.DBInstanceIdentifier",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.13"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableMinorVersionUpgradeOnRDSDBInstance",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "DBInstanceIdentifier": "{{ ParseInput.DBInstanceIdentifier }}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Minor Version enabled on the RDS Instance.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.13"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.13",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.13"
   },
   "Condition": "EnableRDS13Condition"
  },
  "ControlAFSBPRDS16": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_RDS.16\n\n## What does this document do?\nThis document enables `Copy tags to snapshots` on a given Amazon RDS cluster by calling another SSM document.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output - The standard HTTP response from the ModifyDBCluster API.\n\n## Documentation Links\n* [AFSBP RDS.16](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-16)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the RDS.16 finding"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableCopyTagsToSnapshotOnRDSCluster",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "DbClusterResourceId",
         "Selector": "$.Payload.details.AwsRdsDbCluster.DbClusterResourceId",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "RDS.16"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableCopyTagsToSnapshotOnRDSCluster",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "DbClusterResourceId": "{{ ParseInput.DbClusterResourceId }}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}",
         "ApplyImmediately": true
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Copy Tags to Snapshots enabled on RDS DB cluster",
         "UpdatedBy": "ASR-AFSBP_1.0.0_RDS.16"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_RDS.16",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP RDS.16"
   },
   "Condition": "EnableRDS16Condition"
  },
  "ControlAFSBPRedshift1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-AFSBP_1.0.0_Redshift.1\n\n## What does this document do?\nThis document disables public access to a Redshift cluster by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP Redshift.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-1)\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Redshift.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-DisablePublicAccessToRedshiftCluster",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$",
         "expected_control_id": [
          "Redshift.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "outputs": [
        {
         "Name": "ClusterIdentifier",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-DisablePublicAccessToRedshiftCluster",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "ClusterIdentifier": "{{ParseInput.ClusterIdentifier}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Disabled public access to Redshift cluster",
         "UpdatedBy": "ASR-AFSBP_1.0.0_Redshift.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_Redshift.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP Redshift.1"
   },
   "Condition": "EnableRedshift1Condition"
  },
  "ControlAFSBPRedshift3": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-AFSBP_1.0.0_Redshift.3\n\n## What does this document do?\nThis document enables automatic snapshots on a Redshift cluster by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP Redshift.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-3)\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Redshift.3 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableAutomaticSnapshotsOnRedshiftCluster",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$",
         "expected_control_id": [
          "Redshift.3"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "outputs": [
        {
         "Name": "ClusterIdentifier",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RetentionPeriodSerialized",
         "Selector": "$.Payload.aws_config_rule.InputParameters",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "ExtractConfigRuleParameters",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "SerializedJson": "{{ParseInput.RetentionPeriodSerialized}}"
        },
        "Runtime": "python3.8",
        "Handler": "event_handler",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\n\ndef event_handler(event, _):\n    try:\n        return json.loads(event['SerializedJson'])\n    except Exception as e:\n        print(e)\n        exit('Failed to deserialize data')"
       },
       "outputs": [
        {
         "Name": "MinRetentionPeriod",
         "Selector": "$.Payload.MinRetentionPeriod",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableAutomaticSnapshotsOnRedshiftCluster",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "ClusterIdentifier": "{{ParseInput.ClusterIdentifier}}",
         "MinRetentionPeriod": "{{ExtractConfigRuleParameters.MinRetentionPeriod}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enabled automatic snapshots on Redshift cluster",
         "UpdatedBy": "ASR-AFSBP_1.0.0_Redshift.3"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_Redshift.3",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP Redshift.3"
   },
   "Condition": "EnableRedshift3Condition"
  },
  "ControlAFSBPRedshift4": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-AFSBP_1.0.0_Redshift.4\n\n## What does this document do?\nThis document disables public access to a Redshift cluster by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP Redshift.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-1)\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Redshift.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableRedshiftClusterAuditLogging",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$",
         "expected_control_id": [
          "Redshift.4"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "outputs": [
        {
         "Name": "ClusterIdentifier",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "CheckIfSSMParameterWithS3BucketNameIsAvailable",
       "action": "aws:executeScript",
       "inputs": {
        "Runtime": "python3.8",
        "Handler": "check_for_s3_bucket_name",
        "Script": "#!/usr/bin/python\n## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n## SPDX-License-Identifier: Apache-2.0\n\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef check_for_s3_bucket_name(event, context):\n  try:\n      ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n      )\n      s3_bucket_name_for_audit_logging = ssm.get_parameter(\n          Name=f'/Solutions/{get_solution_id()}/afsbp/1.0.0/REDSHIFT.4/S3BucketNameForAuditLogging'\n      )['Parameter'].get('Value', 'unknown')\n  except Exception as e:\n      return {\n        \"s3_bucket_name_for_redshift_audit_logging\": \"NOT_AVAILABLE\"\n      }\n  return {\n      \"s3_bucket_name_for_redshift_audit_logging\": s3_bucket_name_for_audit_logging\n  }"
       },
       "outputs": [
        {
         "Name": "BucketName",
         "Selector": "$.Payload.s3_bucket_name_for_redshift_audit_logging",
         "Type": "String"
        }
       ]
      },
      {
       "name": "ValidateIfS3BucketNameIsConfigured",
       "action": "aws:branch",
       "inputs": {
        "Choices": [
         {
          "NextStep": "UpdateFindingThatS3BucketNameIsNotConfigured",
          "Variable": "{{CheckIfSSMParameterWithS3BucketNameIsAvailable.BucketName}}",
          "StringEquals": "NOT_AVAILABLE"
         }
        ],
        "Default": "Remediation"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableRedshiftClusterAuditLogging",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "ClusterIdentifier": "{{ParseInput.ClusterIdentifier}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}",
         "BucketName": "{{CheckIfSSMParameterWithS3BucketNameIsAvailable.BucketName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enabled Audit logging for the Redshift cluster.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_Redshift.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      },
      {
       "name": "UpdateFindingThatS3BucketNameIsNotConfigured",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Remediation failed the s3 bucket name is not available, review the cloudformation template and select the option Yes for create redshift.4 s3 bucket cloudformation parameter.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_Redshift.4"
        },
        "Workflow": {
         "Status": "NOTIFIED"
        }
       },
       "description": "Abort remediation as s3 bucket name is unavailable.",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_Redshift.4",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP Redshift.4"
   },
   "Condition": "EnableRedshift4Condition"
  },
  "ControlAFSBPRedshift6": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "schemaVersion": "0.3",
     "description": "### Document Name - ASR-AFSBP_1.0.0_Redshift.6\n\n## What does this document do?\nThis document enables automatic version upgrade on a Redshift cluster by calling another SSM document\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Documentation Links\n* [AFSBP Redshift.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-6)\n",
     "assumeRole": "{{AutomationAssumeRole}}",
     "outputs": [
      "Remediation.Output",
      "ParseInput.AffectedObject"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the Redshift.6 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableAutomaticVersionUpgradeOnRedshiftCluster",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$",
         "expected_control_id": [
          "Redshift.6"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "outputs": [
        {
         "Name": "ClusterIdentifier",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "AllowVersionUpgradeSerialized",
         "Selector": "$.Payload.aws_config_rule.InputParameters",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ]
      },
      {
       "name": "ExtractConfigRuleParameters",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "SerializedJson": "{{ParseInput.AllowVersionUpgradeSerialized}}"
        },
        "Runtime": "python3.8",
        "Handler": "event_handler",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\n\ndef event_handler(event, _):\n    try:\n        return json.loads(event['SerializedJson'])\n    except Exception as e:\n        print(e)\n        exit('Failed to deserialize data')"
       },
       "outputs": [
        {
         "Name": "AllowVersionUpgrade",
         "Selector": "$.Payload.allowVersionUpgrade",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableAutomaticVersionUpgradeOnRedshiftCluster",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "ClusterIdentifier": "{{ParseInput.ClusterIdentifier}}",
         "AllowVersionUpgrade": "{{ExtractConfigRuleParameters.AllowVersionUpgrade}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enabled automatic version upgrade on Redshift cluster",
         "UpdatedBy": "ASR-AFSBP_1.0.0_Redshift.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_Redshift.6",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP Redshift.6"
   },
   "Condition": "EnableRedshift6Condition"
  },
  "ControlAFSBPS31": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.1\n\n## What does this document do?\nThis document blocks public access to all buckets by default at the account level.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.1 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "AccountId",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "S3.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-ConfigureS3PublicAccessBlock",
        "RuntimeParameters": {
         "AccountId": "{{ParseInput.AccountId}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3PublicAccessBlock",
         "RestrictPublicBuckets": true,
         "BlockPublicAcls": true,
         "IgnorePublicAcls": true,
         "BlockPublicPolicy": true
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Configured the account to block public S3 access.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_S3.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_S3.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP S3.1"
   },
   "Condition": "EnableS31Condition"
  },
  "ControlAFSBPS32": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.2\n\n## What does this document do?\nThis document blocks all public access to an S3 bucket.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-2)\n* [AFSBP v1.0.0 S3.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-3)\n* [AFSBP v1.0.0 S3.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-8)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.2 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "S3.2",
          "S3.3",
          "S3.8"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-ConfigureS3BucketPublicAccessBlock",
        "RuntimeParameters": {
         "BucketName": "{{ParseInput.BucketName}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3BucketPublicAccessBlock",
         "RestrictPublicBuckets": true,
         "BlockPublicAcls": true,
         "IgnorePublicAcls": true,
         "BlockPublicPolicy": true
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Disabled public access to S3 bucket.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_S3.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_S3.2",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP S3.2"
   },
   "Condition": "EnableS32Condition"
  },
  "ControlAFSBPS34": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.4\n\n## What does this document do?\nThis document enables AES-256 as the default encryption for an S3 bucket.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-4)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.4 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableDefaultEncryptionS3",
       "allowedPattern": "^[\\w+=,.@-]+$"
      },
      "KmsKeyAlias": {
       "type": "String",
       "description": "(Required) KMS Customer-Managed Key (CMK) alias or the default value which is created in the SSM parameter at solution deployment (default-s3-encryption) is used to identify that the s3 bucket encryption value should be set to AES-256.",
       "default": "{{ssm:/Solutions/SO0111/afsbp/1.0.0/S3.4/KmsKeyAlias}}",
       "allowedPattern": "^$|^[a-zA-Z0-9/_-]{1,256}$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "AccountId",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "S3.4"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableDefaultEncryptionS3",
        "RuntimeParameters": {
         "AccountId": "{{ParseInput.AccountId}}",
         "BucketName": "{{ParseInput.BucketName}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}",
         "KmsKeyAlias": "{{KmsKeyAlias}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Enabled default encryption for {{ParseInput.BucketName}}",
         "UpdatedBy": "ASR-AFSBP_1.0.0_S3.4"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_S3.4",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP S3.4"
   },
   "Condition": "EnableS34Condition"
  },
  "ControlAFSBPS35": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.5\n\n## What does this document do?\nThis document adds a bucket policy to restrict internet access to https only.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-5)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.5 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding_id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.product_arn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "AccountId",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "S3.5"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-SetSSLBucketPolicy",
        "RuntimeParameters": {
         "BucketName": "{{ParseInput.BucketName}}",
         "AccountId": "{{ParseInput.AccountId}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetSSLBucketPolicy"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Added SSL-only access policy to S3 bucket.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_S3.5"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_S3.5",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP S3.5"
   },
   "Condition": "EnableS35Condition"
  },
  "ControlAFSBPS36": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_S3.6\n\n## What does this document do?\nThis document restricts cross-account access to a bucket in the local account.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 S3.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-6)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "parameters": {
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the S3.6 finding"
      },
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-S3BlockDenylist",
       "allowedPattern": "^[\\w+=,.@-]+$"
      }
     },
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "BucketName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "ConfigRuleName",
         "Selector": "$.Payload.aws_config_rule.ConfigRuleName",
         "Type": "String"
        },
        {
         "Name": "DenyListSerialized",
         "Selector": "$.Payload.aws_config_rule.InputParameters",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$",
         "expected_control_id": [
          "S3.6"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "ExtractSensitiveApis",
       "action": "aws:executeScript",
       "inputs": {
        "InputPayload": {
         "SerializedList": "{{ ParseInput.DenyListSerialized }}"
        },
        "Runtime": "python3.8",
        "Handler": "runbook_handler",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport json\n\ndef runbook_handler(event, _):\n    try:\n        deserialized = json.loads(event['SerializedList'])\n        if 'blacklistedActionPattern' in deserialized:\n            return deserialized['blacklistedActionPattern'] # Returns comma-delimited list in a string\n        else:\n            exit('Missing blacklistedActionPattern in AWS Config data')\n    except Exception as e:\n        print(e)\n        exit('Failed getting comma-delimited string list of sensitive API calls input data')"
       },
       "outputs": [
        {
         "Name": "ListOfApis",
         "Selector": "$.Payload",
         "Type": "String"
        }
       ]
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-S3BlockDenylist",
        "RuntimeParameters": {
         "BucketName": "{{ParseInput.BucketName}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}",
         "DenyList": "{{ExtractSensitiveApis.ListOfApis}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Added explicit deny for sensitive bucket access from another account.",
         "UpdatedBy": "ASR-AFSBP_1.0.0_S3.6"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_S3.6",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP S3.6"
   },
   "Condition": "EnableS36Condition"
  },
  "ControlAFSBPSNS1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_SNS.1\n\n## What does this document do?\nThis document enables encryption at rest using AWS KMS for SNS topics.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 SNS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-sns-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the SNS.1 finding"
      },
      "KmsKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for this remediation",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      }
     },
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "SNSTopicArn",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "SNS.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       },
       "isEnd": false
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableEncryptionForSNSTopic",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "SO0111-EnableEncryptionForSNSTopic"
         }
        ],
        "RuntimeParameters": {
         "KmsKeyArn": "{{KmsKeyArn}}",
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableEncryptionForSNSTopic",
         "TopicArn": "{{ParseInput.SNSTopicArn}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Encryption enabled on SNS Topic",
         "UpdatedBy": "ASR-AFSBP_1.0.0_SNS.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding",
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_SNS.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP SNS.1"
   },
   "Condition": "EnableSNS1Condition"
  },
  "ControlAFSBPSNS2": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_SNS.2\n\n## What does this document do?\nThis document enables logging of delivery status for notification messages sent to a topic.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n* RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 SNS.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-sns-2)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the SNS.2 finding"
      },
      "RemediationRoleName": {
       "type": "String",
       "default": "SO0111-EnableDeliveryStatusLoggingForSNSTopic",
       "allowedPattern": "^[\\w+=,.@-]+$"
      },
      "LoggingRole": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/DeliveryStatusLoggingRole}}",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      }
     },
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "SNSTopicArn",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "",
         "expected_control_id": [
          "SNS.2"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "inputs": {
        "DocumentName": "ASR-EnableDeliveryStatusLoggingForSNSTopic",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ParseInput.RemediationAccount}}"
          ],
          "Regions": [
           "{{ParseInput.RemediationRegion}}"
          ],
          "ExecutionRoleName": "{{RemediationRoleName}}"
         }
        ],
        "RuntimeParameters": {
         "AutomationAssumeRole": "arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}",
         "LoggingRole": "{{LoggingRole}}",
         "SNSTopicArn": "{{ParseInput.SNSTopicArn}}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ParseInput.FindingId}}",
          "ProductArn": "{{ParseInput.ProductArn}}"
         }
        ],
        "Note": {
         "Text": "Delivery status logging enabled on SNS Topic",
         "UpdatedBy": "ASR-AFSBP_1.0.0_SNS.2"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "description": "Update finding"
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_SNS.2",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP SNS.2"
   },
   "Condition": "EnableSNS2Condition"
  },
  "ControlAFSBPSQS1": {
   "Type": "AWS::SSM::Document",
   "Properties": {
    "Content": {
     "description": "### Document Name - ASR-AFSBP_1.0.0_SQS.1\n\n## What does this document do?\nThis document enables encryption at rest using AWS KMS for SQS Queues.\n\n## Input Parameters\n* Finding: (Required) Security Hub finding details JSON\n* AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n## Output Parameters\n* Remediation.Output\n\n## Documentation Links\n* [AFSBP v1.0.0 SQS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-sqs-1)\n",
     "schemaVersion": "0.3",
     "assumeRole": "{{ AutomationAssumeRole }}",
     "parameters": {
      "AutomationAssumeRole": {
       "type": "String",
       "description": "(Required) The ARN of the role that allows Automation to perform the actions on your behalf.",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$"
      },
      "Finding": {
       "type": "StringMap",
       "description": "The input from the Orchestrator Step function for the SQS.1 finding"
      },
      "KmsKeyArn": {
       "type": "String",
       "default": "{{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}",
       "description": "The ARN of the KMS key created by ASR for this remediation",
       "allowedPattern": "^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$"
      }
     },
     "outputs": [
      "ParseInput.AffectedObject",
      "Remediation.Output"
     ],
     "mainSteps": [
      {
       "name": "ParseInput",
       "action": "aws:executeScript",
       "outputs": [
        {
         "Name": "FindingId",
         "Selector": "$.Payload.finding.Id",
         "Type": "String"
        },
        {
         "Name": "ProductArn",
         "Selector": "$.Payload.finding.ProductArn",
         "Type": "String"
        },
        {
         "Name": "AffectedObject",
         "Selector": "$.Payload.object",
         "Type": "StringMap"
        },
        {
         "Name": "SQSQueueName",
         "Selector": "$.Payload.resource_id",
         "Type": "String"
        },
        {
         "Name": "RemediationRegion",
         "Selector": "$.Payload.resource_region",
         "Type": "String"
        },
        {
         "Name": "RemediationAccount",
         "Selector": "$.Payload.account_id",
         "Type": "String"
        }
       ],
       "inputs": {
        "InputPayload": {
         "Finding": "{{Finding}}",
         "parse_id_pattern": "^arn:(?:aws|aws-us-gov|aws-cn):sqs:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:([a-zA-Z0-9_-]{1,80}(?:\\.fifo)?)$",
         "expected_control_id": [
          "SQS.1"
         ]
        },
        "Runtime": "python3.8",
        "Handler": "parse_event",
        "Script": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\nimport re\nimport json\nimport boto3\nfrom botocore.config import Config\n\ndef connect_to_config(boto_config):\n    return boto3.client('config', config=boto_config)\n\ndef connect_to_ssm(boto_config):\n    return boto3.client('ssm', config=boto_config)\n\ndef get_solution_id():\n    return 'SO0111'\n\ndef get_solution_version():\n    ssm = connect_to_ssm(\n        Config(\n            retries = {\n                'mode': 'standard'\n            },\n            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n        )\n    )\n    solution_version = 'unknown'\n    try:\n        ssm_parm_value = ssm.get_parameter(\n            Name=f'/Solutions/{get_solution_id()}/member-version'\n        )['Parameter'].get('Value', 'unknown')\n        solution_version = ssm_parm_value\n    except Exception as e:\n        print(e)\n        print(f'ERROR getting solution version')\n    return solution_version\n\ndef get_shortname(long_name):\n    short_name = {\n        'aws-foundational-security-best-practices': 'AFSBP',\n        'cis-aws-foundations-benchmark': 'CIS',\n        'pci-dss': 'PCI',\n        'security-control': 'SC'\n    }\n    return short_name.get(long_name, None)\n\ndef get_config_rule(rule_name):\n    boto_config = Config(\n        retries = {\n            'mode': 'standard'\n        },\n        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n    )\n    config_rule = None\n    try:\n        configsvc = connect_to_config(boto_config)\n        config_rule = configsvc.describe_config_rules(\n            ConfigRuleNames=[ rule_name ]\n        ).get('ConfigRules', [])[0]\n    except Exception as e:\n        print(e)\n        exit(f'ERROR getting config rule {rule_name}')\n    return config_rule\n\nclass FindingEvent:\n    \"\"\"\n    Finding object returns the parse fields from an input finding json object\n    \"\"\"\n    def _get_resource_id(self, parse_id_pattern, resource_index):\n        identifier_raw = self.finding_json['Resources'][0]['Id']\n        self.resource_id = identifier_raw\n        self.resource_id_matches = []\n\n        if parse_id_pattern:\n            identifier_match = re.match(\n                parse_id_pattern,\n                identifier_raw\n            )\n\n            if identifier_match:\n                for group in range(1, len(identifier_match.groups())+1):\n                    self.resource_id_matches.append(identifier_match.group(group))\n                self.resource_id = identifier_match.group(resource_index)\n            else:\n                exit(f'ERROR: Invalid resource Id {identifier_raw}')\n    \n    def _get_sc_check(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'security-control/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname('security-control')\n            self.control_id = match_finding_id.group(1)\n\n        return match_finding_id\n\n    def _get_standard_info(self):\n        match_finding_id = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:'+\n            'subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n            self.finding_json['Id']\n        )\n        if match_finding_id:\n            self.standard_id = get_shortname(match_finding_id.group(1))\n            self.standard_version = match_finding_id.group(2)\n            self.control_id = match_finding_id.group(3)\n        else:\n            match_sc_finding_id = self._get_sc_check()\n            if not match_sc_finding_id:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n\n    def _get_aws_config_rule(self):\n        # config_rule_id refers to the AWS Config Rule that produced the finding\n        if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n\n    def _get_region_from_resource_id(self):\n        check_for_region = re.match(\n            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:([a-z]{2}(?:-gov)?-[a-z]+-\\d):.*:.*$',\n            self.finding_json['Resources'][0]['Id']\n        )\n        if check_for_region:\n            self.resource_region = check_for_region.group(1)\n\n    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n        self.valid_finding = True\n        self.resource_region = None\n        self.control_id = None\n        self.aws_config_rule_id = None\n        self.aws_config_rule = {}\n\n        \"\"\"Populate fields\"\"\"\n        # v1.5\n        self.finding_json = finding_json\n        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n\n        # V1.4\n        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n        if not re.match(r'^\\d{12}$', self.account_id) and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n        self.finding_id = self.finding_json.get('Id', None)              # deprecate\n        self.product_arn = self.finding_json.get('ProductArn', None)\n        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:[a-z]{2}(?:-gov)?-[a-z]+-\\d::product/aws/securityhub$', self.product_arn):\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n        self.details = self.finding_json['Resources'][0].get('Details', {})\n        # Test mode is used with fabricated finding data to tell the\n        # remediation runbook to run in test more (where supported)\n        # Currently not widely-used and perhaps should be deprecated.\n        self.testmode = bool('testmode' in self.finding_json)\n        self.resource = self.finding_json['Resources'][0]\n        self._get_region_from_resource_id()\n        self._get_aws_config_rule()\n        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n\n        # Validate control_id\n        if not self.control_id:\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n        elif self.control_id not in expected_control_id:  # ControlId is the expected value\n            if self.valid_finding:\n                self.valid_finding = False\n                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n\n        if not self.resource_id and self.valid_finding:\n            self.valid_finding = False\n            self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n\n        if not self.valid_finding:\n            # Error message and return error data\n            msg = f'ERROR: {self.invalid_finding_reason}'\n            exit(msg)\n\n    def __str__(self):\n        return json.dumps(self.__dict__)\n\n'''\nMAIN\n'''\ndef parse_event(event, _):\n    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n\n    if not finding_event.valid_finding:\n        exit('ERROR: Finding is not valid')\n\n    return {\n        \"account_id\": finding_event.account_id,\n        \"resource_id\": finding_event.resource_id,\n        \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n        \"control_id\": finding_event.control_id,\n        \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n        \"object\": finding_event.affected_object,\n        \"matches\": finding_event.resource_id_matches,\n        \"details\": finding_event.details,               # Deprecate v1.5.0+\n        \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n        \"resource\": finding_event.resource,\n        \"resource_region\": finding_event.resource_region,\n        \"finding\": finding_event.finding_json,\n        \"aws_config_rule\": finding_event.aws_config_rule\n    }"
       }
      },
      {
       "name": "Remediation",
       "action": "aws:executeAutomation",
       "isEnd": false,
       "inputs": {
        "DocumentName": "ASR-EnableEncryptionForSQSQueue",
        "TargetLocations": [
         {
          "Accounts": [
           "{{ ParseInput.RemediationAccount }}"
          ],
          "Regions": [
           "{{ ParseInput.RemediationRegion }}"
          ],
          "ExecutionRoleName": "SO0111-EnableEncryptionForSQSQueue"
         }
        ],
        "RuntimeParameters": {
         "KmsKeyArn": "{{ KmsKeyArn }}",
         "AutomationAssumeRole": "arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/SO0111-EnableEncryptionForSQSQueue",
         "SQSQueueName": "{{ ParseInput.SQSQueueName }}"
        }
       }
      },
      {
       "name": "UpdateFinding",
       "action": "aws:executeAwsApi",
       "inputs": {
        "Service": "securityhub",
        "Api": "BatchUpdateFindings",
        "FindingIdentifiers": [
         {
          "Id": "{{ ParseInput.FindingId }}",
          "ProductArn": "{{ ParseInput.ProductArn }}"
         }
        ],
        "Note": {
         "Text": "Encryption enabled on SQS Queue",
         "UpdatedBy": "ASR-AFSBP_1.0.0_SQS.1"
        },
        "Workflow": {
         "Status": "RESOLVED"
        }
       },
       "isEnd": true
      }
     ]
    },
    "DocumentFormat": "YAML",
    "DocumentType": "Automation",
    "Name": "ASR-AFSBP_1.0.0_SQS.1",
    "UpdateMethod": "NewVersion"
   },
   "DependsOn": [
    "CreateWait7"
   ],
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/Control AFSBP SQS.1"
   },
   "Condition": "EnableSQS1Condition"
  },
  "CreateWait0": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "d29e03692513565fde72a6a1707ea1010947cb6c06d4b9f8eb1ac5e0005866e2"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/CreateWait0/Default"
   }
  },
  "DeletWait0": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "d29e03692513565fde72a6a1707ea1010947cb6c06d4b9f8eb1ac5e0005866e2"
   },
   "DependsOn": [
    "ControlAFSBPAutoScaling1",
    "ControlAFSBPCloudFormation1",
    "ControlAFSBPCloudTrail1",
    "ControlAFSBPCloudTrail2",
    "ControlAFSBPCloudTrail4"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/DeletWait0/Default"
   }
  },
  "CreateWait1": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "0cebf6d33a346f8fda1e439b4fe2758b0d1fe60a0436547ff3a0f785d6bbe5d0"
   },
   "DependsOn": [
    "CreateWait0"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/CreateWait1/Default"
   }
  },
  "DeletWait1": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "0cebf6d33a346f8fda1e439b4fe2758b0d1fe60a0436547ff3a0f785d6bbe5d0"
   },
   "DependsOn": [
    "ControlAFSBPCloudTrail5",
    "ControlAFSBPCodeBuild2",
    "ControlAFSBPConfig1",
    "ControlAFSBPEC21",
    "ControlAFSBPEC22",
    "DeletWait0"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/DeletWait1/Default"
   }
  },
  "CreateWait2": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "4eeec80909e734b4d82444fd0ddd6b3d187ed197b1129c2a04ae559bb8a79a01"
   },
   "DependsOn": [
    "CreateWait1"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/CreateWait2/Default"
   }
  },
  "DeletWait2": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "4eeec80909e734b4d82444fd0ddd6b3d187ed197b1129c2a04ae559bb8a79a01"
   },
   "DependsOn": [
    "ControlAFSBPEC215",
    "ControlAFSBPEC26",
    "ControlAFSBPEC27",
    "ControlAFSBPIAM3",
    "ControlAFSBPIAM7",
    "DeletWait1"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/DeletWait2/Default"
   }
  },
  "CreateWait3": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "8cdab6789e143c83cea5bfffc598bf67e22f001038e269f5763ac3843b13840e"
   },
   "DependsOn": [
    "CreateWait2"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/CreateWait3/Default"
   }
  },
  "DeletWait3": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "8cdab6789e143c83cea5bfffc598bf67e22f001038e269f5763ac3843b13840e"
   },
   "DependsOn": [
    "ControlAFSBPIAM8",
    "ControlAFSBPLambda1",
    "ControlAFSBPRDS1",
    "ControlAFSBPRDS2",
    "ControlAFSBPRDS4",
    "DeletWait2"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/DeletWait3/Default"
   }
  },
  "CreateWait4": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "2125fed1bd952ea3553f40951c9f1cdd9b0915433ed1e4ef12d98fa5fff89bd3"
   },
   "DependsOn": [
    "CreateWait3"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/CreateWait4/Default"
   }
  },
  "DeletWait4": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "2125fed1bd952ea3553f40951c9f1cdd9b0915433ed1e4ef12d98fa5fff89bd3"
   },
   "DependsOn": [
    "ControlAFSBPRDS13",
    "ControlAFSBPRDS5",
    "ControlAFSBPRDS6",
    "ControlAFSBPRDS7",
    "ControlAFSBPRDS8",
    "DeletWait3"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/DeletWait4/Default"
   }
  },
  "CreateWait5": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "3bf6d3e9a1d0de0559edd6f9d5cb8b96f53a6efe2767f0ed64e03e9c0647ecf7"
   },
   "DependsOn": [
    "CreateWait4"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/CreateWait5/Default"
   }
  },
  "DeletWait5": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "3bf6d3e9a1d0de0559edd6f9d5cb8b96f53a6efe2767f0ed64e03e9c0647ecf7"
   },
   "DependsOn": [
    "ControlAFSBPRDS16",
    "ControlAFSBPRedshift1",
    "ControlAFSBPRedshift3",
    "ControlAFSBPRedshift4",
    "ControlAFSBPRedshift6",
    "DeletWait4"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/DeletWait5/Default"
   }
  },
  "CreateWait6": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "7dbc18dd5db4733461dcbf69fd63ef615f511374c72aadd7a4f018226765d854"
   },
   "DependsOn": [
    "CreateWait5"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/CreateWait6/Default"
   }
  },
  "DeletWait6": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "7dbc18dd5db4733461dcbf69fd63ef615f511374c72aadd7a4f018226765d854"
   },
   "DependsOn": [
    "ControlAFSBPS31",
    "ControlAFSBPS32",
    "ControlAFSBPS34",
    "ControlAFSBPS35",
    "ControlAFSBPS36",
    "DeletWait5"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/DeletWait6/Default"
   }
  },
  "CreateWait7": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 1,
    "UpdateIntervalSeconds": 1,
    "DeleteIntervalSeconds": 0,
    "DocumentPropertiesHash": "7a3d55e09a644da740cefbc23f7afb0455bb73036f43c280e1e0562e4fd0e1dc"
   },
   "DependsOn": [
    "CreateWait6"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/CreateWait7/Default"
   }
  },
  "DeletWait7": {
   "Type": "Custom::Wait",
   "Properties": {
    "ServiceToken": {
     "Ref": "WaitProviderServiceToken"
    },
    "CreateIntervalSeconds": 0,
    "UpdateIntervalSeconds": 0,
    "DeleteIntervalSeconds": 0.5,
    "DocumentPropertiesHash": "7a3d55e09a644da740cefbc23f7afb0455bb73036f43c280e1e0562e4fd0e1dc"
   },
   "DependsOn": [
    "ControlAFSBPSNS1",
    "ControlAFSBPSNS2",
    "ControlAFSBPSQS1",
    "DeletWait6"
   ],
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "AFSBPMemberStack/DeletWait7/Default"
   }
  }
 }
}